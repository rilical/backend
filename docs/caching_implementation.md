# RemitScout Caching System: Implementation Guide

**Version: 1.0**

## Overview

RemitScout uses a Redis-based caching system implemented with django-redis to improve performance and reduce load on external APIs. This document describes the architecture, implementation details, and troubleshooting methods for the system.

## Caching Architecture

The caching system has four main components:

1. **Quote Cache**: Stores complete quote responses for specific corridors and amounts
2. **Corridor Rate Cache**: Stores exchange rates and fee structure data independent of amount
3. **Corridor Availability Cache**: Stores whether corridors are supported by providers
4. **Provider Cache**: Stores provider-specific information

## Caching Strategy Layers

The caching strategy uses a multi-layered approach:

1. **Exact Match Cache**: First attempts to find an exact match for the query parameters
2. **Corridor Availability Check**: Verifies if a corridor is supported before making expensive API calls
3. **Corridor Rate Calculation**: Uses cached rate information to calculate quotes for different amounts
4. **External API Fallback**: If no cache hits, fetches fresh data from providers

## Cache Key Structure

Cache keys are generated using standardized functions from `quotes/key_generators.py`:

| Cache Type | Key Format | Example |
|------------|------------|---------|
| Quote | `v1:fee:{source_country}:{dest_country}:{source_currency}:{dest_currency}:{amount}` | `v1:fee:US:MX:USD:MXN:500.0` |
| Provider | `provider:{provider_id}` | `provider:Wise` |
| Corridor | `corridor:{source_country}:{dest_country}` | `corridor:US:MX` |
| Corridor Rate | `corridor_rate:{source_country}:{dest_country}:{source_currency}:{dest_currency}` | `corridor_rate:US:MX:USD:MXN` |

The `v1:` prefix enables version upgrades without breaking compatibility with existing cached data.

## Redis Implementation Details

Django-redis stores keys with this format: `{prefix}:{version}:{key}`

- `prefix`: Set in `settings.py` as `KEY_PREFIX` (default: "remitscout")
- `version`: Cache version (default: 1)
- `key`: The cache key generated by our key generators

For example: `remitscout:1:v1:fee:GB:MX:GBP:MXN:500.0`

## Cache TTL Settings

The system uses the following cache timeouts:

| Cache Type | Default TTL | Setting Name |
|------------|-------------|--------------|
| Quotes | 30 minutes | `QUOTE_CACHE_TTL` |
| Corridor availability | 12 hours | `CORRIDOR_CACHE_TTL` |
| Corridor rates | 3 hours | `CORRIDOR_RATE_CACHE_TTL` |
| Provider details | 24 hours | `PROVIDER_CACHE_TTL` |

Each TTL includes jitter (random variation) to prevent the "thundering herd" problem where many cache entries expire simultaneously.

## Cache Invalidation

The system uses three cache invalidation strategies:

1. **Automatic invalidation** via Django signals:
   - When a `FeeQuote` is saved or deleted, related cache entries are invalidated
   - When a `Provider` is updated, its cache entries are invalidated

2. **Manual invalidation** via management commands:
   - `python manage.py cache_utils --action invalidate_all` - Invalidate all quotes
   - `python manage.py cache_utils --action invalidate_corridor --source_country US --dest_country MX`
   - `python manage.py cache_utils --action invalidate_provider --provider_id Wise`

3. **Scheduled invalidation** via Celery tasks:
   - `refresh_cache_daily` - Daily full cache refresh during off-peak hours
   - `refresh_popular_corridor_caches` - Hourly refresh of popular corridors
   - `refresh_popular_quote_caches` - Bi-hourly refresh of common queries

## Troubleshooting

### Common Issues

#### Cache Miss When Expected Hit

If you're experiencing unexpected cache misses:

1. **Check key generation**: Ensure cache keys are consistent
2. **Use Django's cache interface**: Always use `cache.get`, `cache.set` instead of direct Redis commands
3. **Check serialization**: Django-redis uses Pickle serialization by default, not JSON

#### Debugging Cache Issues

To debug cache problems:

1. Check if a key exists in Redis:
   ```
   redis-cli -n 1 keys "remitscout:1:v1:fee:*"
   ```

2. Use the Python shell:
   ```python
   from django.core.cache import cache
   from quotes.key_generators import get_quote_cache_key

   # Generate a cache key
   cache_key = get_quote_cache_key("GB", "MX", "GBP", "MXN", 500.0)
   
   # Check if it exists
   cached_data = cache.get(cache_key)
   print(f"Found in cache: {cached_data is not None}")
   ```

3. Review the debug_cache tool in the quotes app.

### Best Practices

1. Always use Django's cache API for consistency:

```python
from django.core.cache import cache
from quotes.key_generators import get_quote_cache_key

# Generate cache key
cache_key = get_quote_cache_key(source_country, dest_country, source_currency, dest_currency, amount)

# Set value
cache.set(cache_key, data, timeout=settings.QUOTE_CACHE_TTL)

# Get value
cached_data = cache.get(cache_key)
```

2. Never directly manipulate Redis keys, as this bypasses Django's serialization.

## Performance Considerations

- The caching system reduces load on external provider APIs by up to 90%
- Cache TTL jitter prevents cache stampedes
- Preloading popular corridors and amounts improves user experience
- The system gracefully degrades to direct API calls when cache misses occur 