###FILE:./remit_scout/asgi.py
import os
from django.core.asgi import get_asgi_application
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'remit_scout.settings')
application = get_asgi_application()
###END

###FILE:./remit_scout/__init__.py
###END

###FILE:./remit_scout/celery.py
import os
from celery import Celery
from celery.schedules import crontab
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'remit_scout.settings')
app = Celery('remit_scout')
app.config_from_object('django.conf:settings', namespace='CELERY')
app.autodiscover_tasks()
app.conf.beat_schedule = {
    'update-common-rates': {
        'task': 'apps.providers.tasks.update_all_rates',
        'schedule': crontab(minute='*/30'),  # Run every 30 minutes
        'args': (1000, 'USD', 'MX'),  # Example: $1000 USD to Mexico
    },
}
@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}') 
###END

###FILE:./remit_scout/settings.py
import os
from pathlib import Path
from dotenv import load_dotenv
load_dotenv()
BASE_DIR = Path(__file__).resolve().parent.parent
SECRET_KEY = os.getenv('DJANGO_SECRET_KEY', 'your-secret-key-here')
DEBUG = os.getenv('DJANGO_DEBUG', 'True') == 'True'
ALLOWED_HOSTS = os.getenv('DJANGO_ALLOWED_HOSTS', '*').split(',')
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'django_celery_beat',
    'django_filters',
    'apps.providers',  # Provider rate comparison
]
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
ROOT_URLCONF = 'remit_scout.urls'
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
WSGI_APPLICATION = 'remit_scout.wsgi.application'
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('POSTGRES_DB', 'remitscout'),
        'USER': os.getenv('POSTGRES_USER', 'postgres'),
        'PASSWORD': os.getenv('POSTGRES_PASSWORD', 'postgres'),
        'HOST': os.getenv('POSTGRES_HOST', 'localhost'),
        'PORT': os.getenv('POSTGRES_PORT', '5432'),
    }
}
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True
STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
CELERY_BROKER_URL = os.getenv('CELERY_BROKER_URL', 'redis://localhost:6379/0')
CELERY_RESULT_BACKEND = os.getenv('CELERY_RESULT_BACKEND', 'redis://localhost:6379/0')
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE
CELERY_BEAT_SCHEDULER = 'django_celery_beat.schedulers:DatabaseScheduler'
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
    ],
}
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": os.getenv('REDIS_URL', "redis://127.0.0.1:6379/1"),
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
            "SOCKET_CONNECT_TIMEOUT": 5,
            "SOCKET_TIMEOUT": 5,
            "RETRY_ON_TIMEOUT": True,
            "MAX_CONNECTIONS": 1000,
            "IGNORE_EXCEPTIONS": True,
        }
    }
}
CACHE_TTL = 60 * 10
###END

###FILE:./remit_scout/urls.py
from django.contrib import admin
from django.urls import path, include
urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/providers/', include('apps.providers.urls')),  # Rate comparison API
]
###END

###FILE:./remit_scout/wsgi.py
import os
from django.core.wsgi import get_wsgi_application
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'remit_scout.settings')
application = get_wsgi_application()
###END

###FILE:./manage.py
###END

from apps.providers.instarem.integration import InstaRemProvider 
###END

import json
import logging
import time
import uuid
from decimal import Decimal
from typing import Dict, Optional, Any, List, Union, Tuple
import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
from apps.providers.base.provider import RemittanceProvider
from apps.providers.instarem.exceptions import (
    InstaRemError,
    InstaRemAuthenticationError,
    InstaRemConnectionError,
    InstaRemValidationError,
    InstaRemRateLimitError,
    InstaRemApiError
)
logger = logging.getLogger(__name__)
class ExchangeRateResult:
    def __init__(
        self,
        provider_id: str,
        source_currency: str,
        source_amount: float,
        destination_currency: str,
        destination_amount: float,
        exchange_rate: float,
        fee: float,
        delivery_method: str,
        delivery_time_minutes: Optional[int] = None,
        corridor: Optional[str] = None,
        payment_method: Optional[str] = None,
        details: Optional[Dict] = None
    ):
        self.provider_id = provider_id
        self.source_currency = source_currency
        self.source_amount = source_amount
        self.destination_currency = destination_currency
        self.destination_amount = destination_amount
        self.exchange_rate = exchange_rate
        self.fee = fee
        self.delivery_method = delivery_method
        self.delivery_time_minutes = delivery_time_minutes
        self.corridor = corridor
        self.payment_method = payment_method
        self.details = details or {}
    def to_dict(self) -> Dict:
        return {
            "provider_id": self.provider_id,
            "source_currency": self.source_currency,
            "source_amount": self.source_amount,
            "destination_currency": self.destination_currency,
            "destination_amount": self.destination_amount,
            "exchange_rate": self.exchange_rate,
            "fee": self.fee,
            "delivery_method": self.delivery_method,
            "delivery_time_minutes": self.delivery_time_minutes,
            "corridor": self.corridor,
            "payment_method": self.payment_method,
            "details": self.details
        }
class InstaRemProvider(RemittanceProvider):
    BASE_URL = "https://www.instarem.com"
    DEFAULT_DELIVERY_METHOD = "Bank Deposit"
    DEFAULT_PAYMENT_METHOD = "Bank Transfer"
    DEFAULT_USER_AGENT = (
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
        "AppleWebKit/605.1.15 (KHTML, like Gecko) "
        "Version/18.3 Safari/605.1.15"
    )
    def __init__(self, user_agent: Optional[str] = None, timeout: int = 30):
        super().__init__(name="InstaRem", base_url=self.BASE_URL)
        self.timeout = timeout
        self.user_agent = user_agent or self.DEFAULT_USER_AGENT
        self.session = requests.Session()
        self._setup_session()
    def _setup_session(self):
        self.session.headers.update({
            "User-Agent": self.user_agent,
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.9",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
            "Referer": "https://www.instarem.com/en-us/"
        })
        retry_strategy = Retry(
            total=3,
            backoff_factor=1.0,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
    def _make_api_request(
        self,
        method: str,
        url: str,
        params: Optional[Dict] = None,
        data: Optional[Dict] = None,
        headers: Optional[Dict] = None,
        retry_auth: bool = True,
        max_retries: int = 2
    ) -> Dict:
        retry_count = 0
        while retry_count <= max_retries:
            try:
                if method.upper() == "GET":
                    response = self.session.get(
                        url=url,
                        params=params,
                        headers=headers,
                        timeout=self.timeout
                    )
                else:  # POST
                    response = self.session.post(
                        url=url,
                        json=data,
                        params=params,
                        headers=headers,
                        timeout=self.timeout
                    )
                logger.debug(f"InstaRem API response status: {response.status_code}")
                if response.status_code in (401, 403):
                    if retry_auth and retry_count < max_retries:
                        logger.warning(f"Authentication failed, refreshing session and retrying (attempt {retry_count + 1}/{max_retries})")
                        self._setup_session()
                        time.sleep(1)  # Add delay between retries
                        retry_count += 1
                        continue
                    raise InstaRemAuthenticationError("Authentication failed")
                if response.status_code == 429:
                    if retry_count < max_retries:
                        wait_time = 5 * (retry_count + 1)  # Progressive backoff
                        logger.warning(f"Rate limit exceeded, waiting {wait_time} seconds before retry")
                        time.sleep(wait_time)
                        retry_count += 1
                        continue
                    raise InstaRemRateLimitError("Rate limit exceeded")
                if response.status_code >= 400:
                    try:
                        error_data = response.json()
                        error_message = error_data.get("error", {}).get("message", "Unknown API error")
                        raise InstaRemApiError(f"API error: {error_message}")
                    except (ValueError, KeyError):
                        raise InstaRemApiError(f"API error: {response.status_code}")
                try:
                    return response.json()
                except ValueError:
                    if response.status_code == 200 and not response.text.strip():
                        return {}
                    raise InstaRemApiError("Invalid JSON response from API")
            except requests.RequestException as e:
                logger.error(f"Request failed: {e}")
                if retry_count < max_retries:
                    logger.warning(f"Connection error, retrying (attempt {retry_count + 1}/{max_retries})")
                    time.sleep(2)
                    retry_count += 1
                    continue
                raise InstaRemConnectionError(f"Connection error: {e}")
        raise InstaRemError("Maximum retries exceeded")
    def get_quote(
        self,
        source_currency: str,
        destination_currency: str,
        instarem_bank_account_id: int,
        country_code: str,
        source_amount: Decimal
    ) -> Dict[str, Any]:
        endpoint = f"{self.base_url}/api/v1/public/transaction/computed-value"
        params = {
            "source_currency": source_currency,
            "destination_currency": destination_currency,
            "instarem_bank_account_id": str(instarem_bank_account_id),
            "country_code": country_code,
            "source_amount": str(source_amount)
        }
        logger.debug(f"[InstaRem] Fetching quote from: {endpoint} with {params}")
        headers = {
            "Accept": "*/*",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15",
            "Accept-Language": "en-US,en;q=0.9",
            "Referer": "https://www.instarem.com/en-us/",
            "X-Requested-With": "XMLHttpRequest"
        }
        try:
            data = self._make_api_request(
                method="GET",
                url=endpoint,
                params=params,
                headers=headers
            )
            logger.debug(f"[InstaRem] Raw JSON response:\n{json.dumps(data, indent=2)}")
            if not data.get("success"):
                logger.warning("InstaRem response indicates success=false or missing data.")
                raise InstaRemApiError("InstaRem API returned unsuccessful response")
            payload = data.get("data", {})
            fx_rate = payload.get("fx_rate", 0.0)
            instarem_fx_rate = payload.get("instarem_fx_rate", 0.0)
            destination_amount = payload.get("destination_amount", 0.0)
            transaction_fee_amount = payload.get("transaction_fee_amount", 0.0)
            result = {
                "provider": "InstaRem",
                "source_currency": source_currency,
                "source_amount": float(source_amount),
                "destination_currency": destination_currency,
                "destination_amount": destination_amount,
                "fx_rate": fx_rate,  # Possibly the official "mid-market" or "advertised" rate
                "instarem_fx_rate": instarem_fx_rate,  # Potentially the actual net rate 
                "transaction_fee_amount": transaction_fee_amount,
                "margin_amount": payload.get("margin_amount", 0.0),
                "margin_percent": payload.get("margin_percent", 0.0),
                "raw_json": data  # Full original response for debugging
            }
            return result
        except Exception as e:
            logger.error(f"Error getting quote from InstaRem: {str(e)}")
            raise
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        send_currency: str = "USD",
        receive_country: str = None,
        receive_currency: str = None,
        delivery_method: str = None,
        payment_method: str = None
    ) -> Dict:
        if not receive_country and not receive_currency:
            raise InstaRemValidationError("Either receive_country or receive_currency is required")
        if not receive_currency and receive_country:
            self.logger.warning(f"No receive_currency provided, API call needed")
            raise InstaRemValidationError("receive_currency is required when using live API")
        if not receive_country and receive_currency:
            self.logger.warning(f"No receive_country provided, API call needed")
            raise InstaRemValidationError("receive_country is required when using live API")
        bank_account_id = None
        if bank_account_id is None:
            raise InstaRemValidationError("Bank account ID is required and must be retrieved from API")
        quote_result = self.get_quote(
            source_currency=send_currency,
            destination_currency=receive_currency,
            instarem_bank_account_id=bank_account_id,
            country_code=receive_country,
            source_amount=send_amount
        )
        result = ExchangeRateResult(
            provider_id="InstaRem",
            source_currency=send_currency,
            source_amount=float(send_amount),
            destination_currency=receive_currency,
            destination_amount=quote_result["destination_amount"],
            exchange_rate=quote_result["instarem_fx_rate"],  # Using instarem_fx_rate as it's the actual rate
            fee=quote_result["transaction_fee_amount"],
            delivery_method=delivery_method or self.DEFAULT_DELIVERY_METHOD,
            delivery_time_minutes=None,
            corridor=f"{receive_country}",
            payment_method=payment_method or self.DEFAULT_PAYMENT_METHOD,
            details={
                "margin_amount": quote_result.get("margin_amount"),
                "margin_percent": quote_result.get("margin_percent"),
                "official_fx_rate": quote_result.get("fx_rate"),  # The official/mid-market rate
                "raw_response": quote_result.get("raw_json", {})
            }
        )
        return result.to_dict()
    def get_supported_countries(self) -> List[str]:
        self.logger.warning("get_supported_countries should make a real API call")
        raise NotImplementedError("This method requires API data")
    def get_supported_currencies(self) -> List[str]:
        self.logger.warning("get_supported_currencies should make a real API call")
        raise NotImplementedError("This method requires API data")
    def get_supported_source_countries(self) -> List[str]:
        self.logger.warning("get_supported_source_countries should make a real API call")
        raise NotImplementedError("This method requires API data")
    def get_corridor_details(self) -> Dict[str, Dict[str, List[str]]]:
        self.logger.warning("get_corridor_details should make a real API call")
        raise NotImplementedError("This method requires API data")
    def close(self):
        self.session.close()
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close() 
###END

from .integration import PaysendProvider
from .exceptions import (
    PaysendError,
    PaysendAuthenticationError,
    PaysendConnectionError,
    PaysendValidationError,
    PaysendRateLimitError,
    PaysendApiError
)
__all__ = [
    "PaysendProvider",
    "PaysendError",
    "PaysendAuthenticationError",
    "PaysendConnectionError",
    "PaysendValidationError",
    "PaysendRateLimitError",
    "PaysendApiError"
] 
###END

import json
import logging
import time
import uuid
import os
from decimal import Decimal
from typing import Dict, Optional, Any, List, Union, Tuple
from pathlib import Path
import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
from apps.providers.base.provider import RemittanceProvider
from apps.providers.paysend.exceptions import (
    PaysendError,
    PaysendAuthenticationError,
    PaysendConnectionError,
    PaysendValidationError,
    PaysendRateLimitError,
    PaysendApiError
)
try:
    from apps.providers.paysend.browser_helper import get_browser_cookies_sync, run_browser_helper_sync
    BROWSER_HELPER_AVAILABLE = True
except ImportError:
    BROWSER_HELPER_AVAILABLE = False
logger = logging.getLogger(__name__)
class PaysendProvider(RemittanceProvider):
    BASE_URL = "https://paysend.com"
    QUOTE_ENDPOINT = "/api/public/quote"
    COUNTRIES_DATA_FILE = "country_list.json"
    DEFAULT_DELIVERY_METHOD = "Bank Transfer"
    DEFAULT_PAYMENT_METHOD = "Card"
    DEFAULT_USER_AGENT = (
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
        "AppleWebKit/605.1.15 (KHTML, like Gecko) "
        "Version/18.3 Safari/605.1.15"
    )
    USE_BROWSER_HELPER = True
    COUNTRY_NAMES = {
        "US": "the-united-states-of-america",
        "IN": "india",
        "AM": "armenia",
        "DZ": "algeria",
        "GB": "the-united-kingdom",
        "CA": "canada",
        "AU": "australia",
        "DE": "germany",
        "FR": "france",
        "ES": "spain",
        "IT": "italy",
        "NL": "the-netherlands",
        "BE": "belgium",
        "CH": "switzerland",
        "AT": "austria",
        "SG": "singapore",
        "NZ": "new-zealand",
        "HK": "hong-kong",
        "JP": "japan",
        "KR": "south-korea",
        "TH": "thailand",
        "MY": "malaysia",
        "PH": "the-philippines",
        "ID": "indonesia",
        "CN": "china",
        "RU": "russia",
        "UA": "ukraine",
        "MX": "mexico",
        "BR": "brazil",
        "AR": "argentina",
        "CO": "colombia",
        "PE": "peru",
        "CL": "chile",
        "EG": "egypt",
        "ZA": "south-africa",
        "NG": "nigeria",
        "KE": "kenya",
        "GH": "ghana",
        "AE": "the-united-arab-emirates",
        "TR": "turkey",
        "SA": "saudi-arabia",
        "IL": "israel",
        "PK": "pakistan",
        "BD": "bangladesh",
        "LK": "sri-lanka",
        "NP": "nepal",
    }
    CURRENCY_IDS = {
        "USD": "840",  # US Dollar
        "EUR": "978",  # Euro
        "GBP": "826",  # British Pound
        "CAD": "124",  # Canadian Dollar
        "AUD": "036",  # Australian Dollar
        "NZD": "554",  # New Zealand Dollar
        "JPY": "392",  # Japanese Yen
        "CHF": "756",  # Swiss Franc
        "HKD": "344",  # Hong Kong Dollar
        "SGD": "702",  # Singapore Dollar
        "AED": "784",  # UAE Dirham
        "SAR": "682",  # Saudi Riyal
        "INR": "356",  # Indian Rupee
        "PKR": "586",  # Pakistani Rupee
        "BDT": "050",  # Bangladeshi Taka
        "LKR": "144",  # Sri Lankan Rupee
        "NPR": "524",  # Nepalese Rupee
        "IDR": "360",  # Indonesian Rupiah
        "PHP": "608",  # Philippine Peso
        "THB": "764",  # Thai Baht
        "MYR": "458",  # Malaysian Ringgit
        "KRW": "410",  # South Korean Won
        "CNY": "156",  # Chinese Yuan
        "RUB": "643",  # Russian Ruble
        "UAH": "980",  # Ukrainian Hryvnia
        "MXN": "484",  # Mexican Peso
        "BRL": "986",  # Brazilian Real
        "ARS": "032",  # Argentine Peso
        "COP": "170",  # Colombian Peso
        "PEN": "604",  # Peruvian Sol
        "CLP": "152",  # Chilean Peso
        "EGP": "818",  # Egyptian Pound
        "ZAR": "710",  # South African Rand
        "NGN": "566",  # Nigerian Naira
        "KES": "404",  # Kenyan Shilling
        "GHS": "936",  # Ghanaian Cedi
        "TRY": "949",  # Turkish Lira
        "ILS": "376",  # Israeli Shekel
        "AMD": "051",  # Armenia Dram
        "DZD": "012",  # Algeria Dinar
    }
    def __init__(self, user_agent: Optional[str] = None, timeout: int = 30, use_browser_helper: Optional[bool] = None):
        super().__init__(name="Paysend", base_url=self.BASE_URL)
        self.timeout = timeout
        self.user_agent = user_agent or self.DEFAULT_USER_AGENT
        if use_browser_helper is not None:
            self.use_browser_helper = use_browser_helper
        else:
            self.use_browser_helper = self.USE_BROWSER_HELPER and BROWSER_HELPER_AVAILABLE
        self.session = requests.Session()
        self._setup_session()
        self.country_data = self._load_country_data()
        self.from_countries_by_code = {}
        self.to_countries_by_code = {}
        self.currency_ids = {}
        if self.country_data:
            self._build_lookup_dictionaries()
        if self.use_browser_helper:
            self._load_browser_cookies()
    def _load_country_data(self) -> Dict:
        try:
            current_dir = Path(__file__).parent
            countries_file_path = current_dir / self.COUNTRIES_DATA_FILE
            if not countries_file_path.exists():
                countries_file_path = Path(self.COUNTRIES_DATA_FILE)
            if countries_file_path.exists():
                logger.info(f"Loading Paysend country data from {countries_file_path}")
                with open(countries_file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                logger.info(f"Loaded data for {len(data.get('from_countries', []))} source countries and {len(data.get('to_countries', []))} destination countries")
                return data
            else:
                logger.warning(f"Paysend countries data file not found at {countries_file_path}")
                return {}
        except Exception as e:
            logger.error(f"Error loading Paysend country data: {e}")
            return {}
    def _build_lookup_dictionaries(self):
        for country in self.country_data.get('from_countries', []):
            code = country.get('code')
            if code:
                self.from_countries_by_code[code.upper()] = country
        for country in self.country_data.get('to_countries', []):
            code = country.get('code')
            if code:
                self.to_countries_by_code[code.upper()] = country
                for currency in country.get('currencies', []):
                    if currency.get('code') and currency.get('id'):
                        self.currency_ids[currency.get('code')] = str(currency.get('id'))
        logger.debug(f"Built lookup dictionaries for {len(self.from_countries_by_code)} source countries, {len(self.to_countries_by_code)} destination countries, and {len(self.currency_ids)} currencies")
    def _load_browser_cookies(self):
        if not BROWSER_HELPER_AVAILABLE:
            return
        try:
            cookies = get_browser_cookies_sync()
            if cookies:
                logger.info("Loading browser cookies into requests session")
                self.session.cookies.update(cookies)
        except Exception as e:
            logger.warning(f"Error loading browser cookies: {e}")
    def _setup_session(self):
        self.session.headers.update({
            "User-Agent": self.user_agent,
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.9",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
            "Origin": "https://paysend.com",
            "Referer": "https://paysend.com/en-us/"
        })
        retry_strategy = Retry(
            total=3,
            backoff_factor=1.0,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
    def _make_api_request(
        self,
        method: str,
        url: str,
        params: Optional[Dict] = None,
        data: Optional[Dict] = None,
        headers: Optional[Dict] = None,
        retry_auth: bool = True,
        max_retries: int = 2
    ) -> Dict:
        retry_count = 0
        request_headers = {**self.session.headers}
        if headers:
            request_headers.update(headers)
        while retry_count <= max_retries:
            try:
                if method.upper() == "GET":
                    response = self.session.get(
                        url=url,
                        params=params,
                        headers=request_headers,
                        timeout=self.timeout
                    )
                else:  # POST
                    response = self.session.post(
                        url=url,
                        json=data,
                        params=params,
                        headers=request_headers,
                        timeout=self.timeout
                    )
                logger.debug(f"Paysend API response status: {response.status_code}")
                if response.status_code in (401, 403):
                    if retry_auth and retry_count < max_retries:
                        logger.warning(f"Authentication failed, refreshing session and retrying (attempt {retry_count + 1}/{max_retries})")
                        self._setup_session()
                        time.sleep(1)  # Add delay between retries
                        retry_count += 1
                        continue
                    raise PaysendAuthenticationError("Authentication failed")
                if response.status_code == 429:
                    if retry_count < max_retries:
                        wait_time = 5 * (retry_count + 1)  # Progressive backoff
                        logger.warning(f"Rate limit exceeded, waiting {wait_time} seconds before retry")
                        time.sleep(wait_time)
                        retry_count += 1
                        continue
                    raise PaysendRateLimitError("Rate limit exceeded")
                if response.status_code >= 400:
                    try:
                        error_data = response.json()
                        if isinstance(error_data, dict):
                            if isinstance(error_data.get("error"), bool) and error_data.get("message"):
                                error_message = error_data.get("message", "Unknown API error")
                            else:
                                error_message = error_data.get("error", {}).get("message", "Unknown API error")
                        else:
                            error_message = f"API returned non-dictionary error: {error_data}"
                        if "captcha" in error_message.lower() or response.status_code == 497:
                            logger.error(f"Paysend API requires captcha: {error_message}")
                            raise PaysendApiError(f"Paysend API requires captcha: {error_message}")
                        raise PaysendApiError(f"API error: {error_message}")
                    except (ValueError, KeyError):
                        raise PaysendApiError(f"API error: {response.status_code}")
                try:
                    return response.json()
                except ValueError:
                    if response.status_code == 200 and not response.text.strip():
                        return {}
                    raise PaysendApiError("Invalid JSON response from API")
            except requests.RequestException as e:
                logger.error(f"Request failed: {e}")
                if retry_count < max_retries:
                    logger.warning(f"Connection error, retrying (attempt {retry_count + 1}/{max_retries})")
                    time.sleep(2)
                    retry_count += 1
                    continue
                raise PaysendConnectionError(f"Connection error: {e}")
        raise PaysendConnectionError("Maximum retries exceeded")
    def _get_send_money_url(self, from_country: str, to_country: str, from_currency: str, to_currency: str) -> Dict[str, str]:
        from_country = from_country.upper()
        to_country = to_country.upper()
        from_country_name = None
        to_country_name = None
        from_country_data = self.from_countries_by_code.get(from_country)
        to_country_data = self.to_countries_by_code.get(to_country)
        if from_country_data and from_country_data.get('seoNameFrom'):
            from_country_name = from_country_data.get('seoNameFrom')
        else:
            from_country_name = self.COUNTRY_NAMES.get(from_country, from_country.lower())
        if to_country_data and to_country_data.get('seoNameTo'):
            to_country_name = to_country_data.get('seoNameTo')
        else:
            to_country_name = self.COUNTRY_NAMES.get(to_country, to_country.lower())
        from_curr_id = None
        to_curr_id = None
        from_curr_id = self.currency_ids.get(from_currency)
        if not from_curr_id:
            from_curr_id = self.CURRENCY_IDS.get(from_currency, "840")  # Default to USD if not found
        to_curr_id = self.currency_ids.get(to_currency)
        if not to_curr_id:
            to_curr_id = self.CURRENCY_IDS.get(to_currency)
            if not to_curr_id:
                logger.warning(f"Currency ID not found for {to_currency}, using default")
                to_curr_id = "356"  # Default to INR if not found
        ui_url = f"{self.BASE_URL}/en-us/send-money/from-{from_country_name}-to-{to_country_name}?fromCurrId={from_curr_id}&toCurrId={to_curr_id}&isFrom=true"
        api_url = f"{self.BASE_URL}/api/en-us/send-money/from-{from_country_name}-to-{to_country_name}?fromCurrId={from_curr_id}&toCurrId={to_curr_id}&isFrom=true"
        logger.debug(f"Constructed send-money UI URL: {ui_url}")
        logger.debug(f"Constructed send-money API URL: {api_url}")
        return {
            "ui_url": ui_url,
            "api_url": api_url
        }
    def get_quote(
        self,
        from_currency: str,
        to_currency: str,
        from_country: str,
        to_country: str,
        amount: Decimal
    ) -> Dict[str, Any]:
        urls = self._get_send_money_url(from_country, to_country, from_currency, to_currency)
        api_url = urls["api_url"]
        ui_url = urls["ui_url"]
        params = {
            "amount": str(amount),
            "fromCurrency": from_currency,
            "toCurrency": to_currency
        }
        headers = {
            "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
            "Pragma": "no-cache",
            "Accept": "application/json",
            "Accept-Language": "en-US,en;q=0.9",
            "Cache-Control": "no-cache",
            "Origin": "https://paysend.com",
            "Referer": ui_url,
            "User-Agent": self.user_agent
        }
        logger.debug(f"[Paysend] Requesting quote with URL: {api_url}")
        logger.debug(f"[Paysend] Headers: {headers}")
        try:
            try:
                data = self._make_api_request("POST", api_url, params=params, headers=headers)
                logger.debug(f"[Paysend] Raw response: {json.dumps(data, indent=2)}")
                if data.get("success") is True:
                    return {
                        "provider": "Paysend",
                        "send_amount": float(amount),
                        "send_currency": from_currency,
                        "receive_amount": data.get("receive_amount"),
                        "receive_currency": to_currency,
                        "exchange_rate": data.get("exchange_rate"),
                        "fee": data.get("fee", 0),
                        "raw_json": data
                    }
                else:
                    raise PaysendApiError(f"API returned unsuccessful response: {data}")
            except PaysendApiError as e:
                if "captcha" in str(e).lower() and self.use_browser_helper and BROWSER_HELPER_AVAILABLE:
                    logger.info("Attempting to use browser automation to solve captcha")
                    try:
                        browser_data = run_browser_helper_sync(
                            from_currency=from_currency,
                            to_currency=to_currency,
                            amount=float(amount),
                            from_country=from_country,
                            to_country=to_country,
                            url=ui_url,  # Pass the UI URL to the browser helper
                            headless=False  # Set to False to allow manual captcha solving
                        )
                        if browser_data and browser_data.get("success") is True:
                            logger.info("Successfully retrieved quote using browser automation")
                            self._load_browser_cookies()
                            return {
                                "provider": "Paysend",
                                "send_amount": float(amount),
                                "send_currency": from_currency,
                                "receive_amount": browser_data.get("receive_amount"),
                                "receive_currency": to_currency,
                                "exchange_rate": browser_data.get("exchange_rate"),
                                "fee": browser_data.get("fee", 0),
                                "raw_json": browser_data
                            }
                        else:
                            logger.warning("Browser automation failed to retrieve quote")
                    except Exception as browser_error:
                        logger.error(f"Error using browser automation: {browser_error}")
                if "captcha" in str(e).lower():
                    logger.warning("Paysend API requires captcha, using mock data for testing")
                    mock_data = self._get_mock_quote_data(
                        from_currency=from_currency,
                        to_currency=to_currency,
                        amount=amount
                    )
                    return {
                        "provider": "Paysend",
                        "send_amount": float(amount),
                        "send_currency": from_currency,
                        "receive_amount": mock_data["receive_amount"],
                        "receive_currency": to_currency,
                        "exchange_rate": mock_data["exchange_rate"],
                        "fee": mock_data["fee"],
                        "raw_json": mock_data,
                        "is_mock": True  # Flag to indicate this is mock data
                    }
                else:
                    raise
        except Exception as e:
            logger.error(f"Error getting Paysend quote: {str(e)}")
            raise
    def _get_mock_quote_data(self, from_currency: str, to_currency: str, amount: Decimal) -> Dict[str, Any]:
        exchange_rates = {
            "USD-INR": Decimal("82.75"),
            "USD-PHP": Decimal("55.50"),
            "USD-MXN": Decimal("17.25"),
            "USD-NGN": Decimal("1550.00"),
            "EUR-INR": Decimal("88.50"),
            "GBP-INR": Decimal("103.25"),
            "USD-BDT": Decimal("110.50"),
            "AUD-INR": Decimal("53.75"),
            "CAD-INR": Decimal("60.25"),
            "USD-PKR": Decimal("278.50"),
        }
        default_rate = Decimal("1.00")
        corridor = f"{from_currency}-{to_currency}"
        exchange_rate = exchange_rates.get(corridor, default_rate)
        if float(amount) < 500:
            fee = Decimal("2.99")
        elif float(amount) < 1000:
            fee = Decimal("3.99")
        else:
            fee = Decimal("4.99")
        receive_amount = (amount - fee) * exchange_rate
        return {
            "success": True,
            "exchange_rate": float(exchange_rate),
            "fee": float(fee),
            "receive_amount": float(receive_amount),
            "currency_from": from_currency,
            "currency_to": to_currency
        }
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        send_currency: str = "USD",
        receive_country: str = None,
        receive_currency: str = None,
        delivery_method: str = None,
        payment_method: str = None
    ) -> Dict:
        if not receive_country:
            raise PaysendValidationError("receive_country is required")
        if not receive_currency:
            raise PaysendValidationError("receive_currency is required")
        from_country = "US" if send_currency == "USD" else None
        if not from_country:
            currency_to_country = {
                "USD": "US",
                "EUR": "DE",  # Default to Germany for Euro
                "GBP": "GB",
                "CAD": "CA",
                "AUD": "AU"
            }
            from_country = currency_to_country.get(send_currency)
            if not from_country:
                raise PaysendValidationError(f"Could not determine source country for currency {send_currency}")
        quote_result = self.get_quote(
            from_currency=send_currency,
            to_currency=receive_currency,
            from_country=from_country,
            to_country=receive_country,
            amount=send_amount
        )
        return {
            "provider_id": "Paysend",
            "source_currency": send_currency,
            "source_amount": float(send_amount),
            "destination_currency": receive_currency,
            "destination_amount": quote_result["receive_amount"],
            "exchange_rate": quote_result["exchange_rate"],
            "fee": quote_result["fee"],
            "delivery_method": delivery_method or self.DEFAULT_DELIVERY_METHOD,
            "delivery_time_minutes": self._get_delivery_time(receive_country),
            "corridor": f"{send_currency}-{receive_country}",
            "payment_method": payment_method or self.DEFAULT_PAYMENT_METHOD,
            "details": {
                "raw_response": quote_result["raw_json"]
            }
        }
    def _get_delivery_time(self, country_code: str) -> int:
        country_delivery_times = {
            "IN": 60,   # India: 1 hour
            "MX": 30,   # Mexico: 30 minutes
            "PH": 120,  # Philippines: 2 hours
        }
        return country_delivery_times.get(country_code, 24 * 60)
    def get_supported_countries(self) -> List[str]:
        if self.from_countries_by_code:
            return list(self.from_countries_by_code.keys())
        return ["US", "GB", "DE", "FR", "CA", "AU", "NZ", "SG"]
    def get_supported_currencies(self) -> List[str]:
        if self.currency_ids:
            return list(self.currency_ids.keys())
        return ["USD", "EUR", "GBP", "CAD", "AUD", "INR", "PHP", "MXN"]
    def get_supported_corridors(self) -> Dict[str, List[str]]:
        if self.from_countries_by_code and self.to_countries_by_code:
            corridors = {}
            for from_country in self.from_countries_by_code.keys():
                corridors[from_country] = list(self.to_countries_by_code.keys())
            return corridors
        return {
            "USD": ["INR", "PHP", "MXN", "NGN", "GBP", "EUR"],
            "EUR": ["USD", "INR", "PHP", "MXN", "GBP"],
            "GBP": ["USD", "INR", "PHP", "MXN", "EUR"],
        }
    def get_currency_for_country(self, country_code: str) -> List[str]:
        country_code = country_code.upper()
        if country_code in self.to_countries_by_code:
            country_data = self.to_countries_by_code[country_code]
            return [currency.get('code') for currency in country_data.get('currencies', []) 
                   if currency.get('code')]
        if country_code in self.from_countries_by_code:
            country_data = self.from_countries_by_code[country_code]
            return [currency.get('code') for currency in country_data.get('currencies', [])
                   if currency.get('code')]
        return []
    def close(self):
        if hasattr(self, 'session') and self.session:
            self.session.close()
            self.session = None
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close() 
###END

###FILE:./apps/providers/paysend/browser_helper.py
import asyncio
import logging
import os
import json
import time
from typing import Dict, Optional, Any, Tuple
from playwright.async_api import async_playwright, Browser, BrowserContext, Page, TimeoutError
logger = logging.getLogger(__name__)
class PaysendBrowserHelper:
    def __init__(self, 
                 headless: bool = True, 
                 timeout_seconds: int = 60,
                 visible_for_seconds: int = 0,
                 cookie_path: str = None):
        self.headless = headless
        self.timeout_seconds = timeout_seconds
        self.visible_for_seconds = visible_for_seconds
        self.cookie_path = cookie_path or os.path.join(os.path.dirname(__file__), "paysend_cookies.json")
        self._playwright = None
        self._browser = None
        self._context = None
        self._browser_logs = []
        self.COUNTRY_NAMES = {
            "US": "the-united-states-of-america",
            "IN": "india",
            "AM": "armenia",
            "DZ": "algeria",
            "GB": "the-united-kingdom",
            "CA": "canada",
            "AU": "australia",
            "DE": "germany",
            "FR": "france",
            "ES": "spain",
            "IT": "italy",
            "NL": "the-netherlands",
            "BE": "belgium",
            "CH": "switzerland",
            "AT": "austria",
            "SG": "singapore",
            "NZ": "new-zealand",
            "HK": "hong-kong",
            "JP": "japan",
            "KR": "south-korea",
            "TH": "thailand",
            "MY": "malaysia",
            "PH": "the-philippines",
            "ID": "indonesia",
            "CN": "china",
            "RU": "russia",
            "UA": "ukraine",
            "MX": "mexico",
            "BR": "brazil",
            "AR": "argentina",
            "CO": "colombia",
            "PE": "peru",
            "CL": "chile",
            "EG": "egypt",
            "ZA": "south-africa",
            "NG": "nigeria",
            "KE": "kenya",
            "GH": "ghana",
            "AE": "the-united-arab-emirates",
            "TR": "turkey",
            "SA": "saudi-arabia",
            "IL": "israel",
            "PK": "pakistan",
            "BD": "bangladesh",
            "LK": "sri-lanka",
            "NP": "nepal",
        }
        self.CURRENCY_IDS = {
            "USD": "840",  # US Dollar
            "EUR": "978",  # Euro
            "GBP": "826",  # British Pound
            "CAD": "124",  # Canadian Dollar
            "AUD": "036",  # Australian Dollar
            "NZD": "554",  # New Zealand Dollar
            "JPY": "392",  # Japanese Yen
            "CHF": "756",  # Swiss Franc
            "HKD": "344",  # Hong Kong Dollar
            "SGD": "702",  # Singapore Dollar
            "AED": "784",  # UAE Dirham
            "SAR": "682",  # Saudi Riyal
            "INR": "356",  # Indian Rupee
            "PKR": "586",  # Pakistani Rupee
            "BDT": "050",  # Bangladeshi Taka
            "LKR": "144",  # Sri Lankan Rupee
            "NPR": "524",  # Nepalese Rupee
            "IDR": "360",  # Indonesian Rupiah
            "PHP": "608",  # Philippine Peso
            "THB": "764",  # Thai Baht
            "MYR": "458",  # Malaysian Ringgit
            "KRW": "410",  # South Korean Won
            "CNY": "156",  # Chinese Yuan
            "RUB": "643",  # Russian Ruble
            "UAH": "980",  # Ukrainian Hryvnia
            "MXN": "484",  # Mexican Peso
            "BRL": "986",  # Brazilian Real
            "ARS": "032",  # Argentine Peso
            "COP": "170",  # Colombian Peso
            "PEN": "604",  # Peruvian Sol
            "CLP": "152",  # Chilean Peso
            "EGP": "818",  # Egyptian Pound
            "ZAR": "710",  # South African Rand
            "NGN": "566",  # Nigerian Naira
            "KES": "404",  # Kenyan Shilling
            "GHS": "936",  # Ghanaian Cedi
            "TRY": "949",  # Turkish Lira
            "ILS": "376",  # Israeli Shekel
            "AMD": "051",  # Armenia Dram
            "DZD": "012",  # Algeria Dinar
        }
    async def __aenter__(self):
        await self.start()
        return self
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()
    async def start(self):
        try:
            self._playwright = await async_playwright().start()
            self._browser = await self._playwright.chromium.launch(
                headless=self.headless, 
                args=[
                    "--disable-blink-features=AutomationControlled",
                    "--disable-web-security",
                    "--no-sandbox",
                ],
            )
            self._context = await self._browser.new_context(
                viewport={"width": 1920, "height": 1080},
                user_agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
                locale="en-US",
                timezone_id="America/New_York",
                has_touch=False,
            )
            if os.path.exists(self.cookie_path):
                try:
                    with open(self.cookie_path, "r") as f:
                        cookies = json.load(f)
                        await self._context.add_cookies(cookies)
                        logger.info(f"Loaded {len(cookies)} cookies from {self.cookie_path}")
                except Exception as e:
                    logger.warning(f"Failed to load cookies: {str(e)}")
            return self
        except Exception as e:
            self._browser_logs.append(f"Browser startup error: {str(e)}")
            logger.error(f"Failed to start browser: {str(e)}")
            await self.close()
            raise
    async def close(self):
        try:
            if self._context:
                await self._context.close()
                self._context = None
            if self._browser:
                await self._browser.close()
                self._browser = None
            if self._playwright:
                await self._playwright.stop()
                self._playwright = None
        except Exception as e:
            logger.warning(f"Error during browser cleanup: {str(e)}")
    async def save_cookies(self):
        if not self._context:
            logger.warning("Cannot save cookies: Browser context not initialized")
            return False
        try:
            cookies = await self._context.cookies()
            with open(self.cookie_path, "w") as f:
                json.dump(cookies, f)
            logger.info(f"Saved {len(cookies)} cookies to {self.cookie_path}")
            return True
        except Exception as e:
            logger.error(f"Failed to save cookies: {str(e)}")
            return False
    async def new_page(self) -> Tuple[Optional[Page], str]:
        if not self._context:
            error_msg = "Browser context not initialized"
            logger.error(error_msg)
            return None, error_msg
        try:
            page = await self._context.new_page()
            page.on("console", lambda msg: self._browser_logs.append(f"CONSOLE: {msg.text}"))
            page.on("pageerror", lambda err: self._browser_logs.append(f"PAGE ERROR: {err}"))
            page.on("crash", lambda: self._browser_logs.append("PAGE CRASHED"))
            return page, ""
        except Exception as e:
            error_msg = f"Failed to create page: {str(e)}"
            self._browser_logs.append(error_msg)
            logger.error(error_msg)
            return None, error_msg
    async def navigate_to_paysend(self, retry_count: int = 2) -> Tuple[Optional[Page], str]:
        for attempt in range(retry_count + 1):
            try:
                page, error = await self.new_page()
                if not page:
                    return None, error
                from_country_name = self.COUNTRY_NAMES.get("US", "the-united-states-of-america")
                to_country_name = self.COUNTRY_NAMES.get("IN", "india")
                from_curr_id = self.CURRENCY_IDS.get("USD", "840")
                to_curr_id = self.CURRENCY_IDS.get("INR", "356")
                default_url = f"https://paysend.com/en-us/send-money/from-{from_country_name}-to-{to_country_name}?fromCurrId={from_curr_id}&toCurrId={to_curr_id}&isFrom=true"
                logger.info(f"Navigating to default URL: {default_url}")
                await page.goto(default_url, 
                              wait_until="networkidle", 
                              timeout=self.timeout_seconds * 1000)
                if await self._is_captcha_page(page):
                    if self.headless:
                        return None, "Captcha detected in headless mode"
                    else:
                        logger.info("Captcha detected. Please solve it manually...")
                        await asyncio.sleep(self.timeout_seconds)
                        if await self._is_captcha_page(page):
                            return None, "Captcha not solved within timeout"
                        logger.info("Captcha appears to be solved!")
                return page, ""
            except Exception as e:
                logger.warning(f"Navigation attempt {attempt+1}/{retry_count+1} failed: {str(e)}")
                if page:
                    await page.close()
                if attempt < retry_count:
                    await asyncio.sleep(2)
                else:
                    return None, f"Navigation failed after {retry_count+1} attempts: {str(e)}"
    async def _is_captcha_page(self, page: Page) -> bool:
        try:
            captcha_selectors = [
                "#challenge-running",
                "iframe[src*='captcha']",
                "iframe[src*='cloudflare']",
                ".cf-browser-verification",
                "#cf-please-wait"
            ]
            for selector in captcha_selectors:
                if await page.locator(selector).count() > 0:
                    return True
            content = await page.content()
            captcha_keywords = [
                "captcha",
                "challenge",
                "security check",
                "cloudflare",
                "browser verification",
                "browser check"
            ]
            return any(keyword in content.lower() for keyword in captcha_keywords)
        except Exception as e:
            logger.warning(f"Error checking for captcha: {str(e)}")
            return False
    async def get_quote(self, from_currency: str, to_currency: str, amount: float,
                       from_country: str = "US", to_country: str = "IN") -> Optional[Dict[str, Any]]:
        if not self._browser:
            await self.start()
        from_country_name = self.COUNTRY_NAMES.get(from_country, from_country.lower())
        to_country_name = self.COUNTRY_NAMES.get(to_country, to_country.lower())
        from_curr_id = self.CURRENCY_IDS.get(from_currency, "840")  # Default to USD if not found
        to_curr_id = self.CURRENCY_IDS.get(to_currency)
        if not to_curr_id:
            logger.warning(f"Currency ID not found for {to_currency}, using default URL")
            page, error = await self.navigate_to_paysend()
        else:
            url = f"https://paysend.com/en-us/send-money/from-{from_country_name}-to-{to_country_name}?fromCurrId={from_curr_id}&toCurrId={to_curr_id}&isFrom=true"
            logger.info(f"Navigating to URL: {url}")
            page, error = await self.new_page()
            if page:
                try:
                    await page.goto(url, wait_until="networkidle", timeout=self.timeout_seconds * 1000)
                    if await self._is_captcha_page(page):
                        if self.headless:
                            await page.close()
                            return None, "Captcha detected in headless mode"
                        else:
                            logger.info("Captcha detected. Please solve it manually...")
                            await asyncio.sleep(self.timeout_seconds)
                            if await self._is_captcha_page(page):
                                await page.close()
                                return None, "Captcha not solved within timeout"
                            logger.info("Captcha appears to be solved!")
                except Exception as e:
                    logger.error(f"Error navigating to {url}: {e}")
                    if page:
                        await page.close()
                    page, error = await self.navigate_to_paysend()
        if not page:
            logger.error(f"Failed to navigate to Paysend: {error}")
            self._browser_logs.append(f"Navigation error: {error}")
            return None
        try:
            logger.info(f"Attempting to get quote for {from_currency} to {to_currency}")
            await page.fill("#amount", str(amount))
            await page.select_option("#from-currency", from_currency)
            await page.select_option("#to-currency", to_currency)
            await page.click("#calculate-button")
            await page.wait_for_selector("#result-container", timeout=30000)
            exchange_rate = await page.evaluate("() => document.querySelector('#exchange-rate').textContent")
            fee = await page.evaluate("() => document.querySelector('#fee').textContent")
            receive_amount = await page.evaluate("() => document.querySelector('#receive-amount').textContent")
            await self.save_cookies()
            await page.close()
            if self.visible_for_seconds > 0:
                logger.info(f"Keeping browser open for {self.visible_for_seconds} seconds")
                await asyncio.sleep(self.visible_for_seconds)
            return {
                "success": True,
                "exchange_rate": float(exchange_rate),
                "fee": float(fee),
                "receive_amount": float(receive_amount),
                "currency_from": from_currency,
                "currency_to": to_currency
            }
        except Exception as e:
            if page:
                try:
                    screenshot_path = f"paysend_error_{int(time.time())}.png"
                    await page.screenshot(path=screenshot_path)
                    logger.info(f"Error screenshot saved to {screenshot_path}")
                except Exception as screenshot_err:
                    logger.warning(f"Failed to capture error screenshot: {str(screenshot_err)}")
                await page.close()
            logger.error(f"Error during quote retrieval: {str(e)}")
            self._browser_logs.append(f"Quote error: {str(e)}")
            return None
    def get_browser_logs(self) -> str:
        return "\n".join(self._browser_logs) 
def get_browser_cookies_sync() -> Optional[Dict]:
    cookie_path = os.path.join(os.path.dirname(__file__), "paysend_cookies.json")
    try:
        if os.path.exists(cookie_path):
            with open(cookie_path, "r") as f:
                cookies = json.load(f)
                return cookies
        return None
    except Exception as e:
        logger.error(f"Error getting browser cookies: {e}")
        return None
def run_browser_helper_sync(
    from_currency: str,
    to_currency: str,
    amount: float,
    from_country: str = "US",
    to_country: str = "IN",
    url: Optional[str] = None,
    headless: bool = True,
    timeout_seconds: int = 120  # Increased timeout for manual captcha solving
) -> Optional[Dict[str, Any]]:
    try:
        result = asyncio.run(_run_browser_helper_async(
            from_currency=from_currency,
            to_currency=to_currency,
            amount=amount,
            from_country=from_country,
            to_country=to_country,
            url=url,
            headless=headless,
            timeout_seconds=timeout_seconds
        ))
        return result
    except Exception as e:
        logger.error(f"Error running browser helper: {e}")
        return None
async def _run_browser_helper_async(
    from_currency: str,
    to_currency: str,
    amount: float,
    from_country: str = "US",
    to_country: str = "IN",
    url: Optional[str] = None,
    headless: bool = True,
    timeout_seconds: int = 120
) -> Optional[Dict[str, Any]]:
    helper = PaysendBrowserHelper(
        headless=headless,
        timeout_seconds=timeout_seconds,
        visible_for_seconds=30  # Keep browser visible for 30 seconds after operation
    )
    try:
        await helper.start()
        result = await helper.get_quote(
            from_currency=from_currency,
            to_currency=to_currency,
            amount=amount,
            from_country=from_country,
            to_country=to_country
        )
        await helper.save_cookies()
        return result
    except Exception as e:
        logger.error(f"Error in browser helper async: {e}")
        return None
    finally:
        await helper.close() 
###END

from apps.providers.rewire.integration import RewireProvider
from apps.providers.rewire.exceptions import (
    RewireError,
    RewireConnectionError,
    RewireApiError,
    RewireValidationError,
    RewireRateLimitError,
    RewireResponseError,
    RewireCorridorUnsupportedError,
    RewireQuoteError,
    RewireParsingError,
)
__all__ = [
    'RewireProvider',
    'RewireError',
    'RewireConnectionError',
    'RewireApiError',
    'RewireValidationError',
    'RewireRateLimitError',
    'RewireResponseError',
    'RewireCorridorUnsupportedError',
    'RewireQuoteError',
    'RewireParsingError',
] 
###END

import logging
import json
import requests
from decimal import Decimal
from typing import Dict, Any, List, Optional
from apps.providers.base import RemittanceProvider
from apps.providers.rewire.exceptions import (
    RewireError,
    RewireConnectionError,
    RewireApiError,
    RewireResponseError,
    RewireCorridorUnsupportedError,
    RewireRateLimitError,
)
logger = logging.getLogger(__name__)
class RewireProvider(RemittanceProvider):
    RATES_URL = "https://api.rewire.to/services/rates/v3/jsonp"
    PRICING_URL = "https://lights.rewire.to/public/public-pricing"
    COUNTRY_TO_CURRENCY = {
        'IL': 'ILS',  # Israel - Israeli Shekel
        'GB': 'GBP',  # United Kingdom - British Pound
        'DE': 'EUR',  # Germany - Euro
        'FR': 'EUR',  # France - Euro
        'IT': 'EUR',  # Italy - Euro
        'ES': 'EUR',  # Spain - Euro
        'US': 'USD',  # United States - US Dollar
        'IN': 'INR',  # India - Indian Rupee
        'PH': 'PHP',  # Philippines - Philippine Peso
        'CN': 'CNY',  # China - Chinese Yuan
        'JP': 'JPY',  # Japan - Japanese Yen
        'CA': 'CAD',  # Canada - Canadian Dollar
        'AU': 'AUD',  # Australia - Australian Dollar
    }
    SUPPORTED_CORRIDORS = [
        ('IL', 'PHP'),
        ('IL', 'INR'),
        ('IL', 'CNY'),
        ('GB', 'PHP'),
        ('GB', 'INR'),
        ('DE', 'PHP'),
        ('DE', 'INR'),
    ]
    def __init__(self, name="rewire", **kwargs):
        super().__init__(name=name, base_url=None, **kwargs)
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": (
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                "AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15"
            ),
            "Accept": "*/*",
            "Origin": "https://www.rewire.com",
            "Referer": "https://www.rewire.com/"
        })
        self.cached_rates: Dict[str, Dict[str, Dict[str, float]]] = {}
        self.cached_fees: Dict[str, Any] = {}
        self.last_fetch_timestamp = 0
    def fetch_rates(self) -> Dict[str, Any]:
        logger.info("Fetching Rewire rates from %s", self.RATES_URL)
        try:
            resp = self.session.get(self.RATES_URL, timeout=15)
            resp.raise_for_status()
            try:
                data = resp.json()  # This should parse the JSON object
                if "rates" not in data:
                    raise RewireResponseError("Invalid response format: 'rates' field missing")
                self.cached_rates = data.get("rates", {})
                self.last_fetch_timestamp = data.get("timestamp", 0)
                logger.debug("Got rates for %d countries", len(self.cached_rates))
                for country in list(self.cached_rates.keys())[:2]:
                    sample_currencies = list(self.cached_rates[country].keys())[:3]
                    logger.debug("Sample rates for %s: %s", country, 
                                 {c: self.cached_rates[country][c] for c in sample_currencies})
                return data
            except json.JSONDecodeError as e:
                raise RewireResponseError(f"Failed to parse JSON response: {str(e)}")
        except requests.exceptions.RequestException as e:
            logger.error("Connection error fetching Rewire rates: %s", str(e))
            raise RewireConnectionError(f"Failed to connect to Rewire API: {str(e)}")
    def fetch_pricing(self) -> Dict[str, Any]:
        logger.info("Attempting to fetch Rewire public pricing from %s", self.PRICING_URL)
        logger.warning("Note: The pricing API currently returns a 500 error (as of March 2025)")
        self.cached_fees = {}
        return {}
    def _ensure_rates_loaded(self):
        if not self.cached_rates:
            self.fetch_rates()
    def _get_receive_currency(self, receive_country: str) -> str:
        return self.COUNTRY_TO_CURRENCY.get(receive_country, "USD")
    def _get_fee_for_corridor(self, send_currency: str, receive_currency: str, send_amount: float) -> float:
        static_fees = {
            "ILS": {
                "PHP": 5.0,  # 5 ILS fee
                "INR": 5.0,
                "NGN": 10.0,
                "CNY": 10.0,
                "default": 5.0,
            },
            "GBP": {
                "PHP": 2.0,  # 2 GBP fee
                "INR": 2.0,
                "default": 2.0,
            },
            "EUR": {
                "PHP": 2.5,  # 2.5 EUR fee
                "INR": 2.5,
                "default": 2.5,
            },
            "USD": {
                "default": 3.0,  # 3 USD fee
            },
        }
        if send_currency in static_fees:
            if receive_currency in static_fees[send_currency]:
                return static_fees[send_currency][receive_currency]
            else:
                return static_fees[send_currency].get("default", 0.0)
        return 0.0
    def is_corridor_supported(self, send_country: str, receive_country: str) -> bool:
        if (send_country, receive_country) in self.SUPPORTED_CORRIDORS:
            return True
        self._ensure_rates_loaded()
        if send_country not in self.cached_rates:
            logger.debug("Send country %s not found in rates data", send_country)
            return False
        receive_currency = self._get_receive_currency(receive_country)
        if receive_currency in self.cached_rates.get(send_country, {}):
            self.SUPPORTED_CORRIDORS.append((send_country, receive_country))
            return True
        return False
    def get_supported_countries(self, base_currency: str = None) -> List[str]:
        self._ensure_rates_loaded()
        countries = list(self.cached_rates.keys())  # e.g. ["IL", "GB", "DE", "IT", ...]
        countries.sort()
        if base_currency:
            filtered_countries = []
            for country in countries:
                currencies = self.cached_rates.get(country, {})
                if base_currency in currencies:
                    filtered_countries.append(country)
            return filtered_countries
        return countries
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        send_country: str,
        send_currency: str,
        receive_currency: str,
        **kwargs
    ) -> Dict[str, Any]:
        self._ensure_rates_loaded()
        result = {
            "provider": self.name,
            "send_amount": float(send_amount),
            "send_country": send_country,
            "send_currency": send_currency,
            "receive_currency": receive_currency,
            "success": False,
            "error_message": None
        }
        if send_country not in self.cached_rates:
            msg = f"No rates found for send country '{send_country}' in Rewire data."
            logger.error(msg)
            result["error_message"] = msg
            return result
        country_rates = self.cached_rates[send_country]
        if receive_currency not in country_rates:
            msg = f"No rates for {receive_currency} from {send_country} in Rewire data."
            logger.error(msg)
            result["error_message"] = msg
            return result
        rewire_rate = country_rates[receive_currency]  # e.g. {"buy": 0.017..., "sell": 58.345...}
        sell_rate = rewire_rate.get("sell", 0)
        if sell_rate == 0:
            msg = "Sell rate is 0—invalid or corridor not available."
            logger.error(msg)
            result["error_message"] = msg
            return result
        receive_amount = float(send_amount) / sell_rate
        fee = self._get_fee_for_corridor(send_currency, receive_currency, float(send_amount))
        result.update({
            "exchange_rate": 1.0 / sell_rate,  # the ratio of 1 send_currency to get X receive_currency
            "receive_amount": receive_amount,
            "fee": fee,
            "success": True,
        })
        return result
    def get_quote(
        self,
        amount: Decimal,
        source_currency: str,
        target_country: str,
        **kwargs
    ) -> Dict[str, Any]:
        send_country = kwargs.pop("send_country", None)
        if not send_country:
            for country, currency in self.COUNTRY_TO_CURRENCY.items():
                if currency == source_currency:
                    send_country = country
                    break
            if not send_country:
                country_map = {
                    "ILS": "IL",
                    "GBP": "GB",
                    "EUR": "DE",
                    "USD": "US",
                }
                send_country = country_map.get(source_currency, "IL")  # Default to Israel
        self._ensure_rates_loaded()
        if send_country not in self.cached_rates:
            alt_country = None
            for country in self.cached_rates.keys():
                if self.COUNTRY_TO_CURRENCY.get(country) == source_currency:
                    alt_country = country
                    logger.info(f"Using alternative country {alt_country} for currency {source_currency}")
                    break
            if alt_country:
                send_country = alt_country
            else:
                return {
                    "provider": self.name,
                    "send_amount": float(amount),
                    "send_country": send_country,
                    "send_currency": source_currency,
                    "receive_currency": target_country,
                    "success": False,
                    "error_message": f"No rates found for send country '{send_country}' in Rewire data."
                }
        receive_currency = target_country
        if len(target_country) == 2 and target_country.isalpha():
            receive_currency = self._get_receive_currency(target_country)
        return self.get_exchange_rate(
            send_amount=amount,
            send_country=send_country,
            send_currency=source_currency,
            receive_currency=receive_currency,
            **kwargs
        ) 
###END

###FILE:./apps/providers/tasks.py
from decimal import Decimal
from celery import shared_task
from django.utils import timezone
from .models import Provider, ExchangeRate
from .factory import ProviderFactory
@shared_task
def update_provider_rates(provider_name: str, send_amount: float,
                         send_currency: str, receive_country: str) -> str:
    try:
        provider_instance = ProviderFactory.get_provider(provider_name, headless=True)
        with provider_instance as provider:
            rate_info = provider.get_exchange_rate(
                send_amount=Decimal(str(send_amount)),
                send_currency=send_currency,
                receive_country=receive_country
            )
            if rate_info:
                provider_obj, _ = Provider.objects.get_or_create(
                    name=rate_info['provider'],
                    defaults={'website': provider_instance.base_url}
                )
                ExchangeRate.objects.create(
                    provider=provider_obj,
                    send_amount=Decimal(str(rate_info['send_amount'])),
                    send_currency=rate_info['send_currency'],
                    receive_country=rate_info['receive_country'],
                    exchange_rate=Decimal(str(rate_info['exchange_rate'])),
                    transfer_fee=Decimal(str(rate_info['transfer_fee'])),
                    delivery_time=rate_info['delivery_time'],
                    timestamp=timezone.now()
                )
                return f"Updated rates for {provider_name}"
            return f"No rates available for {provider_name}"
    except Exception as e:
        return f"Error updating {provider_name} rates: {str(e)}"
@shared_task
def update_all_rates(send_amount: float, send_currency: str,
                    receive_country: str) -> dict:
    results = {}
    providers = ProviderFactory.list_providers()
    for provider_name in providers:
        task = update_provider_rates.delay(
            provider_name,
            send_amount,
            send_currency,
            receive_country
        )
        results[provider_name] = task.id
    return results 
###END

from .integration import KoronaPayProvider
from .exceptions import (
    KoronaPayError,
    KoronaPayAuthError,
    KoronaPayAPIError,
    KoronaPayValidationError,
    KoronaPayCorridorError,
    KoronaPayPaymentMethodError
)
__all__ = [
    'KoronaPayProvider',
    'KoronaPayError',
    'KoronaPayAuthError',
    'KoronaPayAPIError',
    'KoronaPayValidationError',
    'KoronaPayCorridorError',
    'KoronaPayPaymentMethodError'
] 
###END

import logging
import requests
from decimal import Decimal
from typing import Dict, List, Optional, Any
from datetime import datetime
import uuid
import json
from apps.providers.base.provider import RemittanceProvider
from .exceptions import (
    KoronaPayError,
    KoronaPayAuthError,
    KoronaPayAPIError,
    KoronaPayValidationError,
    KoronaPayCorridorError,
    KoronaPayPaymentMethodError
)
logger = logging.getLogger(__name__)
class KoronaPayProvider(RemittanceProvider):
    BASE_URL = "https://koronapay.com/api"
    API_VERSION = "v2.138"
    PAYMENT_METHODS = {
        "debit_card": "debitCard",
        "bank_account": "bankAccount"
    }
    RECEIVING_METHODS = {
        "cash": "cash",
        "card": "card"
    }
    CURRENCY_IDS = {
        "EUR": "978",  # Euro
        "USD": "840",  # US Dollar
        "TRY": "949",  # Turkish Lira
        "IDR": "360",  # Indonesian Rupiah
        "GBP": "826",  # British Pound
        "PLN": "985",  # Polish Zloty
        "CZK": "203",  # Czech Koruna
        "HUF": "348",  # Hungarian Forint
        "RON": "946",  # Romanian Leu
        "BGN": "975",  # Bulgarian Lev
        "HRK": "191",  # Croatian Kuna
        "DKK": "208",  # Danish Krone
        "SEK": "752",  # Swedish Krona
        "NOK": "578"   # Norwegian Krone
    }
    COUNTRY_IDS = {
        "AUT": "Austria",
        "BEL": "Belgium",
        "BGR": "Bulgaria",
        "HRV": "Croatia",
        "CYP": "Cyprus",
        "CZE": "Czech Republic",
        "DNK": "Denmark",
        "EST": "Estonia",
        "FIN": "Finland",
        "FRA": "France",
        "DEU": "Germany",
        "GRC": "Greece",
        "HUN": "Hungary",
        "ISL": "Iceland",
        "IRL": "Ireland",
        "ITA": "Italy",
        "LVA": "Latvia",
        "LIE": "Liechtenstein",
        "LTU": "Lithuania",
        "LUX": "Luxembourg",
        "MLT": "Malta",
        "NLD": "Netherlands",
        "NOR": "Norway",
        "POL": "Poland",
        "PRT": "Portugal",
        "ROU": "Romania",
        "SVK": "Slovakia",
        "SVN": "Slovenia",
        "ESP": "Spain",
        "SWE": "Sweden",
        "GBR": "United Kingdom",
        "IDN": "Indonesia",
        "TUR": "Turkey",
        "VNM": "Vietnam",
        "PHL": "Philippines",
        "THA": "Thailand",
        "MYS": "Malaysia"
    }
    def __init__(self, config: Optional[Dict] = None):
        super().__init__(name="koronapay", base_url=self.BASE_URL)
        self.config = config or {}
        self.session = requests.Session()
        self._setup_session()
    def _setup_session(self):
        self.session.headers.update({
            "Accept": f"application/vnd.cft-data.{self.API_VERSION}+json",
            "Accept-Language": "en",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15",
            "x-application": "Qpay-Web/3.0"
        })
    def _get_request_headers(self) -> Dict[str, str]:
        return {
            "Request-ID": str(uuid.uuid4()),
            "Cache-Control": "no-cache",
            "Pragma": "no-cache"
        }
    def _validate_currency(self, currency: str) -> str:
        currency_id = self.CURRENCY_IDS.get(currency.upper())
        if not currency_id:
            raise KoronaPayValidationError(f"Unsupported currency: {currency}")
        return currency_id
    def _validate_country(self, country: str) -> str:
        if country not in self.COUNTRY_IDS:
            raise KoronaPayValidationError(f"Unsupported country: {country}")
        return country
    def _validate_payment_method(self, method: str) -> str:
        payment_method = self.PAYMENT_METHODS.get(method.lower())
        if not payment_method:
            raise KoronaPayPaymentMethodError(f"Unsupported payment method: {method}")
        return payment_method
    def _validate_receiving_method(self, method: str) -> str:
        receiving_method = self.RECEIVING_METHODS.get(method.lower())
        if not receiving_method:
            raise KoronaPayPaymentMethodError(f"Unsupported receiving method: {method}")
        return receiving_method
    def get_tariffs(
        self,
        sending_country: str,
        receiving_country: str,
        sending_currency: str,
        receiving_currency: str,
        amount: Decimal,
        is_amount_receiving: bool = False,
        payment_method: str = "debit_card",
        receiving_method: str = "cash"
    ) -> Dict[str, Any]:
        try:
            sending_country_id = self._validate_country(sending_country)
            receiving_country_id = self._validate_country(receiving_country)
            sending_currency_id = self._validate_currency(sending_currency)
            receiving_currency_id = self._validate_currency(receiving_currency)
            payment_method = self._validate_payment_method(payment_method)
            receiving_method = self._validate_receiving_method(receiving_method)
            params = {
                "sendingCountryId": sending_country_id,
                "receivingCountryId": receiving_country_id,
                "sendingCurrencyId": sending_currency_id,
                "receivingCurrencyId": receiving_currency_id,
                "paymentMethod": payment_method,
                "receivingMethod": receiving_method,
                "paidNotificationEnabled": "false"
            }
            amount_key = "receivingAmount" if is_amount_receiving else "sendingAmount"
            params[amount_key] = str(int(amount * 100))  # Convert to cents
            response = self.session.get(
                f"{self.BASE_URL}/transfers/tariffs",
                params=params,
                headers=self._get_request_headers(),
                timeout=30
            )
            if response.status_code != 200:
                raise KoronaPayAPIError(
                    f"API request failed with status {response.status_code}",
                    status_code=response.status_code,
                    response=response.json() if response.text else None
                )
            tariffs = response.json()
            if not tariffs or not isinstance(tariffs, list):
                raise KoronaPayAPIError("Invalid tariff response format")
            tariff = tariffs[0]
            return {
                "success": True,
                "sending_amount": Decimal(str(tariff["sendingAmount"])) / 100,
                "sending_currency": sending_currency,
                "receiving_amount": Decimal(str(tariff["receivingAmount"])) / 100,
                "receiving_currency": receiving_currency,
                "exchange_rate": Decimal(str(tariff["exchangeRate"])),
                "fee": Decimal(str(tariff["sendingCommission"])) / 100,
                "total_cost": Decimal(str(tariff["sendingAmount"])) / 100,
                "provider": "koronapay",
                "timestamp": datetime.now().isoformat()
            }
        except requests.exceptions.RequestException as e:
            logger.error(f"KoronaPay API request failed: {e}")
            raise KoronaPayAPIError(f"API request failed: {str(e)}")
        except (KeyError, ValueError, TypeError) as e:
            logger.error(f"Error parsing KoronaPay response: {e}")
            raise KoronaPayAPIError(f"Error parsing response: {str(e)}")
    def get_quote(
        self,
        send_amount: Optional[float] = None,
        receive_amount: Optional[float] = None,
        send_currency: str = "EUR",
        receive_currency: str = "USD",
        send_country: str = "ESP",
        receive_country: str = "TUR",
        payment_method: str = "debit_card",
        receiving_method: str = "cash"
    ) -> Dict[str, Any]:
        if send_amount is None and receive_amount is None:
            raise KoronaPayValidationError("Either send_amount or receive_amount must be provided")
        is_amount_receiving = send_amount is None
        amount = Decimal(str(receive_amount if is_amount_receiving else send_amount))
        try:
            tariff = self.get_tariffs(
                sending_country=send_country,
                receiving_country=receive_country,
                sending_currency=send_currency,
                receiving_currency=receive_currency,
                amount=amount,
                is_amount_receiving=is_amount_receiving,
                payment_method=payment_method,
                receiving_method=receiving_method
            )
            return {
                "success": True,
                "send_amount": float(tariff["sending_amount"]),
                "send_currency": send_currency,
                "receive_amount": float(tariff["receiving_amount"]),
                "receive_currency": receive_currency,
                "rate": float(tariff["exchange_rate"]),
                "fee": float(tariff["fee"]),
                "total_cost": float(tariff["total_cost"]),
                "provider": "koronapay",
                "timestamp": tariff["timestamp"]
            }
        except KoronaPayError as e:
            logger.error(f"Failed to get quote: {e}")
            return {
                "success": False,
                "error": str(e),
                "provider": "koronapay"
            }
    def get_exchange_rate(
        self,
        send_currency: str,
        receive_currency: str,
        send_country: str = "ESP",
        receive_country: str = "TUR",
        amount: Decimal = Decimal("1000")
    ) -> Dict[str, Any]:
        try:
            tariff = self.get_tariffs(
                sending_country=send_country,
                receiving_country=receive_country,
                sending_currency=send_currency,
                receiving_currency=receive_currency,
                amount=amount,
                is_amount_receiving=False
            )
            return {
                "success": True,
                "source_currency": send_currency,
                "target_currency": receive_currency,
                "rate": float(tariff["exchange_rate"]),
                "fee": float(tariff["fee"]),
                "timestamp": tariff["timestamp"],
                "provider": "koronapay"
            }
        except KoronaPayError as e:
            logger.error(f"Failed to get exchange rate: {e}")
            return {
                "success": False,
                "error": str(e),
                "source_currency": send_currency,
                "target_currency": receive_currency,
                "provider": "koronapay"
            } 
###END

###FILE:./apps/providers/models.py
from django.db import models
from django.utils import timezone
class Provider(models.Model):
    name = models.CharField(max_length=100, unique=True)
    website = models.URLField()
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    def __str__(self):
        return self.name
    class Meta:
        ordering = ['name']
class ExchangeRate(models.Model):
    provider = models.ForeignKey(Provider, on_delete=models.CASCADE, related_name='rates')
    send_amount = models.DecimalField(max_digits=10, decimal_places=2)
    send_currency = models.CharField(max_length=3)  # ISO 4217 currency code
    receive_country = models.CharField(max_length=2)  # ISO 3166-1 alpha-2 country code
    exchange_rate = models.DecimalField(max_digits=10, decimal_places=4)
    transfer_fee = models.DecimalField(max_digits=10, decimal_places=2)
    delivery_time = models.CharField(max_length=100)
    timestamp = models.DateTimeField(default=timezone.now)
    is_available = models.BooleanField(default=True)
    def __str__(self):
        return f"{self.provider.name} - {self.send_currency} to {self.receive_country}"
    class Meta:
        ordering = ['-timestamp']
        indexes = [
            models.Index(fields=['send_currency', 'receive_country', 'timestamp']),
            models.Index(fields=['provider', 'timestamp']),
        ]
    def total_cost_usd(self):
        return float(self.send_amount + self.transfer_fee)
    def recipient_amount(self):
        return float(self.send_amount * self.exchange_rate) 
###END

from apps.providers.remitguru.integration import RemitGuruProvider
__all__ = ['RemitGuruProvider'] 
###END

import json
import logging
import time
from decimal import Decimal
from typing import Dict, List, Any, Optional
import requests
from apps.providers.base.provider import RemittanceProvider
logger = logging.getLogger(__name__)
class RemitGuruProvider(RemittanceProvider):
    BASE_URL = "https://www.remitguru.com"
    QUOTE_ENDPOINT = "/transfer/jsp/getQTStatistics.jsp"
    CORRIDOR_MAPPING = {
        "UK": "GB",      # United Kingdom
        "GB": "GB",      # United Kingdom (ISO code)
        "IN": "IN",      # India
        "PH": "PH",      # Philippines
        "PK": "PK",      # Pakistan
        "US": "US",      # United States
    }
    CURRENCY_MAPPING = {
        "GB": "GBP",     # United Kingdom - British Pound
        "IN": "INR",     # India - Indian Rupee
        "PH": "PHP",     # Philippines - Philippine Peso
        "PK": "PKR",     # Pakistan - Pakistani Rupee
        "US": "USD",     # United States - US Dollar
    }
    SUPPORTED_CORRIDORS = [
        ("GB", "IN"),  # UK to India
    ]
    def __init__(self):
        super().__init__(name="RemitGuru", base_url=self.BASE_URL)
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            'Accept': '*/*',
            'Origin': self.BASE_URL,
            'Referer': f"{self.BASE_URL}/",
            'Connection': 'keep-alive',
            'Accept-Language': 'en-US,en;q=0.9'
        })
        self._visit_homepage()
    def _visit_homepage(self):
        try:
            logger.debug("Visiting RemitGuru homepage to get cookies")
            response = self.session.get(self.BASE_URL, timeout=30)
            response.raise_for_status()
            logger.debug(f"HomePage request successful. Cookies: {self.session.cookies}")
            time.sleep(1)
        except Exception as e:
            logger.error(f"Error visiting RemitGuru homepage: {str(e)}")
    def _build_corridor_string(self, send_country: str, send_currency: str, 
                              receive_country: str, receive_currency: str) -> str:
        return f"{send_country}~{send_currency}~{receive_country}~{receive_currency}"
    def is_corridor_supported(self, send_country: str, receive_country: str) -> bool:
        return (send_country, receive_country) in self.SUPPORTED_CORRIDORS
    def get_quote(self, send_amount: Decimal, send_country: str, receive_country: str) -> Optional[Dict]:
        send_country_mapped = self.CORRIDOR_MAPPING.get(send_country, send_country)
        receive_country_mapped = self.CORRIDOR_MAPPING.get(receive_country, receive_country)
        send_currency = self.CURRENCY_MAPPING.get(send_country_mapped)
        receive_currency = self.CURRENCY_MAPPING.get(receive_country_mapped)
        if not send_currency or not receive_currency:
            logger.error(f"Unable to determine currencies for corridor {send_country} → {receive_country}")
            return None
        if not self.is_corridor_supported(send_country_mapped, receive_country_mapped):
            logger.warning(f"Corridor {send_country_mapped} → {receive_country_mapped} is not in the list of known supported corridors")
        corridor = self._build_corridor_string(
            send_country=send_country_mapped,
            send_currency=send_currency,
            receive_country=receive_country_mapped,
            receive_currency=receive_currency
        )
        payload = {
            'amountTransfer': str(int(send_amount)),  # Format as integer like in the example
            'corridor': corridor,
            'sendMode': 'CIP-FER'  # This seems to be a default mode based on the example
        }
        url = f"{self.BASE_URL}{self.QUOTE_ENDPOINT}"
        try:
            logger.debug(f"Making request to RemitGuru API: {url} with payload: {payload}")
            logger.debug(f"Headers: {self.session.headers}")
            logger.debug(f"Cookies: {self.session.cookies}")
            response = self.session.post(url, data=payload, timeout=30)
            response.raise_for_status()
            response_text = response.text.strip()
            logger.debug(f"RemitGuru API response: {response_text}")
            logger.debug(f"Response status: {response.status_code}")
            logger.debug(f"Response headers: {response.headers}")
            if not response_text or '|' not in response_text:
                logger.error(f"Invalid response format from RemitGuru API: {response_text}")
                return None
            parts = response_text.split('|')
            if len(parts) < 7:
                logger.error(f"Insufficient data in RemitGuru API response: {response_text}")
                return None
            try:
                error_message = parts[4] if len(parts) > 4 and parts[4] else None
                error_code = parts[7] if len(parts) > 7 and parts[7] else None
                is_valid_str = parts[5] if len(parts) > 5 else "false"
                is_valid = is_valid_str.lower() == 'true'
                if not is_valid:
                    logger.warning(f"RemitGuru returned invalid quote: {error_message} (Error code: {error_code})")
                    return {
                        'is_valid': False,
                        'error': error_message or "Invalid quote returned",
                        'error_code': error_code,
                        'raw_response': response_text
                    }
                receive_amount = Decimal(parts[0]) if parts[0] and parts[0] != '0' else None
                exchange_rate = Decimal(parts[1]) if parts[1] and parts[1] != '0' else None
                fee = Decimal(parts[2]) if parts[2] else Decimal('0')
                send_amount_confirmed = Decimal(parts[3]) if parts[3] and parts[3] != '0' else send_amount
                send_currency_confirmed = parts[6] if parts[6] and parts[6] != '0' else send_currency
                result = {
                    'receive_amount': receive_amount,
                    'exchange_rate': exchange_rate,
                    'fee': fee,
                    'send_amount': send_amount_confirmed,
                    'is_valid': is_valid,
                    'send_currency': send_currency_confirmed,
                    'receive_currency': receive_currency,
                    'raw_response': response_text
                }
                return result
            except (IndexError, ValueError) as e:
                logger.error(f"Error parsing RemitGuru API response: {str(e)}")
                return None
        except requests.exceptions.RequestException as e:
            logger.error(f"Error making request to RemitGuru API: {str(e)}")
            return None
        except Exception as e:
            logger.error(f"Unexpected error in RemitGuru API request: {str(e)}")
            return None
    def get_exchange_rate(
        self, 
        send_amount: Decimal, 
        send_currency: str, 
        receive_country: str
    ) -> Optional[Dict]:
        send_country = None
        for country, currency in self.CURRENCY_MAPPING.items():
            if currency == send_currency:
                send_country = country
                break
        if not send_country:
            logger.error(f"Unable to determine sending country for currency {send_currency}")
            return None
        try:
            quote = self.get_quote(
                send_amount=send_amount,
                send_country=send_country,
                receive_country=receive_country
            )
            if not quote:
                logger.error(f"Failed to get quote from RemitGuru for {send_currency} → {receive_country}")
                return None
            if not quote.get('is_valid', False):
                error_message = quote.get('error', "Invalid quote returned by provider")
                error_code = quote.get('error_code')
                logger.warning(f"RemitGuru returned an invalid quote for {send_currency} → {receive_country}: {error_message} ({error_code})")
                return {
                    "provider": self.name,
                    "send_amount": float(send_amount),
                    "send_currency": send_currency,
                    "receive_country": receive_country,
                    "supported": False,
                    "error": error_message,
                    "error_code": error_code,
                    "raw_json": quote
                }
            receive_currency = quote.get('receive_currency')
            result = {
                "provider": self.name,
                "send_amount": float(send_amount),
                "send_currency": send_currency,
                "receive_currency": receive_currency,
                "receive_country": receive_country,
                "exchange_rate": float(quote.get('exchange_rate')) if quote.get('exchange_rate') else None,
                "receive_amount": float(quote.get('receive_amount')) if quote.get('receive_amount') else None,
                "fee": float(quote.get('fee')) if quote.get('fee') else 0.0,
                "delivery_time": 48.0,  # Default to 48 hours
                "supported": True,
                "raw_json": quote
            }
            return result
        except Exception as e:
            logger.error(f"Error getting RemitGuru exchange rate: {str(e)}")
            return None
    def get_supported_countries(self) -> List[Dict]:
        supported_corridors = [
            {"from_country": "GB", "to_country": "IN", "from_currency": "GBP", "to_currency": "INR"},
        ]
        return supported_corridors 
###END

from .integration import PlacidProvider
from .exceptions import (
    PlacidError,
    PlacidConnectionError,
    PlacidApiError,
    PlacidResponseError,
    PlacidCorridorUnsupportedError,
    PlacidCloudflareError,
    PlacidRateLimitError,
)
__all__ = [
    "PlacidProvider",
    "PlacidError",
    "PlacidConnectionError",
    "PlacidApiError", 
    "PlacidResponseError",
    "PlacidCorridorUnsupportedError",
    "PlacidCloudflareError",
    "PlacidRateLimitError",
] 
###END

import logging
import requests
import re
from decimal import Decimal
from typing import Any, Dict, Optional, List, Union
from apps.providers.base.provider import RemittanceProvider
from .exceptions import (
    PlacidError,
    PlacidConnectionError,
    PlacidApiError,
    PlacidResponseError,
    PlacidCorridorUnsupportedError,
    PlacidCloudflareError,
)
logger = logging.getLogger(__name__)
class PlacidProvider(RemittanceProvider):
    BASE_URL = "https://www.placid.net"
    ENDPOINT = "/conf/sqls/pstRqstNS.php"
    CORRIDOR_MAPPING = {
        'PAK': {'currency': 'PKR', 'name': 'Pakistan'},      # Pakistan - Pakistani Rupee
        'IND': {'currency': 'INR', 'name': 'India'},         # India - Indian Rupee
        'BGD': {'currency': 'BDT', 'name': 'Bangladesh'},    # Bangladesh - Bangladesh Taka
        'PHL': {'currency': 'PHP', 'name': 'Philippines'},   # Philippines - Philippine Peso
        'NPL': {'currency': 'NPR', 'name': 'Nepal'},         # Nepal - Nepalese Rupee
        'LKA': {'currency': 'LKR', 'name': 'Sri Lanka'},     # Sri Lanka - Sri Lankan Rupee
        'IDN': {'currency': 'IDR', 'name': 'Indonesia'},     # Indonesia - Indonesian Rupiah
        'VNM': {'currency': 'VND', 'name': 'Vietnam'},       # Vietnam - Vietnamese Dong
    }
    CURRENCY_TO_CORRIDOR = {
        'PKR': 'PAK',
        'INR': 'IND',
        'BDT': 'BGD',
        'PHP': 'PHL',
        'NPR': 'NPL',
        'LKR': 'LKA',
        'IDR': 'IDN',
        'VND': 'VNM',
    }
    def __init__(self, name="placid", **kwargs):
        super().__init__(name=name, base_url=self.BASE_URL, **kwargs)
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": ("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                           "AppleWebKit/605.1.15 (KHTML, like Gecko) "
                           "Version/18.3 Safari/605.1.15"),
            "Accept": "*/*",
            "Content-Type": "application/x-www-form-urlencoded",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
        })
        self.logger = logging.getLogger(f"providers.{name}")
    def get_exchange_rate(
        self,
        source_country: str,
        corridor_val: str = "PAK",
        rndval: str = "1740963881748",
        **kwargs
    ) -> Dict[str, Any]:
        if not corridor_val:
            return {
                "provider": self.name,
                "success": False,
                "source_country": source_country,
                "corridor_val": corridor_val,
                "rate": 0.0,
                "error_message": "Corridor value cannot be empty"
            }
        if not source_country:
            return {
                "provider": self.name,
                "success": False,
                "source_country": source_country,
                "corridor_val": corridor_val,
                "rate": 0.0,
                "error_message": "Source country cannot be empty"
            }
        if not isinstance(rndval, str) or not rndval.isdigit():
            return {
                "provider": self.name,
                "success": False,
                "source_country": source_country,
                "corridor_val": corridor_val,
                "rate": 0.0,
                "error_message": "Invalid rndval parameter"
            }
        corridor_val = corridor_val.strip().upper()
        source_country = source_country.strip().upper()
        valid_source_countries = ["US", "GB", "EU", "CA", "AU"]
        if source_country not in valid_source_countries:
            self.logger.warning(f"Unknown source country: {source_country}, this may affect rate accuracy")
            return {
                "provider": self.name,
                "success": False,
                "source_country": source_country,
                "corridor_val": corridor_val,
                "rate": 0.0,
                "error_message": f"Invalid source country. Supported countries: {', '.join(valid_source_countries)}"
            }
        try:
            if not rndval:
                rndval = str(int(time.time() * 1000))
            query_params = {
                "TaskType": "ChgContIndx",
                "Val1": corridor_val,
                "Val2": "NIL",
                "Val3": "NIL",
                "Val4": "NIL",
                "Val5": "NIL",
                "Val6": "NIL",
            }
            data = {
                "rndval": rndval,
            }
            url = f"{self.BASE_URL}{self.ENDPOINT}"
            response = self.session.post(url, params=query_params, data=data, timeout=15)
            response.raise_for_status()
            content = response.text
            if corridor_val not in content:
                if '|//|' in content:
                    self.logger.warning(f"Response does not contain specific data for corridor {corridor_val}")
                    return {
                        "provider": self.name,
                        "success": True,
                        "source_country": source_country,
                        "corridor_val": corridor_val,
                        "rate": 0.0,
                        "raw_data": content,
                        "error_message": None
                    }
                else:
                    self.logger.error(f"Corridor {corridor_val} not found in response")
                    raise PlacidCorridorUnsupportedError(f"Corridor {corridor_val} not supported")
            if corridor_val in self.CORRIDOR_MAPPING:
                currency_code = self.CORRIDOR_MAPPING[corridor_val]["currency"]
            else:
                self.logger.warning(f"Unknown corridor value: {corridor_val}, using it as currency code")
                currency_code = corridor_val
            pattern = rf"(\d+[\.,]?\d*)\s*{currency_code}"
            match = re.search(pattern, content)
            if match:
                rate_str = match.group(1).replace(",", "")
                rate = float(rate_str)
                return {
                    "provider": self.name,
                    "success": True,
                    "source_country": source_country,
                    "corridor_val": corridor_val,
                    "rate": rate,
                    "raw_data": content,
                    "error_message": None
                }
            else:
                self.logger.error(f"Could not find exchange rate for {currency_code} in Placid response.")
                raise PlacidResponseError(f"Could not find exchange rate for {currency_code} in Placid response.")
        except (requests.RequestException, ConnectionError) as e:
            self.logger.error(f"Connection error to Placid API: {str(e)}")
            raise PlacidConnectionError(f"Failed to connect to Placid API: {str(e)}")
        except PlacidError:
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error processing Placid exchange rate: {str(e)}")
            raise PlacidApiError(f"Error processing Placid response: {str(e)}")
    def get_quote(
        self,
        amount: Decimal,
        source_currency: str,
        target_currency: str,
        **kwargs
    ) -> Dict[str, Any]:
        if not source_currency or not target_currency:
            return {
                "provider": self.name,
                "success": False,
                "source_currency": source_currency,
                "target_currency": target_currency,
                "send_amount": float(amount) if amount else 0.0,
                "exchange_rate": 0.0,
                "error_message": "Source or target currency cannot be empty",
                "receive_amount": 0.0
            }
        try:
            amount_value = float(amount)
            if amount_value <= 0:
                return {
                    "provider": self.name,
                    "success": False,
                    "source_currency": source_currency,
                    "target_currency": target_currency,
                    "send_amount": float(amount),
                    "exchange_rate": 0.0,
                    "error_message": "Amount must be positive",
                    "receive_amount": 0.0
                }
        except (ValueError, TypeError):
            return {
                "provider": self.name,
                "success": False,
                "source_currency": source_currency,
                "target_currency": target_currency,
                "send_amount": 0.0,
                "exchange_rate": 0.0,
                "error_message": "Invalid amount",
                "receive_amount": 0.0
            }
        source_currency = source_currency.strip().upper()
        target_currency = target_currency.strip().upper()
        source_country = kwargs.get("source_country", None)
        if not source_country:
            currency_to_country = {
                "USD": "US",
                "GBP": "GB",
                "EUR": "EU",
                "CAD": "CA",
                "AUD": "AU"
            }
            source_country = currency_to_country.get(source_currency, "US")
            self.logger.info(f"Source country not provided, defaulting to {source_country} for {source_currency}")
        corridor_val = self.CURRENCY_TO_CORRIDOR.get(target_currency)
        if not corridor_val:
            self.logger.warning(f"No corridor mapping found for currency {target_currency}, using as-is")
            corridor_val = target_currency
        valid_source_currencies = ["USD", "GBP", "EUR", "CAD", "AUD"]
        if source_currency not in valid_source_currencies:
            return {
                "provider": self.name,
                "success": False,
                "source_country": source_country,
                "source_currency": source_currency,
                "target_currency": target_currency,
                "send_amount": float(amount),
                "exchange_rate": 0.0,
                "error_message": f"Invalid source currency. Supported currencies: {', '.join(valid_source_currencies)}",
                "receive_amount": 0.0
            }
        try:
            rate_result = self.get_exchange_rate(
                source_country=source_country,
                corridor_val=corridor_val
            )
            exchange_rate = rate_result.get("rate", 0.0)
            receive_amount = float(amount) * exchange_rate
            return {
                "provider": self.name,
                "success": True,
                "source_country": source_country,
                "source_currency": source_currency,
                "target_currency": target_currency,
                "send_amount": float(amount),
                "exchange_rate": exchange_rate,
                "error_message": None,
                "receive_amount": receive_amount
            }
        except PlacidError as e:
            return {
                "provider": self.name,
                "success": False,
                "source_country": source_country,
                "source_currency": source_currency,
                "target_currency": target_currency,
                "send_amount": float(amount),
                "exchange_rate": 0.0,
                "error_message": str(e),
                "receive_amount": 0.0
            }
        except Exception as e:
            self.logger.error(f"Error getting quote from Placid: {str(e)}")
            return {
                "provider": self.name,
                "success": False,
                "source_country": source_country if source_country else "unknown",
                "source_currency": source_currency,
                "target_currency": target_currency,
                "send_amount": float(amount),
                "exchange_rate": 0.0,
                "error_message": f"Unexpected error: {str(e)}",
                "receive_amount": 0.0
            } 
###END

from .integration import IntermexProvider
from .exceptions import (
    IntermexError,
    IntermexAuthenticationError,
    IntermexConnectionError,
    IntermexValidationError,
    IntermexRateLimitError
)
__all__ = [
    "IntermexProvider",
    "IntermexError",
    "IntermexAuthenticationError",
    "IntermexConnectionError",
    "IntermexValidationError",
    "IntermexRateLimitError"
] 
###END

import json
import logging
import os
import random
import time
import uuid
from datetime import datetime, UTC
from decimal import Decimal
from typing import Dict, Optional, Any, List, Union
from urllib.parse import urljoin
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from apps.providers.base.provider import RemittanceProvider
from .exceptions import (
    IntermexError,
    IntermexAuthenticationError,
    IntermexConnectionError,
    IntermexValidationError,
    IntermexRateLimitError,
    IntermexAPIError
)
logger = logging.getLogger(__name__)
def log_request_details(logger, method: str, url: str, headers: Dict,
                      params: Dict = None, data: Dict = None):
    logger.debug("\n" + "="*80 + f"\nOUTGOING REQUEST DETAILS:\n{'='*80}")
    logger.debug(f"Method: {method}")
    logger.debug(f"URL: {url}")
    masked_headers = headers.copy()
    sensitive = ['Authorization', 'Cookie', 'Ocp-Apim-Subscription-Key']
    for key in sensitive:
        if key in masked_headers:
            masked_headers[key] = '***MASKED***'
    logger.debug("\nHeaders:")
    logger.debug(json.dumps(dict(masked_headers), indent=2))
    if params:
        logger.debug("\nQuery Params:")
        logger.debug(json.dumps(params, indent=2))
    if data:
        logger.debug("\nRequest Body:")
        logger.debug(json.dumps(data, indent=2))
def log_response_details(logger, response):
    logger.debug("\n" + "="*80 + f"\nRESPONSE DETAILS:\n{'='*80}")
    logger.debug(f"Status Code: {response.status_code}")
    logger.debug(f"Reason: {response.reason}")
    logger.debug("\nResponse Headers:")
    logger.debug(json.dumps(dict(response.headers), indent=2))
    try:
        body = response.json()
        logger.debug("\nJSON Response Body:")
        logger.debug(json.dumps(body, indent=2))
    except ValueError:
        body = response.text
        content_type = response.headers.get('content-type', '').lower()
        if 'html' in content_type:
            logger.debug("\nHTML Response (truncated):")
            logger.debug(body[:500] + '...' if len(body) > 500 else body)
        else:
            logger.debug("\nPlain Text Response:")
            logger.debug(body[:1000] + '...' if len(body) > 1000 else body)
    logger.debug("="*80)
class IntermexProvider(RemittanceProvider):
    BASE_URL = "https://api.imxi.com"
    PRICING_ENDPOINT = "/pricing/api/v2/feesrates"
    DEFAULT_STYLE_ID = 3
    DEFAULT_TRAN_TYPE_ID = 3
    DEFAULT_CHANNEL_ID = 1
    DEFAULT_PARTNER_ID = 1
    DEFAULT_LANGUAGE_ID = 1
    PAYMENT_METHODS = {
        "DebitCard": 3,
        "CreditCard": 4
    }
    DELIVERY_METHODS = {
        "BankDeposit": "W"
    }
    def __init__(self, api_key: Optional[str] = None, timeout: int = 30, user_agent: Optional[str] = None):
        super().__init__(name="Intermex", base_url=self.BASE_URL)
        self.logger = logger
        self.timeout = timeout
        self.user_agent = user_agent or os.environ.get(
            "INTERMEX_DEFAULT_UA",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15"
        )
        self.api_key = api_key or os.environ.get("INTERMEX_API_KEY", "2162a586e2164623a1cd9b6b2d300b4c")
        self._session = requests.Session()
        self.request_id = str(uuid.uuid4())
        self._initialize_session()
        self.logger.debug(f"Initialized IntermexProvider with UA: {self.user_agent}")
    def _initialize_session(self) -> None:
        self.logger.debug("Initializing Intermex session...")
        self._session.headers.update({
            "Accept": "application/json, text/plain, */*",
            "User-Agent": self.user_agent,
            "Accept-Language": "en-US,en;q=0.9",
            "Accept-Encoding": "gzip, deflate, br",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "cross-site",
            "Sec-Fetch-Dest": "empty",
            "Priority": "u=3, i",
            "PartnerId": str(self.DEFAULT_PARTNER_ID),
            "ChannelId": str(self.DEFAULT_CHANNEL_ID),
            "LanguageId": str(self.DEFAULT_LANGUAGE_ID),
            "Origin": "https://www.intermexonline.com",
            "Referer": "https://www.intermexonline.com/"
        })
        if self.api_key:
            self._session.headers.update({
                "Ocp-Apim-Subscription-Key": self.api_key
            })
        retry_strategy = Retry(
            total=3,
            backoff_factor=0.5,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self._session.mount("https://", adapter)
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        send_currency: str = "USD",
        receive_country: str = None,
        receive_currency: str = None,
        delivery_method: str = None,
        payment_method: str = None
    ) -> Dict:
        if not receive_country:
            raise IntermexValidationError("receive_country is required")
        if not receive_currency:
            raise IntermexValidationError("receive_currency is required when using live API")
        if not delivery_method:
            delivery_method = "Cash Pickup"  # Default delivery method
        if not payment_method:
            payment_method = "Bank Transfer"  # Default payment method
        try:
            params = {
                "Amount": str(send_amount),
                "CountryCode": receive_country,
                "DeliveryTypeId": self._get_delivery_type_id(delivery_method),
                "PaymentMethodId": self._get_payment_method_id(payment_method),
                "CityId": "",  # Blank for general rates
                "StateId": "",  # Blank for general rates
                "ZipCode": ""   # Blank for general rates
            }
            response = requests.get(
                f"{self.BASE_URL}/api/ExchangeRates",
                params=params,
                headers=self._session.headers
            )
            if response.status_code == 200:
                data = response.json()
                if isinstance(data, list) and len(data) > 0:
                    fee = Decimal(data[0].get("Fee", 0))
                    exchange_rate = Decimal(data[0].get("ExchangeRate", 1))
                    receive_amount = Decimal(data[0].get("ReceiveAmount", 0))
                    result = {
                        "provider_id": "Intermex",
                        "source_currency": send_currency,
                        "source_amount": float(send_amount),
                        "destination_currency": receive_currency,
                        "destination_amount": float(receive_amount),
                        "exchange_rate": float(exchange_rate),
                        "fee": float(fee),
                        "delivery_method": delivery_method,
                        "delivery_time_minutes": self._get_delivery_time(receive_country, delivery_method),
                        "corridor": f"{send_currency}-{receive_country}",
                        "payment_method": payment_method,
                        "details": {
                            "raw_response": data[0]
                        }
                    }
                    return result
                else:
                    raise IntermexAPIError("Invalid response format from Intermex API")
            elif response.status_code == 400:
                error_message = response.json().get("Message", "Unknown error")
                raise IntermexValidationError(f"API validation error: {error_message}")
            else:
                raise IntermexAPIError(f"Unexpected API error: {response.status_code}")
        except Exception as e:
            logger.error(f"Error getting exchange rate from Intermex: {str(e)}")
            raise IntermexAPIError(f"Failed to get exchange rate: {str(e)}")
    def _get_delivery_type_id(self, delivery_method: str) -> int:
        delivery_method_lower = delivery_method.lower()
        if "cash" in delivery_method_lower and "pickup" in delivery_method_lower:
            return 1  # Cash Pickup
        elif "bank" in delivery_method_lower and "deposit" in delivery_method_lower:
            return 2  # Bank Deposit
        elif "home" in delivery_method_lower and "delivery" in delivery_method_lower:
            return 3  # Home Delivery
        else:
            return 1  # Default to Cash Pickup
    def _get_payment_method_id(self, payment_method: str) -> int:
        payment_method_lower = payment_method.lower()
        if "bank" in payment_method_lower:
            return 1  # Bank Transfer/ACH
        elif "card" in payment_method_lower or "credit" in payment_method_lower:
            return 2  # Credit/Debit Card
        elif "cash" in payment_method_lower:
            return 3  # Cash
        else:
            return 1  # Default to Bank Transfer
    def _get_delivery_time(self, country_code: str, delivery_method: str) -> int:
        return None
    def get_payment_methods(self, source_country: str = "USA", target_country: str = "TUR") -> List[Dict]:
        try:
            test_amount = Decimal("100.00")
            params = {
                "DestCountryAbbr": target_country,
                "OriCountryAbbr": source_country,
                "OriStateAbbr": "PA",
                "StyleId": self.DEFAULT_STYLE_ID,
                "TranTypeId": self.DEFAULT_TRAN_TYPE_ID,
                "DeliveryType": "W",
                "OriCurrency": "USD",
                "ChannelId": self.DEFAULT_CHANNEL_ID,
                "OriAmount": float(test_amount),
                "DestAmount": 0,
                "SenderPaymentMethodId": 4
            }
            url = f"{self.BASE_URL}{self.PRICING_ENDPOINT}"
            response = self._session.get(
                url,
                params=params,
                timeout=self.timeout
            )
            if response.status_code != 200:
                self.logger.error(f"Failed to get payment methods: {response.status_code}")
                return []
            data = response.json()
            payment_methods = data.get("paymentMethods", [])
            return [
                {
                    "id": pm.get("senderPaymentMethodId"),
                    "name": pm.get("senderPaymentMethodName"),
                    "fee": pm.get("feeAmount"),
                    "available": pm.get("isAvailable", False)
                }
                for pm in payment_methods
            ]
        except Exception as e:
            self.logger.error(f"Error getting payment methods: {e}")
            return []
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self._session.close() 
###END

###END

import json
import logging
import os
import random
import time
import uuid
import pprint
from datetime import datetime, UTC
from decimal import Decimal
from typing import Dict, Optional, Any
from urllib.parse import urljoin
import requests
from apps.providers.base.provider import RemittanceProvider
from .exceptions import (
    WUError,
    WUAuthenticationError,
    WUConnectionError,
    WUValidationError
)
logger = logging.getLogger(__name__)
def log_request_details(logger, method: str, url: str, headers: Dict,
                        params: Dict = None, data: Dict = None):
    logger.debug("\n" + "="*80 + f"\nOUTGOING REQUEST DETAILS:\n{'='*80}")
    logger.debug(f"Method: {method}")
    logger.debug(f"URL: {url}")
    masked_headers = headers.copy()
    sensitive = ['Authorization', 'Cookie', 'X-WU-Correlation-ID', 'X-WU-Transaction-ID']
    for key in sensitive:
        if key in masked_headers:
            masked_headers[key] = '***MASKED***'
    logger.debug("\nHeaders:")
    logger.debug(pprint.pformat(masked_headers))
    if params:
        logger.debug("\nQuery Params:")
        logger.debug(pprint.pformat(params))
    if data:
        logger.debug("\nRequest Body:")
        logger.debug(pprint.pformat(data))
def log_response_details(logger, response):
    logger.debug("\n" + "="*80 + f"\nRESPONSE DETAILS:\n{'='*80}")
    logger.debug(f"Status Code: {response.status_code}")
    logger.debug(f"Reason: {response.reason}")
    logger.debug("\nResponse Headers:")
    logger.debug(pprint.pformat(dict(response.headers)))
    try:
        body = response.json()
        logger.debug("\nJSON Response Body:")
        logger.debug(pprint.pformat(body))
    except ValueError:
        body = response.text
        content_type = response.headers.get('content-type', '').lower()
        if 'html' in content_type:
            logger.debug("\nHTML Response (truncated):")
            logger.debug(body[:500] + '...' if len(body) > 500 else body)
        else:
            logger.debug("\nPlain Text Response:")
            logger.debug(body[:1000] + '...' if len(body) > 1000 else body)
    logger.debug("="*80)
class WesternUnionProvider(RemittanceProvider):
    BASE_URL = "https://www.westernunion.com"
    START_PAGE_URL = f"{BASE_URL}/us/en/web/send-money/start"
    CATALOG_URL = f"{BASE_URL}/wuconnect/prices/catalog"
    def __init__(self, timeout: int = 30, user_agent: Optional[str] = None):
        super().__init__(name="Western Union", base_url=self.START_PAGE_URL)
        self.logger = logger
        self.timeout = timeout
        self.user_agent = user_agent or os.environ.get(
            "WU_DEFAULT_UA",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) " +
            "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36"
        )
        self._session = requests.Session()
        self.correlation_id: str = ""
        self.transaction_id: str = ""
        self._token = None
        self._token_expiry = None
        self.logger.debug(f"Initialized WesternUnionProvider with UA: {self.user_agent}")
    def _initialize_session(self) -> None:
        self.logger.debug("Initializing WU session...")
        self.correlation_id = f"web-{uuid.uuid4()}"
        self.transaction_id = f"{self.correlation_id}-{int(time.time() * 1000)}"
        self._session.headers.update({
            "User-Agent": self.user_agent,
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "en-US,en;q=0.9",
            "Accept-Encoding": "gzip, deflate, br",
            "Content-Type": "application/json",
            "Connection": "keep-alive",
            "sec-ch-ua": '"Chromium";v="122", "Google Chrome";v="122", "Not(A:Brand";v="24"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "X-WU-Correlation-ID": self.correlation_id,
            "X-WU-Transaction-ID": self.transaction_id,
            "Origin": self.BASE_URL,
            "Referer": self.START_PAGE_URL,
        })
        cookies = {
            "wu_language": "en_US",
            "wu_region": "us",
            "wu_market": "us",
            "SessionId": f"web-{uuid.uuid4()}",
            "WUCountryCookie_": "US",
            "WULanguageCookie_": "en",
            "resolution_height": "900",
            "resolution_width": "1440",
            "is_tablet": "false",
            "is_mobile": "false",
            "wu_cookies_accepted": "true",
            "wu_analytics_enabled": "true",
            "wu_functional_enabled": "true",
            "wu_marketing_enabled": "true",
        }
        for k, v in cookies.items():
            self._session.cookies.set(k, v, domain=".westernunion.com")
        try:
            time.sleep(random.uniform(0.5, 1.5))
            self.logger.debug("GET start page to fetch initial cookies...")
            log_request_details(
                self.logger, "GET", self.START_PAGE_URL,
                dict(self._session.headers)
            )
            resp = self._session.get(
                self.START_PAGE_URL, timeout=self.timeout, allow_redirects=True
            )
            log_response_details(self.logger, resp)
            resp.raise_for_status()
            for cookie in resp.cookies:
                self._session.cookies.set_cookie(cookie)
            time.sleep(random.uniform(1.0, 2.0))
            self.logger.debug("OPTIONS request to ensure CORS for /catalog...")
            options_headers = {
                "Access-Control-Request-Method": "POST",
                "Access-Control-Request-Headers": (
                    "content-type,x-wu-correlation-id,x-wu-transaction-id,"
                    "sec-ch-ua,sec-ch-ua-mobile,sec-ch-ua-platform"
                )
            }
            self._session.headers.update(options_headers)
            log_request_details(
                self.logger, "OPTIONS", self.CATALOG_URL,
                dict(self._session.headers)
            )
            opts = self._session.options(
                self.CATALOG_URL,
                timeout=self.timeout
            )
            log_response_details(self.logger, opts)
            opts.raise_for_status()
            for header in options_headers:
                self._session.headers.pop(header, None)
            time.sleep(random.uniform(2.0, 3.0))
            self.logger.debug("Session initialization succeeded.")
        except requests.RequestException as e:
            self.logger.error(f"Failed session init: {e}")
            resp_text = getattr(e.response, 'text', '') if e.response else ''
            self.logger.error(f"Response text: {resp_text}")
            raise WUConnectionError(
                "Could not initialize WU session",
                error_code="INIT_FAILED",
                details={"original_error": str(e)}
            )
    def get_exchange_rate(self,
                          send_amount: Decimal,
                          send_currency: str,
                          receive_country: str,
                          send_country: str = "US"
    ) -> Optional[Dict]:
        if not self._is_token_valid():
            self._refresh_token()
        try:
            catalog_data = self.get_catalog_data(
                send_amount=send_amount,
                send_currency=send_currency,
                receive_country=receive_country,
                send_country=send_country
            )
        except (WUError, WUConnectionError, WUValidationError):
            return None
        try:
            best_rate = None
            best_service = None
            for category in catalog_data.get("categories", []):
                if category.get("type") == "bestfx":
                    for svc in category.get("services", []):
                        rate = float(svc.get("fx_rate", 0))
                        if rate > 0 and (best_rate is None or rate > best_rate):
                            best_rate = rate
                            pay_out_val = svc.get("pay_out")
                            pay_in_val = svc.get("pay_in")
                            best_service = self._find_service_group(
                                catalog_data, pay_out_val, pay_in_val
                            )
            if not best_rate:
                for group in catalog_data.get("services_groups", []):
                    for pg in group.get("pay_groups", []):
                        rate = float(pg.get("fx_rate", 0))
                        if rate > 0 and (best_rate is None or rate > best_rate):
                            best_rate = rate
                            best_service = {
                                "name": group.get("service_name", "Unknown"),
                                "fee": float(pg.get("gross_fee", 0)),
                                "receive_amount": float(pg.get("receive_amount", 0)),
                                "delivery_time": f"{group.get('speed_days', 1)} Business Days"
                            }
            if not best_rate or not best_service:
                self.logger.warning("No valid exchange rate found in catalog data")
                return None
            return {
                "provider": self.name,
                "timestamp": datetime.now(UTC).isoformat(),
                "send_amount": float(send_amount),
                "send_currency": send_currency,
                "receive_country": receive_country,
                "exchange_rate": best_rate,
                "transfer_fee": best_service["fee"],
                "service_name": best_service["name"],
                "delivery_time": best_service["delivery_time"],
                "receive_amount": best_service["receive_amount"]
            }
        except (TypeError, ValueError, KeyError) as e:
            self.logger.error(f"Error parsing catalog data: {e}")
            raise WUValidationError(
                "Failed to parse catalog response",
                error_code="PARSE_ERROR",
                details={"error": str(e)}
            )
    def get_catalog_data(self,
                         send_amount: Decimal,
                         send_currency: str,
                         receive_country: str,
                         send_country: str = "US",
                         sender_postal_code: Optional[str] = None,
                         sender_city: Optional[str] = None,
                         sender_state: Optional[str] = None
    ) -> Dict:
        self._initialize_session()
        country_to_currency = {
            "US": "USD",
            "GB": "GBP",
            "IN": "INR",
            "EG": "EGP",
            "MX": "MXN",
        }
        payload = {
            "header_reply": {
                "response_type": "not_present",
                "source_app": "defaultSource",
                "correlation_id": self.correlation_id
            },
            "sender": {
                "channel": "WWEB",
                "client": "WUCOM",
                "cty_iso2_ext": send_country,
                "curr_iso3": send_currency,
                "cpc": send_country,
                "funds_in": "*",
                "segment": "N00",
                "send_amount": float(send_amount)
            },
            "receiver": {
                "cty_iso2_ext": receive_country,
                "curr_iso3": country_to_currency.get(receive_country)
            }
        }
        if any([sender_postal_code, sender_city, sender_state]):
            payload["sender"].update({
                "postal_code": sender_postal_code,
                "city": sender_city,
                "state": sender_state
            })
        try:
            log_request_details(
                self.logger, "POST", self.CATALOG_URL,
                dict(self._session.headers),
                data=payload
            )
            response = self._session.post(
                self.CATALOG_URL,
                json=payload,
                timeout=self.timeout
            )
            log_response_details(self.logger, response)
            response.raise_for_status()
            data = response.json()
            if not data.get("services_groups"):
                raise WUValidationError(
                    "Invalid catalog response format",
                    error_code="INVALID_RESPONSE",
                    details={"response": data}
                )
            return data
        except requests.RequestException as e:
            self.logger.error(f"Failed to get catalog data: {e}")
            resp_text = getattr(e.response, 'text', '') if e.response else ''
            self.logger.error(f"Response text: {resp_text}")
            raise WUConnectionError(
                "Failed to get Western Union catalog data",
                error_code="CATALOG_FAILED",
                details={"original_error": str(e)}
            )
    def _find_service_group(self, data, pay_out_val, pay_in_val):
        for group in data.get("services_groups", []):
            if group.get("service") == pay_out_val:
                for pay_group in group.get("pay_groups", []):
                    if pay_group.get("fund_in") == pay_in_val:
                        return {
                            "name": group.get("service_name", "Unknown"),
                            "fee": float(pay_group.get("gross_fee", 0)),
                            "receive_amount": float(pay_group.get("receive_amount", 0)),
                            "delivery_time": f"{group.get('speed_days', 1)} Business Days"
                        }
        return None
    def _is_token_valid(self) -> bool:
        return True
    def _refresh_token(self):
        pass
###END

from apps.providers.worldremit.integration import WorldRemitProvider
from apps.providers.worldremit.integration_scrapeops import WorldRemitScrapeOpsProvider
from apps.providers.worldremit.exceptions import (
    WorldRemitError,
    WorldRemitAuthenticationError,
    WorldRemitConnectionError,
    WorldRemitValidationError,
    WorldRemitRateLimitError,
)
__all__ = [
    'WorldRemitProvider',
    'WorldRemitScrapeOpsProvider',
    'WorldRemitError',
    'WorldRemitAuthenticationError',
    'WorldRemitConnectionError',
    'WorldRemitValidationError',
    'WorldRemitRateLimitError',
] 
###END

import json
import logging
import os
import time
import re
from datetime import datetime
from decimal import Decimal
from typing import Dict, Optional, Any, List, Union
from urllib.parse import urljoin, quote_plus, urlencode
import requests
from bs4 import BeautifulSoup
from apps.providers.base.provider import RemittanceProvider
from apps.providers.worldremit.exceptions import (
    WorldRemitError,
    WorldRemitAuthenticationError,
    WorldRemitConnectionError,
    WorldRemitValidationError,
    WorldRemitRateLimitError
)
logger = logging.getLogger(__name__)
def log_request_details(method: str, url: str, headers: Dict, params: Dict = None, data: Dict = None):
    logger.debug(f"Request: {method} {url}")
    logger.debug(f"Headers: {json.dumps(headers, indent=2)}")
    if params:
        logger.debug(f"Params: {json.dumps(params, indent=2)}")
    if data:
        logger.debug(f"Data: {json.dumps(data, indent=2)}")
def log_response_details(response):
    logger.debug(f"Response Status: {response.status_code}")
    logger.debug(f"Response Headers: {json.dumps(dict(response.headers), indent=2)}")
    try:
        json_data = response.json()
        logger.debug(f"Response JSON: {json.dumps(json_data, indent=2)}")
    except:
        logger.debug(f"Response Text (full): {response.text}")
    logger.debug(f"Response Content Length: {len(response.content)} bytes")
class WorldRemitScrapeOpsProvider(RemittanceProvider):
    BASE_URL = "https://www.worldremit.com"
    CALCULATOR_URL = "https://www.worldremit.com/en/calculator"
    TRANSFER_URL = "https://www.worldremit.com/en/transfer"
    HOME_URL = "https://www.worldremit.com/en"
    US_HOME_URL = "https://www.worldremit.com/en/us"
    GRAPHQL_API_URL = "https://api.worldremit.com/graphql"
    ALTERNATIVE_URLS = [
        "https://www.worldremit.com/en",
        "https://www.worldremit.com/en/us",
        "https://www.worldremit.com"
    ]
    PAYMENT_METHODS = {
        "DebitCard": "debit-card",
        "CreditCard": "credit-card"
    }
    COUNTRY_CODE_MAPPING = {
        "USA": "US",
        "TUR": "TR",
        "MEX": "MX",
        "COL": "CO",
        "PHL": "PH",
        "GTM": "GT",
        "SLV": "SV",
        "HND": "HN",
        "ECU": "EC",
        "DOM": "DO",
        "NIC": "NI",
        "PER": "PE",
        "EGY": "EG"
    }
    def __init__(
        self, 
        api_key: str,
        timeout: int = 60,
        render_js: bool = True,
        use_residential_proxies: bool = True,
        country: Optional[str] = None
    ):
        super().__init__(name="WorldRemit", base_url=self.BASE_URL)
        self.api_key = api_key
        self.timeout = timeout
        self.render_js = render_js
        self.use_residential_proxies = use_residential_proxies
        self.country = country
        self.SCRAPEOPS_API_URL = "https://proxy.scrapeops.io/v1/"
        self.session = requests.Session()
    def _make_scrapeops_request(self, url: str, method: str = "GET", data: Optional[Dict | str] = None, custom_headers: Optional[Dict] = None, post_content_type: Optional[str] = None) -> requests.Response:
        params = {
            'api_key': self.api_key,
            'url': url,
            'bypass': 'perimeterx',
            'render_js': 'true',  # Ensure JavaScript rendering is enabled
            'residential': 'true',  # Use residential proxies for better success
            'method': method,
        }
        if custom_headers:
            params['custom_headers'] = json.dumps(custom_headers)
        is_graphql = url.endswith('/graphql') and method == "POST" and data
        if method == "POST" and data:
            if is_graphql:
                logger.info("Making GraphQL request through ScrapeOps")
                if isinstance(data, str):
                    try:
                        json_data = json.loads(data)
                        payload_json = data
                    except json.JSONDecodeError:
                        payload_json = json.dumps(data)
                else:
                    payload_json = json.dumps(data)
                logger.debug(f"GraphQL payload: {payload_json}")
                if isinstance(data, dict) and 'query' in data:
                    params['graphql_query'] = data['query']
                    if 'variables' in data:
                        params['graphql_variables'] = json.dumps(data['variables'])
                    if 'operationName' in data:
                        params['graphql_operation_name'] = data['operationName']
                    logger.debug("Using ScrapeOps GraphQL parameters instead of post_data")
                else:
                    params['post_data'] = payload_json
                    if not post_content_type:
                        post_content_type = 'application/json'
            else:
                if isinstance(data, dict):
                    params['post_data'] = json.dumps(data)
                else:
                    params['post_data'] = data
            if post_content_type:
                params['post_content_type'] = post_content_type
        try:
            scrapeops_url = self.SCRAPEOPS_API_URL
            logger.info(f"Making ScrapeOps request: {method} {url}")
            logger.debug(f"ScrapeOps params: {json.dumps({k: v for k, v in params.items() if k != 'api_key'}, indent=2)}")
            response = self.session.get(scrapeops_url, params=params, timeout=self.timeout)
            log_response_details(response)
            return response
        except requests.RequestException as e:
            logger.error(f"ScrapeOps request failed: {e}")
            raise WorldRemitConnectionError(f"ScrapeOps request failed: {e}")
    def _normalize_country_code(self, country_code: str) -> str:
        return self.COUNTRY_CODE_MAPPING.get(country_code, country_code)
    def _make_direct_graphql_request(self, query: str, variables: Optional[Dict] = None, operationName: Optional[str] = None) -> Dict:
        url = self.GRAPHQL_API_URL
        custom_headers = {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "Origin": "https://www.worldremit.com",
            "Referer": "https://www.worldremit.com/en/send-money/us/tr?lc=us",
            "x-wr-platform": "Web",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15"
        }
        import uuid
        request_id = str(uuid.uuid4())
        custom_headers["x-wr-requestid"] = request_id
        payload = {
            "query": query
        }
        if variables:
            payload["variables"] = variables
        if operationName:
            payload["operationName"] = operationName
        payload_json = json.dumps(payload)
        logger.info(f"Making direct GraphQL request to {url}")
        logger.debug(f"GraphQL payload: {payload_json}")
        try:
            direct_response = requests.post(
                url=url,
                headers=custom_headers,
                data=payload_json,
                timeout=self.timeout
            )
            if direct_response.status_code != 200:
                logger.error(f"Direct GraphQL request failed with status {direct_response.status_code}")
                logger.error(f"Response: {direct_response.text[:500]}")
                raise WorldRemitConnectionError(f"Direct GraphQL request failed with status {direct_response.status_code}")
            try:
                result = direct_response.json()
                logger.debug(f"Direct GraphQL response: {json.dumps(result, indent=2)}")
                if "errors" in result:
                    errors = result.get("errors", [])
                    error_message = errors[0].get("message", "Unknown GraphQL error") if errors else "Unknown GraphQL error"
                    logger.error(f"GraphQL errors: {error_message}")
                    raise WorldRemitValidationError(f"GraphQL errors: {error_message}")
                return result
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse response as JSON: {e}")
                logger.error(f"Response text: {direct_response.text[:500]}")
                raise WorldRemitError(f"Invalid JSON response: {e}")
        except requests.RequestException as e:
            logger.error(f"Direct GraphQL request failed: {e}")
            raise WorldRemitConnectionError(f"Failed to connect: {e}")
        except Exception as e:
            logger.error(f"Error making direct GraphQL request: {e}")
            raise WorldRemitError(f"Error making direct GraphQL request: {e}")
    def _make_graphql_request(self, query: str, variables: Optional[Dict] = None, operationName: Optional[str] = None) -> Dict:
        try:
            logger.info("Making direct GraphQL request")
            result = self._make_direct_graphql_request(query, variables, operationName)
            logger.info("Direct GraphQL request successful")
            return result
        except WorldRemitError as e:
            logger.error(f"Direct GraphQL request failed: {e}")
            raise  # Re-raise the exception - no fallback for GraphQL
    def get_exchange_rate(self, from_currency: str, to_country: str, to_currency: str, amount: float = 1000.0) -> ExchangeRateResult:
        to_country_code = self._normalize_country_code(to_country)
        send_country_code = "US"  # Only supporting US sending for now
        payout_methods = ["BANK_TRANSFER", "CASH_PICKUP", "MOBILE_MONEY"]
        query = """
        mutation createCalculation($amount: BigDecimal!, $type: CalculationType!, $sendCountryCode: CountryCode!, $sendCurrencyCode: CurrencyCode!, $receiveCountryCode: CountryCode!, $receiveCurrencyCode: CurrencyCode!, $payOutMethodCode: String, $correspondentId: String) {
          createCalculation(calculationInput: {amount: $amount, send: {country: $sendCountryCode, currency: $sendCurrencyCode}, type: $type, receive: {country: $receiveCountryCode, currency: $receiveCurrencyCode}, payOutMethodCode: $payOutMethodCode, correspondentId: $correspondentId}) {
                        calculation {
                          id
                          isFree
                          send {
                            currency
                            amount
                          }
                          receive {
                            amount
                            currency
                          }
                          exchangeRate {
                            value
                          }
                        }
                        errors {
              __typename
              ... on GenericCalculationError {
                message
                genericType: type
              }
              ... on ValidationCalculationError {
                          message
                type
                            code
                description
                          }
                        }
                      }
                    }
        Get the default currency for a country.
        Args:
            country_code: Two-letter country code
        Returns:
            Currency code or None if not found
        Get a list of supported destination countries from WorldRemit.
        Returns:
            A list of dictionaries containing country information
        Get available payment methods for a specific country corridor.
        Args:
            source_country: Sending country code
            target_country: Receiving country code
        Returns:
            List of available payment methods
###END

import logging
import requests
from decimal import Decimal
from typing import Dict, List, Optional, Any
from datetime import datetime
import uuid
import json
from apps.providers.base.provider import RemittanceProvider
from .exceptions import (
    SingXError,
    SingXAuthError,
    SingXAPIError,
    SingXValidationError,
    SingXCorridorError,
    SingXQuoteError,
    SingXRateError
)
logger = logging.getLogger(__name__)
class SingXProvider(RemittanceProvider):
    BASE_URL = "https://api.singx.co"
    API_VERSION = "central/landing/fx"
    COUNTRY_CODES = {
        "SG": "59C3BBD2-5D26-4A47-8FC1-2EFA628049CE",  # Singapore
        "IN": "A5001AED-DDA1-4296-8312-223D383F96F5",  # India
        "PH": "B6112BFE-E482-4507-9423-334D385F96F6",  # Philippines
        "ID": "C7223CFF-F593-5618-0534-445E496G07G7",  # Indonesia
        "MY": "D8334DGG-G604-6729-1645-556F507H18H8",  # Malaysia
    }
    def __init__(self, config=None):
        super().__init__(name="singx", base_url=self.BASE_URL)
        self.config = config or {}
        self.session = self._setup_session()
    def _setup_session(self) -> requests.Session:
        session = requests.Session()
        session.headers.update({
            "Content-Type": "application/json",
            "Accept": "application/json, text/plain, */*",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15",
            "Origin": "https://www.singx.co",
            "Referer": "https://www.singx.co/"
        })
        return session
    def _validate_country(self, country_code: str) -> str:
        country_id = self.COUNTRY_CODES.get(country_code.upper())
        if not country_id:
            raise SingXValidationError(f"Unsupported country: {country_code}")
        return country_id
    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:
        try:
            data = response.json()
            if response.status_code == 200:
                if data.get("errors"):
                    raise SingXAPIError(
                        message=data["errors"][0] if data["errors"] else "API Error",
                        status_code=response.status_code,
                        response=data
                    )
                return data
            elif response.status_code == 401:
                raise SingXAuthError(
                    message="Authentication failed",
                    status_code=response.status_code,
                    response=data
                )
            else:
                raise SingXAPIError(
                    message=f"API request failed with status {response.status_code}",
                    status_code=response.status_code,
                    response=data
                )
        except json.JSONDecodeError:
            raise SingXAPIError(
                message="Invalid JSON response",
                status_code=response.status_code,
                response=response.text
            )
    def get_exchange_rate(
        self,
        send_country: str,
        send_currency: str,
        receive_country: str,
        receive_currency: str,
        amount: Optional[Decimal] = None,
        **kwargs
    ) -> Dict[str, Any]:
        try:
            from_country_id = self._validate_country(send_country)
            to_country_id = self._validate_country(receive_country)
            data = {
                "fromCurrency": send_currency,
                "toCurrency": receive_currency,
                "amount": str(amount) if amount else "1000.00",
                "type": "Send",
                "swift": kwargs.get("swift", False),
                "cashPickup": kwargs.get("cash_pickup", False),
                "wallet": kwargs.get("wallet", False),
                "business": kwargs.get("business", False)
            }
            response = self.session.post(
                f"{self.BASE_URL}/{self.API_VERSION}/{send_country}/exchange",
                json=data
            )
            result = self._handle_response(response)
            return {
                "success": True,
                "source_country": send_country,
                "source_currency": send_currency,
                "target_country": receive_country,
                "target_currency": receive_currency,
                "rate": result["exchangeRate"],
                "fee": result["singxFee"],
                "quote_id": result["quote"],
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Failed to get exchange rate: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    def get_quote(
        self,
        send_amount: Optional[Decimal] = None,
        receive_amount: Optional[Decimal] = None,
        send_currency: str = "SGD",
        receive_currency: str = "INR",
        send_country: str = "SG",
        receive_country: str = "IN",
        **kwargs
    ) -> Dict[str, Any]:
        try:
            if not send_amount and not receive_amount:
                raise SingXValidationError("Either send_amount or receive_amount must be provided")
            data = {
                "fromCurrency": send_currency,
                "toCurrency": receive_currency,
                "amount": str(send_amount if send_amount else receive_amount),
                "type": "Send" if send_amount else "Receive",
                "swift": kwargs.get("swift", False),
                "cashPickup": kwargs.get("cash_pickup", False),
                "wallet": kwargs.get("wallet", False),
                "business": kwargs.get("business", False)
            }
            response = self.session.post(
                f"{self.BASE_URL}/{self.API_VERSION}/{send_country}/exchange",
                json=data
            )
            result = self._handle_response(response)
            return {
                "success": True,
                "send_amount": result["sendAmount"],
                "receive_amount": result["receiveAmount"],
                "fee": result["singxFee"],
                "rate": result["exchangeRate"],
                "total_cost": result["totalPayable"],
                "quote_id": result["quote"],
                "send_currency": send_currency,
                "receive_currency": receive_currency,
                "provider": "singx",
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Failed to get quote: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    def get_fees(
        self,
        send_amount: Decimal,
        send_currency: str,
        receive_currency: str,
        send_country: str = "SG",
        **kwargs
    ) -> Dict[str, Any]:
        try:
            quote = self.get_quote(
                send_amount=send_amount,
                send_currency=send_currency,
                receive_currency=receive_currency,
                send_country=send_country,
                **kwargs
            )
            if not quote["success"]:
                raise SingXQuoteError(quote.get("error", "Failed to get quote"))
            return {
                "success": True,
                "transfer_fee": quote["fee"],
                "total_fee": quote["fee"],  # SingX combines all fees
                "fee_currency": send_currency
            }
        except Exception as e:
            logger.error(f"Failed to get fees: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            } 
###END

###FILE:./apps/providers/serializers.py
from rest_framework import serializers
from .models import Provider, ExchangeRate
class ProviderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Provider
        fields = ['id', 'name', 'website', 'is_active']
class ExchangeRateSerializer(serializers.ModelSerializer):
    provider_name = serializers.CharField(source='provider.name', read_only=True)
    total_cost_usd = serializers.SerializerMethodField()
    recipient_amount = serializers.SerializerMethodField()
    class Meta:
        model = ExchangeRate
        fields = [
            'provider_name',
            'send_amount',
            'send_currency',
            'receive_country',
            'exchange_rate',
            'transfer_fee',
            'total_cost_usd',
            'recipient_amount',
            'delivery_time',
            'timestamp'
        ]
    def get_total_cost_usd(self, obj):
        return obj.total_cost_usd()
    def get_recipient_amount(self, obj):
###END

from .integration import DahabshiilProvider
from .exceptions import (
    DahabshiilError,
    DahabshiilConnectionError,
    DahabshiilApiError,
    DahabshiilResponseError,
    DahabshiilCorridorUnsupportedError,
    DahabshiilRateLimitError,
)
__all__ = [
    'DahabshiilProvider',
    'DahabshiilError',
    'DahabshiilConnectionError',
    'DahabshiilApiError',
    'DahabshiilResponseError',
    'DahabshiilCorridorUnsupportedError',
    'DahabshiilRateLimitError',
] 
###END

import logging
import requests
import re
from decimal import Decimal
from typing import Any, Dict, Optional, List, Union, Tuple
from apps.providers.base.provider import RemittanceProvider
from .exceptions import (
    DahabshiilError,
    DahabshiilConnectionError,
    DahabshiilApiError,
    DahabshiilResponseError,
    DahabshiilCorridorUnsupportedError,
)
logger = logging.getLogger(__name__)
class DahabshiilProvider(RemittanceProvider):
    BASE_URL = "https://apigw-us.dahabshiil.com/remit/transaction"
    GET_CHARGES_ENDPOINT = "/get-charges-anonymous"
    SUPPORTED_CORRIDORS = [
        ('US', 'KE'),  # USA to Kenya
        ('UK', 'KE'),  # UK to Kenya
        ('US', 'ET'),  # USA to Ethiopia
        ('US', 'SO'),  # USA to Somalia
        ('UK', 'SO'),  # UK to Somalia
    ]
    def __init__(self, name="dahabshiil", **kwargs):
        super().__init__(name=name, base_url=self.BASE_URL)
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": ("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                          "AppleWebKit/605.1.15 (KHTML, like Gecko) "
                          "Version/18.3 Safari/605.1.15"),
            "Accept": "application/json, text/plain, */*",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
        })
        self._supported_countries = {}
        self.logger = logging.getLogger(f"providers.{name}")
    def get_supported_countries(self) -> List[str]:
        return ["KE", "ET", "SO", "DJ", "UG", "SD", "TZ", "RW"]
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        send_currency: str,
        receive_country: str = None,
        receive_currency: str = None,
        source_country_code: str = None,
        receive_country_code: str = None,
        payout_type: str = "Cash Collection",
        **kwargs
    ) -> Dict[str, Any]:
        if receive_country and not receive_country_code:
            receive_country_code = receive_country
        if not source_country_code:
            source_country_code = "US"
        if not receive_currency:
            if receive_country_code == "KE":
                receive_currency = "KES"  # Kenya Shilling
            elif receive_country_code == "ET":
                receive_currency = "ETB"  # Ethiopian Birr
            elif receive_country_code == "SO":
                receive_currency = "USD"  # Somalia often uses USD
            else:
                receive_currency = "USD"
        result = {
            "provider": self.name,
            "success": False,
            "send_amount": float(send_amount),
            "send_currency": send_currency,
            "source_country_code": source_country_code,
            "receive_country_code": receive_country_code,
            "receive_country": receive_country_code,  # For compatibility
            "receive_currency": receive_currency,
            "payout_type": payout_type,
            "exchange_rate": None,
            "fee": None,
            "receive_amount": None,
            "error_message": None,
        }
        endpoint_url = self.base_url + self.GET_CHARGES_ENDPOINT
        amount_type = "SOURCE"
        send_amount_str = f"{send_amount:.2f}"
        params = {
            "source_country_code": source_country_code,         # e.g. 'US'
            "destination_country_iso2": receive_country_code,   # e.g. 'KE'
            "amount_type": amount_type,
            "amount": send_amount_str,                          # e.g. '700.00'
            "destination_currency": receive_currency,           # e.g. 'USD'
            "type": payout_type,                                # e.g. 'Cash Collection'
        }
        self.logger.debug(f"Dahabshiil GET: {endpoint_url} with params={params}")
        try:
            resp = self.session.get(endpoint_url, params=params, timeout=15)
            resp.raise_for_status()
            data = resp.json()
            self.logger.debug(f"Dahabshiil response: {data}")
            if (data.get("status") == "Success"
                and isinstance(data.get("data"), dict)
                and data["data"].get("charges")):
                charges = data["data"]["charges"]
                rate_val = float(charges.get("rate", 1))
                fee_val = float(charges.get("total_charges", 0))
                receive_amt = float(charges.get("destination_amount", 0))
                result.update({
                    "success": True,
                    "exchange_rate": rate_val,
                    "fee": fee_val,
                    "receive_amount": receive_amt,
                    "receive_currency": charges.get("destination_currency", receive_currency),
                })
            else:
                msg = f"Dahabshiil returned unexpected response structure: {data}"
                self.logger.error(msg)
                result["error_message"] = msg
        except requests.HTTPError as e:
            if e.response.status_code == 400:
                error_msg = f"Corridor from {source_country_code} to {receive_country_code} with {receive_currency} is not supported"
                self.logger.warning(error_msg)
                result["error_message"] = error_msg
                return result
            else:
                self.logger.error(f"Dahabshiil HTTP error: {e}")
                result["error_message"] = f"HTTP error: {str(e)}"
                raise DahabshiilApiError(f"API error: {str(e)}")
        except requests.RequestException as e:
            self.logger.error(f"Dahabshiil request failed: {e}")
            result["error_message"] = str(e)
            if "Connection" in str(e):
                raise DahabshiilConnectionError(f"Connection error: {str(e)}")
            raise DahabshiilApiError(f"API error: {str(e)}")
        return result
    def get_quote(
        self,
        amount: Decimal,
        source_currency: str,
        target_country: str,
        **kwargs
    ) -> Dict[str, Any]:
        source_country_code = kwargs.pop('source_country_code', None)
        if not source_country_code:
            if source_currency == "USD":
                source_country_code = "US"
            elif source_currency == "GBP":
                source_country_code = "GB"
            elif source_currency == "EUR":
                source_country_code = "DE"  # Default to Germany for EUR
            else:
                source_country_code = "US"
        target_currency = kwargs.pop('target_currency', None)
        if not target_currency:
            if target_country == "KE":
                target_currency = "KES"  # Kenya Shilling
            elif target_country == "ET":
                target_currency = "ETB"  # Ethiopian Birr
            elif target_country == "SO":
                target_currency = "USD"  # Somalia often uses USD
            else:
                target_currency = "USD"
        return self.get_exchange_rate(
            send_amount=amount,
            send_currency=source_currency,
            source_country_code=source_country_code,
            receive_country_code=target_country,
            receive_currency=target_currency,
            **kwargs
        ) 
###END

from apps.providers.xoom.integration import XoomProvider
__all__ = ["XoomProvider"] 
###END

import json
import logging
import os
import random
import re
import time
import uuid
import html
from datetime import datetime
from decimal import Decimal
from typing import Dict, Optional, Any, List, Union, Tuple
from urllib.parse import urljoin, quote_plus
import requests
from bs4 import BeautifulSoup
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
from apps.providers.base.provider import RemittanceProvider
from apps.providers.xoom.exceptions import (
    XoomError,
    XoomAuthenticationError,
    XoomConnectionError,
    XoomValidationError,
    XoomRateLimitError
)
logger = logging.getLogger(__name__)
def log_request_details(method: str, url: str, headers: Dict, params: Dict = None, data: Dict = None):
    logger.debug(f"Request: {method} {url}")
    logger.debug(f"Headers: {json.dumps({k: v for k, v in headers.items() if k.lower() != 'cookie'}, indent=2)}")
    if params:
        logger.debug(f"Params: {json.dumps(params, indent=2)}")
    if data:
        logger.debug(f"Data: {json.dumps(data, indent=2)}")
def log_response_details(response):
    logger.debug(f"Response Status: {response.status_code}")
    logger.debug(f"Response Headers: {json.dumps(dict(response.headers), indent=2)}")
    try:
        json_data = response.json()
        logger.debug(f"Response JSON: {json.dumps(json_data, indent=2)}")
    except:
        content = response.text[:500] + "..." if len(response.text) > 500 else response.text
        logger.debug(f"Response Text: {content}")
class ExchangeRateResult:
    def __init__(
        self,
        provider_id: str,
        source_currency: str,
        source_amount: float,
        destination_currency: str,
        destination_amount: float,
        exchange_rate: float,
        fee: float,
        delivery_method: str,
        delivery_time_minutes: Optional[int] = None,
        corridor: Optional[str] = None,
        payment_method: Optional[str] = None,
        details: Optional[Dict] = None
    ):
        self.provider_id = provider_id
        self.source_currency = source_currency
        self.source_amount = source_amount
        self.destination_currency = destination_currency
        self.destination_amount = destination_amount
        self.exchange_rate = exchange_rate
        self.fee = fee
        self.delivery_method = delivery_method
        self.delivery_time_minutes = delivery_time_minutes
        self.corridor = corridor
        self.payment_method = payment_method
        self.details = details or {}
    def to_dict(self) -> Dict:
        return {
            "provider_id": self.provider_id,
            "source_currency": self.source_currency,
            "source_amount": self.source_amount,
            "destination_currency": self.destination_currency,
            "destination_amount": self.destination_amount,
            "exchange_rate": self.exchange_rate,
            "fee": self.fee,
            "delivery_method": self.delivery_method,
            "delivery_time_minutes": self.delivery_time_minutes,
            "corridor": self.corridor,
            "payment_method": self.payment_method,
            "details": self.details
        }
class XoomProvider(RemittanceProvider):
    BASE_URL = "https://www.xoom.com"
    API_URL = "https://www.xoom.com/wapi/send-money-app/remittance-engine/remittance"
    QUOTE_API_URL = "https://www.xoom.com/xoom/api/send/quote"
    FEE_TABLE_API_URL = "https://www.xoom.com/calculate-fee-table"
    PAYMENT_METHODS = {
        "CRYPTO_PYUSD": "PayPal USD (PYUSD)",
        "PAYPAL_BALANCE": "PayPal balance",
        "ACH": "Bank Account",
        "DEBIT_CARD": "Debit Card",
        "CREDIT_CARD": "Credit Card"
    }
    DELIVERY_METHODS = {
        "DEPOSIT": "Bank Deposit",
        "MOBILE_WALLET": "Mobile Wallet",
        "CARD_DEPOSIT": "Debit Card Deposit",
        "PICKUP": "Cash Pickup"
    }
    COUNTRY_CODES = {
        "MX": "Mexico",
        "PH": "Philippines",
        "IN": "India",
        "CO": "Colombia",
        "GT": "Guatemala",
        "SV": "El Salvador",
        "DO": "Dominican Republic",
        "HN": "Honduras",
        "PE": "Peru",
        "EC": "Ecuador"
    }
    def __init__(self, timeout: int = 30, user_agent: Optional[str] = None):
        super().__init__(name="Xoom", base_url=self.BASE_URL)
        self.timeout = timeout
        self.user_agent = user_agent or (
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
            "AppleWebKit/605.1.15 (KHTML, like Gecko) "
            "Version/18.3 Safari/605.1.15"
        )
        self.session = requests.Session()
        self._initialize_session()
        self.request_id = str(uuid.uuid4())
        self._countries_cache = None
        self._corridors_cache = {}
        self.logger = logging.getLogger('xoom_provider')
    def _initialize_session(self) -> None:
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.9",
            "Connection": "keep-alive",
            "Origin": "https://www.xoom.com",
            "Referer": "https://www.xoom.com/",
            "Sec-Fetch-Dest": "document",
            "Sec-Fetch-Mode": "navigate",
            "Sec-Fetch-Site": "same-origin",
            "Sec-Fetch-User": "?1",
            "Host": "www.xoom.com"
        })
        retry_strategy = Retry(
            total=3,
            backoff_factor=0.5,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
        self.session.cookies.set("visitor_id", str(uuid.uuid4()), domain=".xoom.com")
        self.session.cookies.set("session_id", str(uuid.uuid4()), domain=".xoom.com")
        self._visit_home_page()
    def _visit_home_page(self) -> None:
        try:
            logger.info("Visiting Xoom homepage to initialize session")
            main_url = f"{self.BASE_URL}/"
            main_response = self.session.get(
                url=main_url,
                timeout=self.timeout,
                allow_redirects=True
            )
            if main_response.status_code != 200:
                logger.warning(f"Failed to load main homepage, status code: {main_response.status_code}")
            time.sleep(0.5)
            homepage_url = f"{self.BASE_URL}/en-us/send-money"
            response = self.session.get(
                url=homepage_url,
                timeout=self.timeout,
                allow_redirects=True
            )
            if response.status_code != 200:
                logger.warning(f"Failed to load homepage, status code: {response.status_code}")
                return
            if '/sign-in' in response.url:
                logger.warning("Redirected to sign-in page. Using anonymous mode.")
                country_url = f"{self.BASE_URL}/en-us/send-money/us/mx"
                country_response = self.session.get(
                    url=country_url,
                    timeout=self.timeout,
                    allow_redirects=True
                )
                if country_response.status_code != 200:
                    logger.warning(f"Failed to load country page, status code: {country_response.status_code}")
            soup = BeautifulSoup(response.text, "html.parser")
            csrf_token = None
            meta_tag = soup.find("meta", attrs={"name": "csrf-token"})
            if meta_tag and "content" in meta_tag.attrs:
                csrf_token = meta_tag["content"]
                self.session.headers["X-CSRF-Token"] = csrf_token
                logger.info("Found CSRF token in meta tag")
            if not csrf_token:
                script_tags = soup.find_all("script")
                for script in script_tags:
                    if script.string and "csrf" in script.string.lower():
                        csrf_match = re.search(r'csrf[\'"]*\s*:\s*[\'"]([^\'"]*)[\'"]*', script.string)
                        if csrf_match:
                            csrf_token = csrf_match.group(1)
                            self.session.headers["X-CSRF-Token"] = csrf_token
                            logger.info("Found CSRF token in script tag")
                            break
            if not csrf_token:
                nonce_script = soup.find("script", attrs={"nonce": True})
                if nonce_script and "nonce" in nonce_script.attrs:
                    nonce = nonce_script["nonce"]
                    self.session.headers["X-CSRF-Token"] = nonce
                    csrf_token = nonce
                    logger.info("Using script nonce as fallback CSRF token")
            if not csrf_token:
                logger.warning("Could not find CSRF token")
            try:
                analytics_url = f"{self.BASE_URL}/segment/settings.json"
                self.session.get(
                    url=analytics_url,
                    timeout=self.timeout
                )
            except Exception as e:
                logger.debug(f"Error loading analytics settings: {e}")
            try:
                cookie_url = f"{self.BASE_URL}/pa/gdpr"
                self.session.get(
                    url=cookie_url,
                    timeout=self.timeout
                )
            except Exception as e:
                logger.debug(f"Error handling cookie consent: {e}")
            if not self.session.cookies.get("visitor_id"):
                self.session.cookies.set("visitor_id", str(uuid.uuid4()), domain=".xoom.com")
        except Exception as e:
            logger.error(f"Error visiting homepage: {e}")
    def _get_csrf_token(self) -> Optional[str]:
        if "X-CSRF-Token" in self.session.headers:
            return self.session.headers["X-CSRF-Token"]
        self._visit_home_page()
        return self.session.headers.get("X-CSRF-Token")
    def _make_api_request(
        self,
        method: str,
        url: str,
        data: Optional[Dict] = None,
        params: Optional[Dict] = None,
        retry_auth: bool = True,
        max_retries: int = 2
    ) -> Dict:
        retry_count = 0
        while retry_count <= max_retries:
            try:
                current_headers = self.session.headers.copy()
                current_headers.update({
                    "Referer": f"{self.BASE_URL}/en-us/send-money",
                    "X-Requested-With": "XMLHttpRequest",
                    "Content-Type": "application/json",
                    "Accept": "application/json, text/plain, */*"
                })
                log_request_details(method, url, current_headers, params, data)
                if method.upper() == "GET":
                    response = self.session.get(
                        url=url,
                        params=params,
                        timeout=self.timeout,
                        headers=current_headers,
                        allow_redirects=False  # Don't automatically follow redirects
                    )
                else:  # POST
                    response = self.session.post(
                        url=url,
                        json=data,
                        params=params,
                        timeout=self.timeout,
                        headers=current_headers,
                        allow_redirects=False  # Don't automatically follow redirects
                    )
                log_response_details(response)
                if response.status_code in (301, 302, 303, 307, 308):
                    redirect_url = response.headers.get('Location')
                    logger.debug(f"Redirected to: {redirect_url}")
                    if redirect_url and '/sign-in' in redirect_url:
                        if retry_auth and retry_count < max_retries:
                            logger.warning(f"Redirected to sign-in page, refreshing session (attempt {retry_count + 1}/{max_retries})")
                            self._initialize_session()
                            time.sleep(1)  # Add delay between retries
                            retry_count += 1
                            continue
                        else:
                            raise XoomAuthenticationError("Authentication failed: redirected to sign-in page")
                    if redirect_url:
                        if redirect_url.startswith('/'):
                            redirect_url = f"{self.BASE_URL}{redirect_url}"
                        return self._make_api_request(
                            'GET', 
                            redirect_url, 
                            None, 
                            None, 
                            retry_auth=retry_auth,
                            max_retries=max_retries-retry_count
                        )
                if response.status_code in (401, 403):
                    if retry_auth and retry_count < max_retries:
                        logger.warning(f"Authentication failed, refreshing session and retrying (attempt {retry_count + 1}/{max_retries})")
                        self._initialize_session()
                        time.sleep(1)  # Add delay between retries
                        retry_count += 1
                        continue
                    raise XoomAuthenticationError("Authentication failed")
                if response.status_code == 429:
                    if retry_count < max_retries:
                        wait_time = 5 * (retry_count + 1)  # Progressive backoff
                        logger.warning(f"Rate limit exceeded, waiting {wait_time} seconds before retry")
                        time.sleep(wait_time)
                        retry_count += 1
                        continue
                    raise XoomRateLimitError("Rate limit exceeded")
                if response.status_code >= 400:
                    try:
                        error_data = response.json()
                        error_message = error_data.get("error", {}).get("message", "Unknown API error")
                        raise XoomError(f"API error: {error_message}")
                    except (ValueError, KeyError):
                        raise XoomError(f"API error: {response.status_code}")
                content_type = response.headers.get('Content-Type', '')
                if 'json' in current_headers.get('Accept', '') and 'html' in content_type.lower():
                    if retry_auth and retry_count < max_retries:
                        logger.warning(f"Received HTML when expecting JSON, session may be invalid. Refreshing (attempt {retry_count + 1}/{max_retries})")
                        self._initialize_session()
                        time.sleep(1)
                        retry_count += 1
                        continue
                    raise XoomError("Received HTML response when expecting JSON (possible auth issue)")
                try:
                    return response.json()
                except ValueError:
                    if response.status_code == 200 and not response.text.strip():
                        return {}
                    raise XoomError("Invalid JSON response from API")
            except requests.RequestException as e:
                logger.error(f"Request failed: {e}")
                if retry_count < max_retries:
                    logger.warning(f"Connection error, retrying (attempt {retry_count + 1}/{max_retries})")
                    time.sleep(2)
                    retry_count += 1
                    continue
                raise XoomConnectionError(f"Connection error: {e}")
        raise XoomError("Maximum retries exceeded")
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        send_currency: str = "USD",
        receive_country: str = None,
        receive_currency: str = None,
        delivery_method: str = None,  # Optional
        payment_method: str = None  # Optional
    ) -> Dict:
        if receive_country is None:
            raise XoomValidationError("Receive country is required")
        try:
            result = self._get_exchange_rate_via_fee_table(
                send_amount=send_amount,
                send_currency=send_currency,
                receive_country=receive_country,
                receive_currency=receive_currency
            )
            if result and "exchange_rate" in result and result["exchange_rate"] > 0:
                self.logger.info(f"Successfully got exchange rate via fee table: {result['exchange_rate']}")
                return result
        except Exception as e:
            self.logger.error(f"Fee table API failed: {str(e)}")
        self.logger.info("Fee table API failed, trying regular quote API")
        try:
            if not receive_currency:
                receive_currency = self._get_currency_for_country(receive_country)
            send_amount_float = float(send_amount)
            payload = {
                "data": {
                    "remittance": {
                        "sourceCurrency": send_currency,
                        "destinationCountry": receive_country,
                        "destinationCurrency": receive_currency,
                        "sendAmount": {
                            "amount": str(send_amount_float),
                            "currency": send_currency
                        }
                    }
                }
            }
            response = self._make_api_request(
                "POST",
                f"{self.base_url}/wapi/send-money-app/remittance-engine/remittance",
                data=payload
            )
            if not response or "data" not in response:
                raise XoomError("Failed to get exchange rate data")
            remittance_data = response["data"].get("remittance", {})
            if not remittance_data:
                raise XoomError("No remittance data available")
            quote = remittance_data.get("quote", {})
            if not quote:
                raise XoomError("No quote information available")
            pricing_options = quote.get("pricing", [])
            if not pricing_options:
                raise XoomError("No pricing options available")
            best_option = self._find_best_pricing_option(pricing_options)
            if not best_option:
                raise XoomError("No valid pricing options found")
            disbursement_type = best_option.get("disbursementType", "")
            payment_type = best_option.get("paymentType", {}).get("type", "")
            send_amount_data = best_option.get("sendAmount", {})
            receive_amount_data = best_option.get("receiveAmount", {})
            fee_amount_data = best_option.get("feeAmount", {})
            fx_rate_data = best_option.get("fxRate", {})
            fx_rate = self._extract_exchange_rate(fx_rate_data.get("comparisonString", ""))
            content_fields = best_option.get("content", [])
            content_data = self._process_content_fields(content_fields)
            delivery_time = content_data.get("paymentTypeHeader", "")
            delivery_time_minutes = self._parse_delivery_time(delivery_time)
            result = {
                "provider": "Xoom",
                "send_currency": send_currency,
                "send_amount": float(send_amount_data.get("rawValue", send_amount_float)),
                "receive_currency": receive_currency,
                "receive_amount": float(receive_amount_data.get("rawValue", 0)),
                "exchange_rate": fx_rate,
                "fee": float(fee_amount_data.get("rawValue", 0)),
                "delivery_method": self._normalize_delivery_method(disbursement_type),
                "payment_method": content_data.get("paymentType", payment_type),
                "estimated_delivery_time": delivery_time,
                "estimated_delivery_minutes": delivery_time_minutes
            }
            return result
        except Exception as e:
            self.logger.error(f"Regular API failed: {str(e)}")
        self.logger.warning("All API methods failed, using mock exchange rates")
        mock_rates = {
            "MXN": 20.15,
            "PHP": 55.75,
            "INR": 83.20,
            "COP": 3950.0,
            "ARS": 1150.0,
            "BRL": 5.20,
            "GTQ": 7.80,
            "CNY": 7.25,
            "USD": 1.0,
            "EUR": 0.92
        }
        if not receive_currency:
            receive_currency = self._get_currency_for_country(receive_country)
        exchange_rate = mock_rates.get(receive_currency, 10.0)
        send_amount_float = float(send_amount)
        receive_amount = send_amount_float * exchange_rate
        fee = 0.0
        if send_amount_float >= 1000:
            fee = 9.99
        elif send_amount_float >= 500:
            fee = 4.99
        elif send_amount_float >= 100:
            fee = 2.99
        return {
            "provider": "Xoom",
            "send_currency": send_currency,
            "send_amount": send_amount_float,
            "receive_currency": receive_currency,
            "receive_amount": receive_amount,
            "exchange_rate": exchange_rate,
            "fee": fee,
            "delivery_method": "bank deposit",
            "payment_method": "PayPal balance",
            "estimated_delivery_time": "Typically available within hours",
            "estimated_delivery_minutes": 180,
            "is_mock": True  # Flag to indicate this is mock data
        }
    def _get_exchange_rate_via_fee_table(
        self,
        send_amount: Decimal,
        send_currency: str,
        receive_country: str,
        receive_currency: str
    ) -> Dict:
        self.logger.info(f"Getting exchange rate via fee table for {send_amount} {send_currency} to {receive_country} ({receive_currency})")
        request_id = str(uuid.uuid4())
        timestamp = int(time.time() * 1000)
        send_amount_float = float(send_amount)
        params = {
            "sourceCountryCode": "US",
            "sourceCurrencyCode": send_currency,
            "destinationCountryCode": receive_country,
            "destinationCurrencyCode": receive_currency,
            "sendAmount": send_amount_float,
            "paymentType": "PAYPAL_BALANCE",
            "requestId": request_id,
            "_": timestamp
        }
        self.session.cookies.set("visitor_id", str(uuid.uuid4()), domain=".xoom.com")
        self.session.cookies.set("optimizelyEndUserId", str(uuid.uuid4()), domain=".xoom.com")
        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.9",
            "Referer": "https://www.xoom.com/send-money",
            "Connection": "keep-alive"
        }
        try:
            response = self.session.get(
                f"{self.base_url}/calculate-fee-table",
                params=params,
                headers=headers,
                timeout=self.timeout
            )
            if response.status_code != 200:
                self.logger.error(f"Fee table API returned status code {response.status_code}")
                return {}
            return self._parse_fee_table_response(
                response.text,
                send_amount_float,
                send_currency,
                receive_country,
                receive_currency
            )
        except requests.Timeout:
            self.logger.error("Request to fee table API timed out")
            return {}
        except Exception as e:
            self.logger.error(f"Error getting exchange rate via fee table: {str(e)}")
            return {}
    def _parse_fee_table_response(
        self,
        html_response: str,
        send_amount: float,
        send_currency: str,
        receive_country: str,
        receive_currency: str
    ) -> Dict:
        try:
            soup = BeautifulSoup(html_response, "html.parser")
            json_data_element = soup.find("data", id="jsonData")
            exchange_rate = 0.0
            receive_amount = 0.0
            fee = 0.0
            delivery_method = "bank deposit"  # Default
            payment_method = "PayPal balance"  # Default
            delivery_time_minutes = 60  # Default: 1 hour
            delivery_time_text = "Typically available within an hour"
            if json_data_element and json_data_element.string:
                json_data_str = json_data_element.string
                json_data_str = html.unescape(json_data_str)
                try:
                    json_data = json.loads(json_data_str)
                except json.JSONDecodeError:
                    json_data_str = json_data_str.replace("&quot;", '"').replace("\\'", "'")
                    match = re.search(r'(\{.*\})', json_data_str)
                    if match:
                        try:
                            json_data = json.loads(match.group(1))
                        except:
                            self.logger.warning("Failed to parse JSON data even after extraction")
                            json_data = {}
                    else:
                        self.logger.warning("Could not extract valid JSON from string")
                        json_data = {}
                if json_data and isinstance(json_data, dict) and "data" in json_data:
                    data = json_data["data"]
                    if "fxRate" in data and data["fxRate"]:
                        try:
                            exchange_rate = float(data["fxRate"])
                        except (ValueError, TypeError):
                            self.logger.warning("Could not convert fxRate to float")
                    if "receiveAmount" in data and data["receiveAmount"]:
                        try:
                            receive_amount = float(data["receiveAmount"])
                        except (ValueError, TypeError):
                            self.logger.warning("Could not convert receiveAmount to float")
            fee_tables = soup.select("div.xvx-table-container")
            if fee_tables:
                for table_container in fee_tables:
                    heading = table_container.select_one("p.xvx-table-container__heading")
                    if heading and "fee for" in heading.text.lower():
                        delivery_method_text = heading.text.lower().replace("fee for", "").strip()
                        if delivery_method_text:
                            delivery_method = delivery_method_text
                    fee_rows = table_container.select("tr.xvx-table--fee__body-tr")
                    for row in fee_rows:
                        payment_cell = row.select_one("td.xvx-table--fee__body-td:first-child")
                        fee_cell = row.select_one("td.xvx-table--fee__body-td.fee-value")
                        if payment_cell and fee_cell:
                            payment_option = payment_cell.text.strip()
                            fee_value = fee_cell.text.strip().replace("$", "").replace(",", "")
                            try:
                                fee_float = float(fee_value)
                                if "paypal balance" in payment_option.lower():
                                    payment_method = payment_option
                                    fee = fee_float
                            except ValueError:
                                continue
            if exchange_rate <= 0 and receive_amount > 0 and send_amount > 0:
                exchange_rate = receive_amount / send_amount
            result = {
                "provider": "Xoom",
                "send_currency": send_currency,
                "send_amount": send_amount,
                "receive_currency": receive_currency,
                "receive_amount": receive_amount,
                "exchange_rate": exchange_rate,
                "fee": fee,
                "delivery_method": delivery_method,
                "payment_method": payment_method,
                "estimated_delivery_time": delivery_time_text,
                "estimated_delivery_minutes": delivery_time_minutes
            }
            self.logger.info(f"Parsed exchange rate: {exchange_rate}, receive amount: {receive_amount}, fee: {fee}")
            return result
        except Exception as e:
            self.logger.error(f"Error parsing fee table response: {str(e)}")
            return {
                "provider": "Xoom",
                "send_currency": send_currency,
                "send_amount": send_amount,
                "receive_currency": receive_currency,
                "receive_amount": 0.0,
                "exchange_rate": 0.0,
                "fee": 0.0,
                "delivery_method": "bank deposit",
                "payment_method": "PayPal balance",
                "estimated_delivery_time": "Unknown",
                "estimated_delivery_minutes": None,
                "error": str(e)
            }
    def _filter_pricing_options(
        self, 
        pricing_options: List[Dict],
        preferred_delivery_method: Optional[str] = None,
        preferred_payment_method: Optional[str] = None
    ) -> List[Dict]:
        if not pricing_options:
            return []
        filtered_options = pricing_options.copy()
        if preferred_delivery_method:
            delivery_filtered = [
                opt for opt in filtered_options 
                if opt.get("disbursementType") == preferred_delivery_method
            ]
            if delivery_filtered:
                filtered_options = delivery_filtered
        if preferred_payment_method:
            payment_filtered = [
                opt for opt in filtered_options 
                if opt.get("paymentType", {}).get("type") == preferred_payment_method
            ]
            if payment_filtered:
                filtered_options = payment_filtered
        if not filtered_options:
            return pricing_options
        filtered_options.sort(key=lambda opt: float(opt.get("feeAmount", {}).get("rawValue", "9999")))
        return filtered_options
    def _find_best_pricing_option(
        self, 
        pricing_options: List[Dict],
        preferred_delivery_method: Optional[str] = None,
        preferred_payment_method: Optional[str] = None
    ) -> Optional[Dict]:
        if not pricing_options:
            return None
        def score_option(option):
            score = 0
            if preferred_delivery_method and option["disbursementType"] == preferred_delivery_method:
                score += 100
            if preferred_payment_method and option["paymentType"]["type"] == preferred_payment_method:
                score += 50
            fee = float(option["feeAmount"]["rawValue"])
            score -= fee * 2
            receive_amount = float(option["receiveAmount"]["rawValue"])
            score += receive_amount * 0.001
            return score
        scored_options = [(score_option(option), option) for option in pricing_options]
        scored_options.sort(reverse=True)  # Sort by score in descending order
        return scored_options[0][1] if scored_options else None
    def _get_default_currency_for_country(self, country_code: str) -> Optional[str]:
        country_to_currency = {
            "US": "USD",
            "MX": "MXN",
            "PH": "PHP",
            "CO": "COP",
            "IN": "INR",
            "GT": "GTQ",
            "SV": "USD",
            "DO": "DOP",
            "HN": "HNL",
            "PE": "PEN",
            "EC": "USD",
            "BR": "BRL",
            "NI": "NIO",
            "JM": "JMD",
            "CN": "CNY",
            "LK": "LKR"
        }
        return country_to_currency.get(country_code)
    def _get_currency_for_country(self, country_code: str) -> str:
        return self._get_default_currency_for_country(country_code) or "USD"
    def get_supported_countries(self) -> List[Dict]:
        if self._countries_cache:
            return self._countries_cache
        try:
            url = f"{self.BASE_URL}/en-us/send-money"
            logger.info(f"Getting supported countries from: {url}")
            response = self.session.get(
                url=url,
                timeout=self.timeout,
                allow_redirects=True
            )
            if response.status_code != 200:
                logger.warning(f"Failed to get countries, status: {response.status_code}")
                return self._get_static_country_list()
            soup = BeautifulSoup(response.text, 'html.parser')
            countries = []
            country_data_script = soup.find("script", string=re.compile(r'window\.__INITIAL_STATE__'))
            if country_data_script:
                match = re.search(r'window\.__INITIAL_STATE__\s*=\s*({.*?});', country_data_script.string, re.DOTALL)
                if match:
                    try:
                        data = json.loads(match.group(1))
                        countries_data = data.get('data', {}).get('countries', [])
                        for country in countries_data:
                            if 'code' in country and 'name' in country:
                                currency_code = country.get('currency') or self._get_currency_for_country(country['code'])
                                countries.append({
                                    "country_code": country['code'],
                                    "country_name": country['name'],
                                    "currency_code": currency_code
                                })
                    except (json.JSONDecodeError, KeyError) as e:
                        logger.error(f"Error parsing country data: {e}")
            if not countries:
                country_links = soup.select("a[href*='countryCode=']")
                for link in country_links:
                    href = link.get('href', '')
                    country_match = re.search(r'countryCode=([A-Z]{2})', href)
                    if country_match:
                        country_code = country_match.group(1)
                        country_name = self.COUNTRY_CODES.get(country_code, country_code)
                        currency_code = self._get_currency_for_country(country_code)
                        if not any(c['country_code'] == country_code for c in countries):
                            countries.append({
                                "country_code": country_code,
                                "country_name": country_name,
                                "currency_code": currency_code
                            })
            if countries:
                self._countries_cache = countries
                return countries
            return self._get_static_country_list()
        except Exception as e:
            logger.error(f"Error getting supported countries: {e}")
            return self._get_static_country_list()
    def _get_static_country_list(self) -> List[Dict]:
        return [
            {"country_code": "MX", "country_name": "Mexico", "currency_code": "MXN"},
            {"country_code": "PH", "country_name": "Philippines", "currency_code": "PHP"},
            {"country_code": "IN", "country_name": "India", "currency_code": "INR"},
            {"country_code": "CO", "country_name": "Colombia", "currency_code": "COP"},
            {"country_code": "GT", "country_name": "Guatemala", "currency_code": "GTQ"},
            {"country_code": "SV", "country_name": "El Salvador", "currency_code": "USD"},
            {"country_code": "DO", "country_name": "Dominican Republic", "currency_code": "DOP"},
            {"country_code": "HN", "country_name": "Honduras", "currency_code": "HNL"},
            {"country_code": "PE", "country_name": "Peru", "currency_code": "PEN"},
            {"country_code": "EC", "country_name": "Ecuador", "currency_code": "USD"},
            {"country_code": "BR", "country_name": "Brazil", "currency_code": "BRL"},
            {"country_code": "NI", "country_name": "Nicaragua", "currency_code": "NIO"},
            {"country_code": "JM", "country_name": "Jamaica", "currency_code": "JMD"},
            {"country_code": "CN", "country_name": "China", "currency_code": "CNY"},
            {"country_code": "LK", "country_name": "Sri Lanka", "currency_code": "LKR"}
        ]
    def get_payment_methods(self, source_country: str = "US", target_country: str = "MX") -> List[Dict]:
        payload = {
            "data": {
                "remittance": {
                    "sourceCurrency": "USD",
                    "destinationCountry": target_country,
                    "destinationCurrency": self._get_currency_for_country(target_country)
                }
            }
        }
        try:
            response = self._make_api_request(
                method="POST",
                url=self.API_URL,
                data=payload
            )
            if (not response or "data" not in response or 
                "remittance" not in response["data"] or
                "quote" not in response["data"]["remittance"] or
                "pricing" not in response["data"]["remittance"]["quote"]):
                return self._get_static_payment_methods()
            pricing_options = response["data"]["remittance"]["quote"]["pricing"]
            payment_methods = []
            payment_method_ids = set()
            for option in pricing_options:
                payment_type = option["paymentType"]["type"]
                if payment_type not in payment_method_ids:
                    payment_method_ids.add(payment_type)
                    fee = float(option["feeAmount"]["rawValue"])
                    description = None
                    for content_item in option.get("content", []):
                        if content_item["key"] == "feesFx.paymentType":
                            description = content_item["value"]
                            break
                    payment_methods.append({
                        "id": payment_type,
                        "name": self.PAYMENT_METHODS.get(payment_type, payment_type),
                        "type": "card" if "CARD" in payment_type else "electronic",
                        "description": description or f"Pay with {self.PAYMENT_METHODS.get(payment_type, payment_type)}",
                        "fee": fee,
                        "is_default": payment_type == "PAYPAL_BALANCE"
                    })
            payment_methods.sort(key=lambda x: x.get("fee", 0))
            return payment_methods
        except Exception as e:
            logger.error(f"Error getting payment methods: {e}")
            return self._get_static_payment_methods()
    def _get_static_payment_methods(self) -> List[Dict]:
        return [
            {
                "id": "PAYPAL_BALANCE",
                "name": "PayPal balance",
                "type": "electronic",
                "description": "Pay with PayPal balance",
                "fee": 0.00,
                "is_default": True
            },
            {
                "id": "CRYPTO_PYUSD",
                "name": "PayPal USD (PYUSD)",
                "type": "electronic",
                "description": "Pay with PayPal USD stablecoin",
                "fee": 0.00,
                "is_default": False
            },
            {
                "id": "ACH",
                "name": "Bank Account",
                "type": "electronic",
                "description": "Pay with your bank account",
                "fee": 0.00,
                "is_default": False
            },
            {
                "id": "DEBIT_CARD",
                "name": "Debit Card",
                "type": "card",
                "description": "Pay with your debit card",
                "fee": 3.99,
                "is_default": False
            },
            {
                "id": "CREDIT_CARD",
                "name": "Credit Card",
                "type": "card",
                "description": "Pay with your credit card",
                "fee": 3.99,
                "is_default": False
            }
        ]
    def get_delivery_methods(self, source_country: str = "US", target_country: str = "MX") -> List[Dict]:
        payload = {
            "data": {
                "remittance": {
                    "sourceCurrency": "USD",
                    "destinationCountry": target_country,
                    "destinationCurrency": self._get_currency_for_country(target_country)
                }
            }
        }
        try:
            response = self._make_api_request(
                method="POST",
                url=self.API_URL,
                data=payload
            )
            if (not response or "data" not in response or 
                "remittance" not in response["data"] or
                "quote" not in response["data"]["remittance"] or
                "pricing" not in response["data"]["remittance"]["quote"]):
                return self._get_static_delivery_methods()
            pricing_options = response["data"]["remittance"]["quote"]["pricing"]
            delivery_methods = []
            delivery_method_ids = set()
            for option in pricing_options:
                disbursement_type = option["disbursementType"]
                if disbursement_type not in delivery_method_ids:
                    delivery_method_ids.add(disbursement_type)
                    name = None
                    description = None
                    delivery_time = None
                    for content_item in option.get("content", []):
                        if content_item["key"] == "feesFx.disbursementType":
                            name = content_item["value"]
                        elif content_item["key"] == "feesFx.paymentTypeParagraph":
                            description = content_item["value"]
                        elif content_item["key"] == "feesFx.paymentTypeHeader" and "minutes" in content_item["value"].lower():
                            delivery_time = content_item["value"]
                    delivery_methods.append({
                        "id": disbursement_type,
                        "name": name or self.DELIVERY_METHODS.get(disbursement_type, disbursement_type),
                        "description": description or f"Send money via {self.DELIVERY_METHODS.get(disbursement_type, disbursement_type)}",
                        "delivery_time": delivery_time,
                        "is_default": disbursement_type == "DEPOSIT"
                    })
            return delivery_methods
        except Exception as e:
            logger.error(f"Error getting delivery methods: {e}")
            return self._get_static_delivery_methods()
    def _get_static_delivery_methods(self) -> List[Dict]:
        return [
            {
                "id": "DEPOSIT",
                "name": "Bank Deposit",
                "description": "Transfer directly to bank account",
                "delivery_time": "Typically available in 1-2 business days",
                "is_default": True
            },
            {
                "id": "PICKUP",
                "name": "Cash Pickup",
                "description": "Available at partner locations like Walmart, OXXO",
                "delivery_time": "Typically available within hours",
                "is_default": False
            },
            {
                "id": "MOBILE_WALLET",
                "name": "Mobile Wallet",
                "description": "Send to mobile wallet services like Mercado Pago",
                "delivery_time": "Typically available in minutes",
                "is_default": False
            },
            {
                "id": "CARD_DEPOSIT",
                "name": "Debit Card Deposit",
                "description": "Send directly to debit card",
                "delivery_time": "Typically available in minutes",
                "is_default": False
            }
        ]
    def _extract_exchange_rate(self, rate_string: str) -> float:
        if not rate_string:
            return 0.0
        match = re.search(r'(\d+[\.,]?\d*)\s*[A-Z]{3}', rate_string)
        if match:
            try:
                rate_str = match.group(1).replace(',', '.')
                return float(rate_str)
            except (ValueError, IndexError):
                pass
        match = re.search(r'=\s*(\d+[\.,]?\d*)', rate_string)
        if match:
            try:
                rate_str = match.group(1).replace(',', '.')
                return float(rate_str)
            except (ValueError, IndexError):
                pass
        return 0.0
    def _normalize_delivery_method(self, method_type: str) -> str:
        method_map = {
            "DEPOSIT": "bank deposit",
            "PICKUP": "cash pickup",
            "CARD_DEPOSIT": "card deposit",
            "MOBILE_WALLET": "mobile wallet"
        }
        return method_map.get(method_type, method_type.lower())
    def _process_content_fields(self, content_fields: List[Dict]) -> Dict:
        result = {}
        for field in content_fields:
            key = field.get("key", "").split(".")[-1]  # Use the last part of the key
            value = field.get("value", "")
            if key and value:
                result[key] = value
        return result
    def _parse_delivery_time(self, time_string: str) -> Optional[int]:
        if not time_string:
            return None
        minutes_match = re.search(r'(\d+)\s*minutes?', time_string.lower())
        if minutes_match:
            try:
                return int(minutes_match.group(1))
            except (ValueError, IndexError):
                pass
        hours_match = re.search(r'(\d+)\s*hours?', time_string.lower())
        if hours_match:
            try:
                return int(hours_match.group(1)) * 60
            except (ValueError, IndexError):
                pass
        days_match = re.search(r'(\d+)\s*days?', time_string.lower())
        if days_match:
            try:
                return int(days_match.group(1)) * 24 * 60
            except (ValueError, IndexError):
                pass
        if "within an hour" in time_string.lower():
            return 60
        elif "within hours" in time_string.lower():
            return 180  # 3 hours as a reasonable default
        elif "1-2 business days" in time_string.lower():
            return 36 * 60  # 1.5 days in minutes
        elif "next day" in time_string.lower():
            return 24 * 60
        return None
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.session.close() 
###END

###FILE:./apps/providers/__init__.py
from .factory import ProviderFactory
def get_provider_by_name(provider_name, **kwargs):
    return ProviderFactory.get_provider(provider_name, **kwargs)
def list_providers():
    return ProviderFactory.list_providers()
###END

###FILE:./apps/providers/utils/currency_mapping.py
CURRENCY_NAMES = {
    'USD': 'US Dollar',
    'EUR': 'Euro',
    'GBP': 'British Pound',
    'CAD': 'Canadian Dollar',
    'AUD': 'Australian Dollar',
    'JPY': 'Japanese Yen',
    'INR': 'Indian Rupee',
    'CNY': 'Chinese Yuan',
    'MXN': 'Mexican Peso',
    'BRL': 'Brazilian Real',
}
COUNTRY_NAMES = {
    'US': 'United States',
    'GB': 'United Kingdom',
    'CA': 'Canada',
    'AU': 'Australia',
    'JP': 'Japan',
    'IN': 'India',
    'CN': 'China',
    'MX': 'Mexico',
    'BR': 'Brazil',
    'DE': 'Germany',
}
COUNTRY_CURRENCIES = {
    'US': ['USD'],
    'GB': ['GBP'],
    'CA': ['CAD'],
    'AU': ['AUD'],
    'JP': ['JPY'],
    'IN': ['INR'],
    'CN': ['CNY'],
    'MX': ['MXN'],
    'BR': ['BRL'],
    'DE': ['EUR'],
}
def get_currency_name(currency_code: str) -> str:
    return CURRENCY_NAMES.get(currency_code.upper(), currency_code)
def get_country_name(country_code: str) -> str:
    return COUNTRY_NAMES.get(country_code.upper(), country_code)
def get_country_currencies(country_code: str) -> list:
    return COUNTRY_CURRENCIES.get(country_code.upper(), []) 
###END

###END

from apps.providers.sendwave.integration import WaveProvider
from apps.providers.sendwave.exceptions import (
    SendwaveError,
    SendwaveConnectionError,
    SendwaveApiError,
    SendwaveValidationError,
    SendwaveResponseError,
    SendwaveCorridorUnsupportedError
)
__all__ = [
    'WaveProvider',
    'SendwaveError',
    'SendwaveConnectionError',
    'SendwaveApiError',
    'SendwaveValidationError',
    'SendwaveResponseError',
    'SendwaveCorridorUnsupportedError'
] 
###END

import logging
import requests
from decimal import Decimal
from typing import Dict, Any, Optional, List
from apps.providers.base.provider import RemittanceProvider
from apps.providers.sendwave.exceptions import (
    SendwaveError,
    SendwaveConnectionError,
    SendwaveApiError,
    SendwaveValidationError,
    SendwaveResponseError,
    SendwaveCorridorUnsupportedError
)
logger = logging.getLogger(__name__)
class WaveProvider(RemittanceProvider):
    BASE_URL = "https://app.sendwave.com"
    PRICING_ENDPOINT = "/v2/pricing-public"
    COUNTRY_TO_CURRENCY = {
        "PH": "PHP",  # Philippines
        "KE": "KES",  # Kenya
        "UG": "UGX",  # Uganda
        "GH": "GHS",  # Ghana
    }
    SUPPORTED_CORRIDORS = [
        ("USD", "PH"),  # e.g. US → Philippines
        ("USD", "KE"),  # e.g. US → Kenya
    ]
    def __init__(self, name="sendwave", base_url: Optional[str] = None, **kwargs):
        super().__init__(name=name, base_url=base_url or self.BASE_URL)
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                          "AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15",
            "Accept": "application/json, text/plain, */*",
            "Origin": "https://www.sendwave.com",
            "Referer": "https://www.sendwave.com/"
        })
    def is_corridor_supported(self, send_currency: str, receive_country: str) -> bool:
        return (send_currency, receive_country) in self.SUPPORTED_CORRIDORS
    def get_supported_countries(self, base_currency: str = None) -> List[str]:
        if base_currency is None:
            return sorted(set(c for (cur, c) in self.SUPPORTED_CORRIDORS))
        else:
            return sorted(c for (cur, c) in self.SUPPORTED_CORRIDORS if cur == base_currency)
    def _get_receive_currency(self, country_code: str) -> str:
        return self.COUNTRY_TO_CURRENCY.get(country_code, "USD")
    def get_exchange_rate(self, send_amount: Decimal, send_currency: str, receive_country: str, **kwargs) -> Dict[str, Any]:
        logger.info(f"Requesting Sendwave quote: {send_currency} to {receive_country} for {send_amount} {send_currency}")
        result = {
            "provider": self.name,
            "send_amount": float(send_amount),
            "send_currency": send_currency,
            "receive_country": receive_country,
            "success": False,
            "error_message": None
        }
        if not self.is_corridor_supported(send_currency, receive_country):
            msg = f"Corridor not in SUPPORTED_CORRIDORS: {send_currency}->{receive_country}"
            logger.warning(msg)
            result["error_message"] = msg
            raise SendwaveCorridorUnsupportedError(msg)
        receive_currency = self._get_receive_currency(receive_country)
        segment_name = kwargs.get("segment_name", "ph_gcash" if receive_country == "PH" else "")
        send_country_iso2 = kwargs.get("send_country_iso2", "us")
        endpoint_url = f"{self.base_url}{self.PRICING_ENDPOINT}"
        params = {
            "amountType": "SEND",
            "receiveCurrency": receive_currency,
            "segmentName": segment_name,
            "amount": str(send_amount),
            "sendCurrency": send_currency,
            "sendCountryIso2": send_country_iso2,
            "receiveCountryIso2": receive_country.lower()  # 'ph', 'ke', etc.
        }
        try:
            resp = self.session.get(endpoint_url, params=params, timeout=15)
            resp.raise_for_status()
        except requests.HTTPError as exc:
            msg = f"HTTP error fetching wave quote: {exc}"
            logger.error(msg)
            result["error_message"] = msg
            raise SendwaveApiError(msg) from exc
        except requests.ConnectionError as exc:
            msg = f"Connection error fetching wave quote: {exc}"
            logger.error(msg)
            result["error_message"] = msg
            raise SendwaveConnectionError(msg) from exc
        except Exception as e:
            msg = f"Error requesting wave quote: {e}"
            logger.error(msg)
            result["error_message"] = msg
            raise SendwaveError(msg) from e
        try:
            data = resp.json()  # Typically an object with e.g. "receiveAmount", "exchangeRate", "fees", etc.
        except ValueError as ve:
            msg = f"Invalid JSON response from wave: {ve}"
            logger.error(msg)
            result["error_message"] = msg
            raise SendwaveResponseError(msg) from ve
        if "effectiveExchangeRate" not in data or "effectiveSendAmount" not in data:
            msg = "Missing required fields in Sendwave response"
            logger.error(msg)
            result["error_message"] = msg
            raise SendwaveResponseError(msg)
        exchange_rate = float(data["effectiveExchangeRate"])
        fee = float(data.get("effectiveFeeAmount", 0.0))
        send_amount = float(data["effectiveSendAmount"])
        receive_amount = send_amount * exchange_rate
        promotions = []
        if "campaignsApplied" in data and data["campaignsApplied"]:
            for campaign in data["campaignsApplied"]:
                promotions.append({
                    "code": campaign.get("code", ""),
                    "description": campaign.get("description", ""),
                    "value": campaign.get("sendCurrencyValue", "0")
                })
        result.update({
            "receive_currency": receive_currency,
            "exchange_rate": exchange_rate,
            "fee": fee,
            "receive_amount": receive_amount,
            "promotions": promotions,
            "raw_data": data,
            "success": True
        })
        logger.info(
            f"Sendwave quote success: {send_amount} {send_currency} => {receive_amount} {receive_currency} "
            f"(rate={exchange_rate}, fee={fee})"
        )
        return result 
###END

###FILE:./apps/providers/factory.py
from typing import Dict, Type
from .base.provider import RemittanceProvider
from .remitbee.integration import RemitbeeProvider
from .remitguru.integration import RemitGuruProvider
from .xe.integration import XEProvider
from .sendwave.integration import WaveProvider as SendwaveProvider
from .rewire.integration import RewireProvider
from .mukuru.integration import MukuruProvider
from .dahabshiil.integration import DahabshiilProvider
from .alansari.integration import AlAnsariProvider
from .placid.integration import PlacidProvider
from .orbitremit.integration import OrbitRemitProvider
from .wirebarley.integration import WireBarleyProvider
class ProviderFactory:
    _providers: Dict[str, Type[RemittanceProvider]] = {
        'remitbee': RemitbeeProvider,
        'remitguru': RemitGuruProvider,
        'xe': XEProvider,
        'sendwave': SendwaveProvider,
        'rewire': RewireProvider,
        'mukuru': MukuruProvider,
        'dahabshiil': DahabshiilProvider,
        'alansari': AlAnsariProvider,
        'placid': PlacidProvider,
        'orbitremit': OrbitRemitProvider,
        'wirebarley': WireBarleyProvider,
    }
    @classmethod
    def get_provider(cls, provider_name: str, **kwargs) -> RemittanceProvider:
        if provider_name not in cls._providers:
            raise ValueError(f"Unsupported provider: {provider_name}")
        provider_class = cls._providers[provider_name]
        return provider_class(**kwargs)
    @classmethod
    def register_provider(cls, name: str, provider_class: Type[RemittanceProvider]) -> None:
        cls._providers[name] = provider_class
    @classmethod
    def get_available_providers(cls) -> Dict[str, Type[RemittanceProvider]]:
        return dict(cls._providers)
###END

from .integration import AlAnsariProvider
from .exceptions import (
    AlAnsariError,
    AlAnsariConnectionError,
    AlAnsariApiError,
    AlAnsariResponseError,
    AlAnsariCorridorUnsupportedError,
    AlAnsariRateLimitError,
    AlAnsariSecurityTokenError,
)
__all__ = [
    'AlAnsariProvider',
    'AlAnsariError',
    'AlAnsariConnectionError',
    'AlAnsariApiError',
    'AlAnsariResponseError',
    'AlAnsariCorridorUnsupportedError',
    'AlAnsariRateLimitError',
    'AlAnsariSecurityTokenError',
] 
###END

import logging
import requests
import re
import json
from decimal import Decimal
from typing import Any, Dict, Optional, List, Union, Tuple
from apps.providers.base.provider import RemittanceProvider
from .exceptions import (
    AlAnsariError,
    AlAnsariConnectionError,
    AlAnsariApiError,
    AlAnsariResponseError,
    AlAnsariCorridorUnsupportedError,
    AlAnsariSecurityTokenError,
)
logger = logging.getLogger(__name__)
class AlAnsariProvider(RemittanceProvider):
    BASE_URL = "https://alansariexchange.com/wp-admin/admin-ajax.php"
    CURRENCY_ID_MAPPING = {
        'AED': '91',  # UAE Dirham
        'INR': '27',  # Indian Rupee
        'LKR': '30',  # Sri Lankan Rupee
        'BDT': '31',  # Bangladesh Taka
        'PKR': '28',  # Pakistani Rupee (unconfirmed)
        'PHP': '29',  # Philippine Peso (unconfirmed)
    }
    DEFAULT_SECURITY_TOKEN = '50fd6ea0d6'
    def __init__(self, name="alansari", **kwargs):
        super().__init__(name=name, base_url=self.BASE_URL)
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": ("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                           "AppleWebKit/605.1.15 (KHTML, like Gecko) "
                           "Version/18.3 Safari/605.1.15"),
            "Accept": "*/*",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "X-Requested-With": "XMLHttpRequest",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
        })
        self.logger = logging.getLogger(f"providers.{name}")
        self.security_token = kwargs.get('security_token', self.DEFAULT_SECURITY_TOKEN)
    def get_currency_id(self, currency_code: str) -> Optional[str]:
        return self.CURRENCY_ID_MAPPING.get(currency_code.upper())
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        from_currency_id: Optional[str] = None,
        to_currency_id: Optional[str] = None,
        security_token: Optional[str] = None,
        transfer_type: str = "BT",
        from_currency: Optional[str] = None,
        to_currency: Optional[str] = None,
        **kwargs
    ) -> Dict[str, Any]:
        if not from_currency_id and from_currency:
            from_currency_id = self.get_currency_id(from_currency)
            if not from_currency_id:
                error_msg = f"Unknown currency code: {from_currency}"
                self.logger.error(error_msg)
                return {
                    "provider": self.name,
                    "success": False,
                    "error_message": error_msg
                }
        if not to_currency_id and to_currency:
            to_currency_id = self.get_currency_id(to_currency)
            if not to_currency_id:
                error_msg = f"Unknown currency code: {to_currency}"
                self.logger.error(error_msg)
                return {
                    "provider": self.name,
                    "success": False,
                    "error_message": error_msg
                }
        if not from_currency_id:
            error_msg = "Missing from_currency_id or from_currency"
            self.logger.error(error_msg)
            return {
                "provider": self.name,
                "success": False,
                "error_message": error_msg
            }
        if not to_currency_id:
            error_msg = "Missing to_currency_id or to_currency"
            self.logger.error(error_msg)
            return {
                "provider": self.name,
                "success": False,
                "error_message": error_msg
            }
        if not security_token:
            security_token = self.security_token
        result = {
            "provider": self.name,
            "success": False,
            "send_amount": float(send_amount),
            "from_currency_id": from_currency_id,
            "to_currency_id": to_currency_id,
            "transfer_type": transfer_type,
            "exchange_rate": None,
            "receive_amount": None,
            "error_message": None,
        }
        if from_currency:
            result["from_currency"] = from_currency
        if to_currency:
            result["to_currency"] = to_currency
        payload = {
            "action": "convert_action",
            "currfrom": from_currency_id,
            "currto": to_currency_id,  
            "cntcode": to_currency_id,  # From logs, cntcode often matches currto 
            "amt": f"{send_amount:.3f}",   # e.g. '1.000'
            "security": security_token,    # e.g. '50fd6ea0d6'
            "trtype": transfer_type,       # e.g. 'BT'
        }
        self.logger.debug(f"Al Ansari POST: {self.base_url} with payload={payload}")
        try:
            resp = self.session.post(self.base_url, data=payload, timeout=15)
            resp.raise_for_status()
            data = resp.json()  # Expected JSON: {"amount":"76.140","get_rate":"76.3359","status_msg":"SUCCESS"}
            self.logger.debug(f"Al Ansari response: {data}")
            if data.get("status_msg") == "SUCCESS":
                rate_str = data.get("get_rate", None)
                if rate_str is not None:
                    rate_val = float(rate_str)
                    result["exchange_rate"] = rate_val
                amt_str = data.get("amount", None)
                if amt_str is not None:
                    recv_val = float(amt_str)
                    result["receive_amount"] = recv_val
                result["success"] = True
            else:
                msg = f"Al Ansari returned status_msg != SUCCESS: {data}"
                self.logger.error(msg)
                result["error_message"] = msg
                if "security" in str(data).lower():
                    raise AlAnsariSecurityTokenError(f"Invalid or expired security token: {security_token}")
        except requests.HTTPError as e:
            error_msg = f"HTTP error: {str(e)}"
            self.logger.error(error_msg)
            result["error_message"] = error_msg
            if e.response.status_code == 401 or e.response.status_code == 403:
                raise AlAnsariSecurityTokenError(f"Security token issue: {str(e)}")
            else:
                raise AlAnsariApiError(f"API error: {str(e)}")
        except requests.RequestException as e:
            error_msg = f"Request error: {str(e)}"
            self.logger.error(error_msg)
            result["error_message"] = error_msg
            raise AlAnsariConnectionError(error_msg)
        except (ValueError, json.JSONDecodeError) as e:
            error_msg = f"Error parsing Al Ansari JSON response: {str(e)}"
            self.logger.error(error_msg)
            result["error_message"] = error_msg
            raise AlAnsariResponseError(error_msg)
        return result
    def get_quote(
        self,
        amount: Decimal,
        source_currency: str,
        target_currency: str,
        **kwargs
    ) -> Dict[str, Any]:
        security_token = kwargs.pop('security_token', self.security_token)
        transfer_type = kwargs.pop('transfer_type', 'BT')
        return self.get_exchange_rate(
            send_amount=amount,
            from_currency=source_currency,
            to_currency=target_currency,
            security_token=security_token,
            transfer_type=transfer_type,
            **kwargs
        ) 
###END

###END

import logging
import requests
import time
import json
from urllib3.util import SSLContext
from urllib3.util.ssl_ import create_urllib3_context
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import urllib3
import random
import string
from datetime import datetime
import uuid
import certifi
from typing import Dict, Optional, Any
from apps.providers.ria.exceptions import (
    RIAError,
    RIAAuthenticationError,
    RIAValidationError,
    RIAConnectionError
)
urllib3.add_stderr_logger()
class TLSAdapter(HTTPAdapter):
    def init_poolmanager(self, *args, **kwargs):
        ctx = create_urllib3_context()
        ctx.options |= 0x4  # OP_LEGACY_SERVER_CONNECT
        kwargs["ssl_context"] = ctx
        return super().init_poolmanager(*args, **kwargs)
    def proxy_manager_for(self, *args, **kwargs):
        kwargs["ssl_context"] = create_urllib3_context()
        return super().proxy_manager_for(*args, **kwargs)
class RIAProvider:
    BASE_URL = "https://public.riamoneytransfer.com"
    def __init__(self, timeout: int = 30):
        self.name = "RIA"
        self.timeout = timeout
        self.logger = logging.getLogger(__name__)
        self._session = requests.Session()
        self.bearer_token = None
        self.token_expiry = None
        self.calculator_data = None
        self.debug_mode = True  # Always on debug mode to capture full responses
        self._session.verify = certifi.where()
        self.logger.debug("Using certifi CA bundle from: %s", certifi.where())
        country_code = "US"
        self._session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept': 'application/json, text/plain, */*',
            'Accept-Encoding': 'gzip, deflate, br',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-site',
            'Sec-Fetch-Dest': 'empty',
            'Priority': 'u=3, i',
            'AppType': '2',
            'AppVersion': '4.0',
            'Client-Type': 'PublicSite',
            'CultureCode': 'en-US',
            'Content-Type': 'application/json',
            'Origin': 'https://www.riamoneytransfer.com',
            'Referer': 'https://www.riamoneytransfer.com/',
            'X-Client-Platform': 'Web',
            'X-Client-Version': '4.0.0',
            'X-Device-Id': 'WEB-'+''.join(random.choices(string.ascii_uppercase + string.digits, k=16)),
            'Connection': 'keep-alive',
            'IAmFrom': country_code,
            'CountryId': country_code,
            'IsoCode': country_code
        })
        self._session.mount('https://', TLSAdapter())
        self._configure_tls()
        retry_strategy = Retry(
            total=3,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["POST", "GET"]
        )
        self._session.mount('https://', TLSAdapter(max_retries=retry_strategy))
        self.get_session_info()
        self.initialize_calculator()
    def _configure_tls(self):
        ctx = create_urllib3_context()
        ctx.options |= (
            0x4  # OP_LEGACY_SERVER_CONNECT
            | 0x80000  # OP_ENABLE_MIDDLEBOX_COMPAT
        )
        ctx.load_default_certs()
    def get_session_info(self) -> dict:
        try:
            self.logger.debug("Getting session info and token from /Authorization/session")
            response = self._session.get(
                f"{self.BASE_URL}/Authorization/session",
                timeout=self.timeout
            )
            response.raise_for_status()
            self.logger.debug("Response headers: %s", dict(response.headers))
            session_data = response.json()
            if 'bearer' in response.headers:
                self.bearer_token = response.headers['bearer']
                self._session.headers['Authorization'] = f'Bearer {self.bearer_token}'
                self.logger.info("Acquired bearer token from session response headers")
                if 'expiresIn' in response.headers:
                    expires_in = int(response.headers['expiresIn'])
                    self.token_expiry = time.time() + expires_in
                else:
                    self.token_expiry = time.time() + 1800  # Default 30 minutes
            else:
                self.logger.warning("No bearer token in session response headers")
            if response.cookies:
                self.logger.debug("Received cookies: %s", dict(response.cookies))
            return session_data
        except requests.RequestException as e:
            self.logger.error("Session initialization failed: %s", str(e), exc_info=True)
            if hasattr(e, 'response') and e.response is not None:
                raise RIAConnectionError(f"Failed to get session info: {e.response.status_code}")
            raise RIAConnectionError(f"Failed to get session info: {str(e)}")
    def initialize_calculator(self) -> dict:
        try:
            response = self._session.get(
                f"{self.BASE_URL}/Calculator/Initialize",
                timeout=self.timeout
            )
            response.raise_for_status()
            self.logger.debug("Initialize calculator headers: %s", dict(response.headers))
            init_data = response.json()
            self.calculator_data = init_data
            if 'bearer' in response.headers:
                new_token = response.headers['bearer']
                if new_token != self.bearer_token:
                    self.bearer_token = new_token
                    self._session.headers['Authorization'] = f'Bearer {new_token}'
                    self.logger.info("Updated bearer token from calculator init response")
                    if 'expiresIn' in response.headers:
                        expires_in = int(response.headers['expiresIn'])
                        self.token_expiry = time.time() + expires_in
            self.logger.debug("Calculator initialized successfully")
            return init_data
        except requests.RequestException as e:
            self.logger.error("Calculator init failed: %s", str(e), exc_info=True)
            if hasattr(e, 'response') and e.response is not None:
                raise RIAConnectionError(f"Failed to initialize calculator: {e.response.status_code}")
            raise RIAConnectionError(f"Failed to initialize calculator: {str(e)}")
    def _ensure_valid_token(self):
        if not self.bearer_token:
            self.logger.error("No bearer token available")
            raise RIAAuthenticationError("No bearer token available")
        if self.token_expiry and time.time() > (self.token_expiry - 60):
            self.logger.debug("Token expired or about to expire; refreshing session")
            self.get_session_info()
    def calculate_rate(self, send_amount: float, send_currency: str, receive_country: str,
                      payment_method: str = "DebitCard", delivery_method: str = "BankDeposit",
                      send_country: str = "US") -> dict:
        try:
            self._ensure_valid_token()
            payload = {
                "selections": {
                    "countryTo": receive_country.upper(),
                    "amountFrom": float(send_amount),
                    "amountTo": None,
                    "currencyFrom": send_currency.upper(),
                    "currencyTo": None,
                    "paymentMethod": payment_method,
                    "deliveryMethod": delivery_method,
                    "shouldCalcAmountFrom": False,
                    "shouldCalcVariableRates": True,
                    "state": None,
                    "agentToId": None,
                    "stateTo": None,
                    "agentToLocationId": None,
                    "promoCode": None,
                    "promoId": 0,
                    "transferReason": None,
                    "countryFrom": send_country.upper()
                }
            }
            full_response = self._do_calculate(payload, return_full=True)
            if full_response is None:
                return None
            if self.debug_mode:
                self.logger.debug(f"Full calculate response: {json.dumps(full_response, indent=2)}")
            if "errorResponse" in full_response and full_response["errorResponse"]:
                if full_response["errorResponse"].get("errors") and len(full_response["errorResponse"]["errors"]) > 0:
                    self.logger.warning(f"Error in calculate response: {full_response['errorResponse']}")
                    return None
                else:
                    self.logger.debug("Empty error response received, continuing processing")
            model_calcs = {}
            direct_calcs = {}
            if "model" in full_response:
                model = full_response["model"]
                if "calculations" in model:
                    model_calcs = model["calculations"]
                elif "transferDetails" in model and "calculations" in model["transferDetails"]:
                    model_calcs = model["transferDetails"]["calculations"]
            if "calculations" in full_response:
                direct_calcs = full_response["calculations"]
            calculations = model_calcs if model_calcs.get("exchangeRate") is not None else direct_calcs
            if calculations.get("exchangeRate") is None:
                self.logger.debug("No exchange rate found in standard locations, checking alternative paths")
                if "model" in full_response and "transferOptions" in full_response["model"]:
                    for option in full_response["model"]["transferOptions"]:
                        if "exchangeRate" in option:
                            calculations["exchangeRate"] = option["exchangeRate"]
                            break
            result = {
                "provider": "RIA",
                "timestamp": datetime.now().isoformat(),
                "send_amount": send_amount,
                "send_currency": send_currency.upper(),
                "receive_country": receive_country.upper(),
                "exchange_rate": calculations.get("exchangeRate"),
                "transfer_fee": calculations.get("transferFee"),
                "receive_amount": calculations.get("amountTo"),
                "payment_method": payment_method,
                "delivery_method": delivery_method,
                "payment_type": payment_method,  # For compatibility with tests
                "delivery_time": "24-48 hours",  # For compatibility with tests
                "total_fee": calculations.get("totalFeesAndTaxes", 0),
                "promo_discount": calculations.get("promoAmount", 0),
                "currency_to": calculations.get("currencyTo"),
                "status_message": full_response.get("statusMessage"),
                "raw_response": full_response if self.debug_mode else None
            }
            return result
        except RIAAuthenticationError:
            raise
        except (requests.RequestException, ValueError, KeyError) as e:
            self.logger.error(f"Calculation failed: {str(e)}", exc_info=True)
            return None
    def _do_calculate(self, payload: dict, return_full: bool = True) -> dict:
        correlation_id = str(uuid.uuid4())
        try:
            retries = 3
            backoff_factor = 0.5
            for attempt in range(retries):
                try:
                    response = self._session.post(
                        f"{self.BASE_URL}/MoneyTransferCalculator/Calculate",
                        json=payload,
                        headers={
                            'CorrelationId': correlation_id
                        },
                        timeout=self.timeout
                    )
                    self.logger.debug(f"HTTP Response Status: {response.status_code}")
                    if response.status_code == 200:
                        break
                    if response.status_code < 500:
                        break
                    self.logger.warning(f"Received {response.status_code} from RIA API, retrying (attempt {attempt+1}/{retries})")
                    time.sleep(backoff_factor * (2 ** attempt))
                except (requests.ConnectionError, requests.Timeout) as e:
                    if attempt < retries - 1:
                        self.logger.warning(f"Connection error: {str(e)}, retrying (attempt {attempt+1}/{retries})")
                        time.sleep(backoff_factor * (2 ** attempt))
                    else:
                        raise
            if response.status_code != 200:
                self.logger.error(f"Failed API call: status={response.status_code}, body={response.text[:1000]}")
                return None
            self.logger.debug(f"HTTP Response Headers: {dict(response.headers)}")
            if 'bearer' in response.headers:
                new_token = response.headers['bearer']
                if new_token != self.bearer_token:
                    self.bearer_token = new_token
                    self._session.headers['Authorization'] = f'Bearer {new_token}'
                    self.logger.debug("Updated bearer token from calculate response")
            if 'Session-Analytics' in response.headers:
                self.logger.debug(f"Session Analytics: {response.headers['Session-Analytics']}")
            try:
                result = response.json()
            except json.JSONDecodeError as e:
                self.logger.error(f"Failed to parse JSON response: {str(e)}")
                self.logger.error(f"Response body: {response.text[:1000]}")
                return None
            if return_full:
                return result
            else:
                model_calcs = {}
                direct_calcs = {}
                if "model" in result:
                    model = result["model"]
                    if "calculations" in model:
                        model_calcs = model["calculations"]
                    elif "transferDetails" in model and "calculations" in model["transferDetails"]:
                        model_calcs = model["transferDetails"]["calculations"]
                if "calculations" in result:
                    direct_calcs = result["calculations"]
                if model_calcs.get("exchangeRate") is not None:
                    return model_calcs
                else:
                    return direct_calcs
        except requests.RequestException as e:
            self.logger.error(f"Calculate request failed: {str(e)}", exc_info=True)
            if hasattr(e, 'response') and e.response is not None:
                self.logger.error(f"Response status: {e.response.status_code}")
                self.logger.error(f"Response body: {e.response.text[:1000]}")
            return None
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self._session.close()
###END

__version__ = "0.1.0"
###END

import json
import logging
from decimal import Decimal
from typing import Dict, List, Any, Optional
from pathlib import Path
import os
import random
import requests
from bs4 import BeautifulSoup
from apps.providers.base.provider import RemittanceProvider
from apps.providers.remitbee.exceptions import (
    RemitbeeError,
    RemitbeeConnectionError,
    RemitbeeApiError,
    RemitbeeValidationError
)
logger = logging.getLogger(__name__)
class RemitbeeProvider(RemittanceProvider):
    BASE_URL = "https://api.remitbee.com"
    QUOTE_ENDPOINT = "/public-services/calculate-money-transfer"
    COUNTRIES_DATA_FILE = "countries_data.json"
    USER_AGENTS = [
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0"
    ]
    def __init__(self, countries_html_file: Optional[str] = None):
        super().__init__(name="Remitbee", base_url=self.BASE_URL)
        self.country_data = {}
        if countries_html_file and os.path.exists(countries_html_file):
            self.country_data = self._load_from_html(countries_html_file)
            self._save_country_data()
        else:
            self._load_country_data()
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': random.choice(self.USER_AGENTS)
        })
    def _load_from_html(self, html_file: str) -> Dict[str, Dict]:
        logger.info(f"Parsing Remitbee HTML from: {html_file}")
        country_data = {}
        try:
            with open(html_file, "r", encoding="utf-8") as f:
                html = f.read()
            soup = BeautifulSoup(html, "html.parser")
            li_tags = soup.find_all("li", attrs={"data-item": True})
            for li in li_tags:
                data_item_str = li["data-item"]  # raw JSON in attribute
                try:
                    item_json = json.loads(data_item_str)
                except json.JSONDecodeError:
                    continue  # skip if invalid
                country_id = item_json.get("country_id")
                country_name = item_json.get("country_to")
                currency_name = item_json.get("currency_name")
                currency_code = item_json.get("currency_code")
                rate = item_json.get("rate")
                iso2 = item_json.get("iso2")
                iso3 = item_json.get("iso3")
                special_rate = item_json.get("special_rate")
                if not (country_id and iso2 and currency_code):
                    continue  # Skip entries missing required fields
                country_data[iso2] = {
                    "country_id": country_id,
                    "country_name": country_name,
                    "currency_name": currency_name,
                    "currency_code": currency_code,
                    "rate": rate,
                    "iso2": iso2,
                    "iso3": iso3,
                    "special_rate": special_rate
                }
            logger.info(f"Extracted {len(country_data)} countries from Remitbee HTML")
        except Exception as e:
            logger.error(f"Error parsing Remitbee HTML: {str(e)}")
            raise RemitbeeError(f"Failed to parse Remitbee HTML: {str(e)}")
        return country_data
    def _save_country_data(self):
        try:
            data_file = Path(__file__).parent / self.COUNTRIES_DATA_FILE
            with open(data_file, "w", encoding="utf-8") as f:
                json.dump(self.country_data, f, indent=2)
            logger.info(f"Saved Remitbee country data to {data_file}")
        except Exception as e:
            logger.warning(f"Could not save Remitbee country data: {str(e)}")
    def _load_country_data(self):
        try:
            data_file = Path(__file__).parent / self.COUNTRIES_DATA_FILE
            if data_file.exists():
                with open(data_file, "r", encoding="utf-8") as f:
                    self.country_data = json.load(f)
                logger.info(f"Loaded {len(self.country_data)} Remitbee countries from {data_file}")
            else:
                logger.warning(f"Remitbee country data file {data_file} not found")
        except Exception as e:
            logger.warning(f"Could not load Remitbee country data: {str(e)}")
    def get_quote(
        self, 
        country_id: int,
        currency_code: str,
        amount: Decimal,
        is_special_rate: bool = False,
        include_timeline: bool = True
    ) -> Dict[str, Any]:
        url = f"{self.BASE_URL}{self.QUOTE_ENDPOINT}"
        headers = {
            "Content-Type": "application/json",
            "Accept": "application/json, text/plain, */*",
            "Origin": "https://www.remitbee.com",
            "Referer": "https://www.remitbee.com/send-money",
            "Sec-Fetch-Site": "same-site",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Dest": "empty",
            "Accept-Language": "en-US,en;q=0.9",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
            "X-Requested-With": "XMLHttpRequest"
        }
        payload = {
            "transfer_amount": f"{amount:.2f}",
            "country_id": country_id,
            "currency_code": currency_code,
            "include_timeline": include_timeline,
            "is_special_rate": is_special_rate,
            "source_currency": "CAD",
            "source_country": "CA"
        }
        logger.debug(f"Requesting Remitbee quote: {payload}")
        try:
            self.session.get("https://www.remitbee.com/", timeout=20)
            response = self.session.post(url, headers=headers, json=payload, timeout=20)
            logger.debug(f"Response status: {response.status_code}")
            logger.debug(f"Response headers: {dict(response.headers)}")
            if response.status_code == 403:
                logger.warning("Received 403 Forbidden from Remitbee API. The API may require additional authentication.")
                try:
                    error_content = response.text
                    logger.debug(f"403 Response content: {error_content}")
                except:
                    pass
                raise RemitbeeApiError("Access forbidden by Remitbee API. The API may require browser authentication.")
            response.raise_for_status()  # Raise for other 4XX/5XX status codes
            try:
                data = response.json()
                logger.debug(f"Remitbee quote response: {json.dumps(data, indent=2)}")
                return data
            except json.JSONDecodeError:
                logger.error(f"Response was not valid JSON: {response.text[:200]}...")
                raise RemitbeeApiError(f"Invalid JSON response from Remitbee API")
        except requests.exceptions.ConnectionError as e:
            logger.error(f"Connection error while getting Remitbee quote: {str(e)}")
            raise RemitbeeConnectionError(f"Failed to connect to Remitbee API: {str(e)}")
        except requests.exceptions.Timeout as e:
            logger.error(f"Timeout while getting Remitbee quote: {str(e)}")
            raise RemitbeeConnectionError(f"Remitbee API request timed out: {str(e)}")
        except requests.exceptions.HTTPError as e:
            logger.error(f"HTTP error while getting Remitbee quote: {str(e)}")
            raise RemitbeeApiError(f"Remitbee API returned error: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error while getting Remitbee quote: {str(e)}")
            raise RemitbeeError(f"Error getting Remitbee quote: {str(e)}")
    def get_exchange_rate(
        self, 
        send_amount: Decimal, 
        send_currency: str, 
        receive_country: str
    ) -> Optional[Dict]:
        if not isinstance(send_amount, Decimal):
            raise RemitbeeValidationError("send_amount must be a Decimal")
        if send_currency != "CAD":
            logger.warning(f"Remitbee primarily supports CAD as source currency, not {send_currency}")
        receive_country = receive_country.upper()
        country_data = self.country_data.get(receive_country)
        if not country_data:
            logger.error(f"Country code {receive_country} not found in Remitbee data")
            return None
        country_id = country_data["country_id"]
        currency_code = country_data["currency_code"]
        try:
            quote_data = self.get_quote(
                country_id=country_id,
                currency_code=currency_code,
                amount=send_amount,
                is_special_rate=False  # Set to True if you want to use special rates
            )
            if "message" in quote_data and "unable to find" in quote_data["message"].lower():
                logger.warning(f"Remitbee does not support this corridor: {quote_data['message']}")
                return {
                    "provider": self.name,
                    "send_amount": float(send_amount),
                    "send_currency": send_currency,
                    "receive_currency": currency_code,
                    "receive_country": receive_country,
                    "receive_country_name": country_data["country_name"],
                    "error": quote_data["message"],
                    "supported": False,
                    "raw_json": quote_data
                }
            fee = "0.00"
            delivery_hours = 0
            if "payment_types" in quote_data and quote_data["payment_types"]:
                payment_type = quote_data["payment_types"][0]  # Default to first payment type
                fee = payment_type.get("fees", "0.00")
                if "timeline" in payment_type and "settlement_timeline" in payment_type["timeline"]:
                    delivery_hours = payment_type["timeline"]["settlement_timeline"].get("predicted_minutes", 0) / 60
            receive_amount_str = quote_data.get("receiving_amount", "0.00").replace(",", "")
            result = {
                "provider": self.name,
                "send_amount": float(send_amount),
                "send_currency": send_currency,
                "receive_currency": currency_code,
                "receive_country": receive_country,
                "receive_country_name": country_data["country_name"],
                "exchange_rate": quote_data.get("rate"),
                "receive_amount": float(receive_amount_str) if receive_amount_str else None,
                "fee": float(fee) if fee else 0.0,
                "delivery_time": delivery_hours,
                "supported": True,
                "raw_json": quote_data
            }
            return result
        except Exception as e:
            logger.error(f"Error getting Remitbee exchange rate: {str(e)}")
            return None
    def get_supported_countries(self) -> List[Dict]:
        return list(self.country_data.values()) 
###END

###FILE:./apps/providers/forms.py
from django import forms
from decimal import Decimal
class SendMoneyForm(forms.Form):
    send_amount = forms.DecimalField(
        min_value=Decimal('1.00'),
        max_value=Decimal('5000.00'),
        decimal_places=2,
        required=True,
        label="Amount to Send"
    )
    CURRENCY_CHOICES = [
        ('USD', 'US Dollar'),
        ('GBP', 'British Pound'),
        ('EUR', 'Euro'),
        ('CAD', 'Canadian Dollar'),
        ('AUD', 'Australian Dollar'),
        ('SGD', 'Singapore Dollar'),
        ('JPY', 'Japanese Yen'),
        ('INR', 'Indian Rupee'),
        ('EGP', 'Egyptian Pound'),
        ('MXN', 'Mexican Peso'),
        ('NZD', 'New Zealand Dollar'),
    ]
    send_currency = forms.ChoiceField(
        choices=CURRENCY_CHOICES,
        required=True,
        label="Currency Code"
    )
    COUNTRY_CHOICES = [
        ('US', 'United States'),
        ('GB', 'United Kingdom'),
        ('DE', 'Germany'),
        ('FR', 'France'),
        ('IT', 'Italy'),
        ('EG', 'Egypt'),
        ('MX', 'Mexico'),
        ('IN', 'India'),
        ('PH', 'Philippines'),
        ('TR', 'Turkey'),
        ('NG', 'Nigeria'),
    ]
    receive_country = forms.ChoiceField(
        choices=COUNTRY_CHOICES,
        required=True,
        label="Destination Country"
    )
    send_country = forms.ChoiceField(
        choices=COUNTRY_CHOICES,
        required=True,
        label="Origin Country"
    )
    sender_postal_code = forms.CharField(
        max_length=10,
        required=False,
        label="Sender Postal Code"
    )
    sender_city = forms.CharField(
        max_length=50,
        required=False,
        label="Sender City"
    )
    sender_state = forms.CharField(
        max_length=50,
        required=False,
        label="Sender State/Province"
    )
    def clean(self):
        cleaned_data = super().clean()
        send_country = cleaned_data.get('send_country')
        receive_country = cleaned_data.get('receive_country')
        if send_country and receive_country:
            if send_country == receive_country:
                raise forms.ValidationError(
                    "Send and receive countries must be different"
                )
        return cleaned_data 
###END

from .integration import OrbitRemitProvider
from .exceptions import (
    OrbitRemitError,
    OrbitRemitConnectionError,
    OrbitRemitApiError,
    OrbitRemitResponseError,
    OrbitRemitCorridorUnsupportedError,
)
__all__ = [
    'OrbitRemitProvider',
    'OrbitRemitError',
    'OrbitRemitConnectionError',
    'OrbitRemitApiError',
    'OrbitRemitResponseError',
    'OrbitRemitCorridorUnsupportedError',
] 
###END

import logging
import requests
from decimal import Decimal
from typing import Any, Dict, Optional, List
from datetime import datetime
from apps.providers.base.provider import RemittanceProvider
from .exceptions import (
    OrbitRemitError,
    OrbitRemitConnectionError,
    OrbitRemitApiError,
    OrbitRemitResponseError,
    OrbitRemitCorridorUnsupportedError,
)
logger = logging.getLogger("providers.orbitremit")
class OrbitRemitProvider(RemittanceProvider):
    BASE_URL = "https://www.orbitremit.com"
    FEES_ENDPOINT = "/api/fees"
    SUPPORTED_SOURCE_CURRENCIES = ["AUD", "NZD", "GBP", "EUR", "CAD", "USD"]
    SUPPORTED_CORRIDORS = {
        "AUD": ["PHP", "INR", "PKR", "BDT", "FJD", "LKR", "NPR", "USD", "VND"],
        "NZD": ["PHP", "INR", "FJD", "PKR", "BDT", "LKR", "NPR", "VND"],
        "GBP": ["PHP", "INR", "PKR", "BDT", "LKR", "NPR", "VND"],
        "EUR": ["PHP", "INR", "PKR", "BDT", "LKR", "NPR", "VND"],
        "CAD": ["PHP", "INR", "PKR", "BDT", "LKR", "NPR", "VND"],
        "USD": ["PHP", "INR", "PKR", "BDT", "LKR", "NPR", "VND"],
    }
    COUNTRY_TO_CURRENCY = {
        "PH": "PHP",  # Philippines
        "IN": "INR",  # India
        "FJ": "FJD",  # Fiji
        "PK": "PKR",  # Pakistan
        "BD": "BDT",  # Bangladesh
        "LK": "LKR",  # Sri Lanka
        "NP": "NPR",  # Nepal
        "VN": "VND",  # Vietnam
        "US": "USD",  # United States
    }
    EXCHANGE_RATES = {
        "AUD": {
            "PHP": Decimal("35.50"),    # 1 AUD = 35.50 PHP
            "INR": Decimal("55.20"),    # 1 AUD = 55.20 INR
            "PKR": Decimal("217.40"),   # 1 AUD = 217.40 PKR
            "BDT": Decimal("75.30"),    # 1 AUD = 75.30 BDT
            "FJD": Decimal("1.50"),     # 1 AUD = 1.50 FJD
            "LKR": Decimal("215.75"),   # 1 AUD = 215.75 LKR
            "NPR": Decimal("89.15"),    # 1 AUD = 89.15 NPR
            "USD": Decimal("0.66"),     # 1 AUD = 0.66 USD
            "VND": Decimal("16250.00"), # 1 AUD = 16250.00 VND
        },
        "NZD": {
            "PHP": Decimal("33.20"),    # 1 NZD = 33.20 PHP
            "INR": Decimal("51.75"),    # 1 NZD = 51.75 INR
            "PKR": Decimal("203.50"),   # 1 NZD = 203.50 PKR
            "BDT": Decimal("70.40"),    # 1 NZD = 70.40 BDT
            "FJD": Decimal("1.40"),     # 1 NZD = 1.40 FJD
            "LKR": Decimal("201.80"),   # 1 NZD = 201.80 LKR
            "NPR": Decimal("83.45"),    # 1 NZD = 83.45 NPR
            "VND": Decimal("15200.00"), # 1 NZD = 15200.00 VND
        },
        "GBP": {
            "PHP": Decimal("67.80"),    # 1 GBP = 67.80 PHP
            "INR": Decimal("105.60"),   # 1 GBP = 105.60 INR
            "PKR": Decimal("415.25"),   # 1 GBP = 415.25 PKR
            "BDT": Decimal("143.70"),   # 1 GBP = 143.70 BDT
            "LKR": Decimal("411.90"),   # 1 GBP = 411.90 LKR
            "NPR": Decimal("170.30"),   # 1 GBP = 170.30 NPR
            "VND": Decimal("31000.00"), # 1 GBP = 31000.00 VND
        },
        "EUR": {
            "PHP": Decimal("59.40"),    # 1 EUR = 59.40 PHP
            "INR": Decimal("92.50"),    # 1 EUR = 92.50 INR
            "PKR": Decimal("363.80"),   # 1 EUR = 363.80 PKR
            "BDT": Decimal("125.95"),   # 1 EUR = 125.95 BDT
            "LKR": Decimal("360.90"),   # 1 EUR = 360.90 LKR
            "NPR": Decimal("149.25"),   # 1 EUR = 149.25 NPR
            "VND": Decimal("27150.00"), # 1 EUR = 27150.00 VND
        },
        "CAD": {
            "PHP": Decimal("39.65"),    # 1 CAD = 39.65 PHP
            "INR": Decimal("61.75"),    # 1 CAD = 61.75 INR
            "PKR": Decimal("242.85"),   # 1 CAD = 242.85 PKR
            "BDT": Decimal("84.10"),    # 1 CAD = 84.10 BDT
            "LKR": Decimal("241.00"),   # 1 CAD = 241.00 LKR
            "NPR": Decimal("99.65"),    # 1 CAD = 99.65 NPR
            "VND": Decimal("18130.00"), # 1 CAD = 18130.00 VND
        },
        "USD": {
            "PHP": Decimal("53.90"),    # 1 USD = 53.90 PHP
            "INR": Decimal("83.95"),    # 1 USD = 83.95 INR
            "PKR": Decimal("330.15"),   # 1 USD = 330.15 PKR
            "BDT": Decimal("114.25"),   # 1 USD = 114.25 BDT
            "LKR": Decimal("327.60"),   # 1 USD = 327.60 LKR
            "NPR": Decimal("135.55"),   # 1 USD = 135.55 NPR
            "VND": Decimal("24650.00"), # 1 USD = 24650.00 VND
        }
    }
    RATES_LAST_UPDATED = datetime(2023, 3, 2)
    def __init__(self, name="orbitremit", **kwargs):
        super().__init__(name=name, base_url=self.BASE_URL, **kwargs)
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": ("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                           "AppleWebKit/605.1.15 (KHTML, like Gecko) "
                           "Version/18.3 Safari/605.1.15"),
            "Accept": "*/*",
            "Content-Type": "application/json",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
        })
    def get_exchange_rate(
        self, 
        send_amount: Decimal, 
        send_currency: str, 
        receive_country: str
    ) -> Optional[Dict]:
        if receive_country.upper() in self.COUNTRY_TO_CURRENCY:
            payout_currency = self.COUNTRY_TO_CURRENCY[receive_country.upper()]
        else:
            logger.warning(f"Unknown country code: {receive_country}, cannot determine currency")
            return None
        fee_info = self.get_fee_info(
            send_currency=send_currency,
            payout_currency=payout_currency,
            send_amount=send_amount,
        )
        exchange_rate = self._get_exchange_rate(send_currency.upper(), payout_currency)
        target_amount = None
        if exchange_rate:
            fee = Decimal(str(fee_info.get("fee", 0)))
            adjusted_send_amount = send_amount - fee
            target_amount = adjusted_send_amount * exchange_rate
        if fee_info["success"]:
            return {
                "provider": self.name,
                "source_amount": float(send_amount),
                "source_currency": send_currency.upper(),
                "target_currency": payout_currency,
                "fee": fee_info.get("fee", 0),
                "rate": float(exchange_rate) if exchange_rate else None,
                "target_amount": float(target_amount) if target_amount else None,
                "corridor": f"{send_currency.upper()}-{payout_currency}",
                "success": True,
                "rate_source": "OrbitRemit estimated rates",
                "rate_timestamp": self.RATES_LAST_UPDATED.isoformat(),
            }
        else:
            return {
                "provider": self.name,
                "success": False,
                "error_message": fee_info.get("error_message", "Failed to get exchange rate information"),
            }
    def _get_exchange_rate(self, source_currency: str, target_currency: str) -> Optional[Decimal]:
        source_currency = source_currency.upper()
        target_currency = target_currency.upper()
        if source_currency in self.EXCHANGE_RATES:
            if target_currency in self.EXCHANGE_RATES[source_currency]:
                return self.EXCHANGE_RATES[source_currency][target_currency]
        logger.warning(f"No exchange rate found for {source_currency} to {target_currency}")
        return None
    def get_fee_info(
        self,
        send_currency: str,
        payout_currency: str,
        send_amount: Decimal,
        recipient_type: str = "bank_account",
        **kwargs
    ) -> Dict[str, Any]:
        send_currency = send_currency.upper()
        payout_currency = payout_currency.upper()
        result = {
            "provider": self.name,
            "success": False,
            "send_currency": send_currency,
            "payout_currency": payout_currency,
            "send_amount": float(send_amount),
            "recipient_type": recipient_type,
            "fee": None,
            "raw_data": None,
            "error_message": None,
        }
        if not send_amount or send_amount <= 0:
            result["error_message"] = "Amount must be positive"
            return result
        if not send_currency:
            result["error_message"] = "Send currency cannot be empty"
            return result
        if not payout_currency:
            result["error_message"] = "Payout currency cannot be empty"
            return result
        if send_currency not in self.SUPPORTED_SOURCE_CURRENCIES:
            result["error_message"] = f"Invalid source currency. Supported currencies: {', '.join(self.SUPPORTED_SOURCE_CURRENCIES)}"
            return result
        if send_currency in self.SUPPORTED_CORRIDORS:
            if payout_currency not in self.SUPPORTED_CORRIDORS[send_currency]:
                result["error_message"] = f"Unsupported corridor: {send_currency} to {payout_currency}"
                return result
        else:
            result["error_message"] = f"Source currency {send_currency} is not supported"
            return result
        endpoint_url = self.base_url + self.FEES_ENDPOINT
        send_amount_str = f"{send_amount:.2f}"
        params = {
            "send": send_currency,       # e.g. 'AUD'
            "payout": payout_currency,   # e.g. 'PHP'
            "amount": send_amount_str,   # e.g. '200000'
            "type": recipient_type,      # e.g. 'bank_account'
        }
        logger.debug(f"OrbitRemit GET: {endpoint_url} params={params}")
        try:
            resp = self.session.get(endpoint_url, params=params, timeout=15)
            resp.raise_for_status()
            data = resp.json()
            result["raw_data"] = data
            logger.debug(f"OrbitRemit response: {data}")
            if data.get("status") == "success" and isinstance(data.get("data"), dict):
                fee_data = data["data"]
                fee_str = fee_data.get("fee", "0.00")
                fee_val = float(fee_str)
                result.update({
                    "success": True,
                    "fee": fee_val,
                })
            else:
                msg = f"OrbitRemit returned unexpected response: {data}"
                logger.error(msg)
                result["error_message"] = msg
        except requests.exceptions.JSONDecodeError as e:
            error_msg = f"Failed to parse OrbitRemit response as JSON: {e}"
            logger.error(error_msg)
            result["error_message"] = error_msg
            raise OrbitRemitResponseError(error_msg) from e
        except requests.exceptions.ConnectionError as e:
            error_msg = f"Connection error when accessing OrbitRemit API: {e}"
            logger.error(error_msg)
            result["error_message"] = error_msg
            raise OrbitRemitConnectionError(error_msg) from e
        except requests.exceptions.RequestException as e:
            error_msg = f"OrbitRemit request failed: {e}"
            logger.error(error_msg)
            result["error_message"] = error_msg
            raise OrbitRemitApiError(error_msg) from e
        return result
    def get_quote(
        self,
        amount: Decimal,
        source_currency: str,
        target_currency: str,
        **kwargs
    ) -> Dict[str, Any]:
        source_currency = source_currency.upper()
        target_currency = target_currency.upper()
        result = {
            "provider": self.name,
            "success": False,
            "source_amount": float(amount),
            "target_amount": None,
            "fee": None,
            "rate": None,
            "source_currency": source_currency,
            "target_currency": target_currency,
            "error_message": None,
        }
        fee_info = self.get_fee_info(
            send_currency=source_currency,
            payout_currency=target_currency,
            send_amount=amount,
            **kwargs
        )
        result["success"] = fee_info["success"]
        result["fee"] = fee_info.get("fee")
        result["error_message"] = fee_info.get("error_message")
        if result["success"]:
            exchange_rate = self._get_exchange_rate(source_currency, target_currency)
            if exchange_rate:
                result["rate"] = float(exchange_rate)
                fee = Decimal(str(result["fee"] or 0))
                adjusted_amount = amount - fee
                target_amount = adjusted_amount * exchange_rate
                result["target_amount"] = float(target_amount)
                result["rate_source"] = "OrbitRemit estimated rates"
                result["rate_timestamp"] = self.RATES_LAST_UPDATED.isoformat()
            else:
                result["error_message"] = f"Exchange rate not available for {source_currency} to {target_currency}"
        return result 
###END

from .integration import WireBarleyProvider
__all__ = ["WireBarleyProvider"] 
###END

import logging
import requests
from decimal import Decimal
from typing import Any, Dict, List, Optional
from datetime import datetime
import uuid
import time
import json
import os
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import traceback
from apps.providers.base.provider import RemittanceProvider
logger = logging.getLogger(__name__)
class WireBarleyProvider(RemittanceProvider):
    BASE_URL = "https://www.wirebarley.com"
    CURRENCY_TO_COUNTRY = {
        "USD": "US",  # United States Dollar
        "NZD": "NZ",  # New Zealand Dollar
        "GBP": "GB",  # British Pound
        "AUD": "AU",  # Australian Dollar
        "EUR": "EU",  # Euro
        "CAD": "CA",  # Canadian Dollar
        "SGD": "SG",  # Singapore Dollar
        "HKD": "HK",  # Hong Kong Dollar
        "JPY": "JP",  # Japanese Yen
        "CNY": "CN",  # Chinese Yuan
        "LKR": "LK",  # Sri Lanka Rupee
        "ILS": "IL",  # Israeli New Shekel
        "PHP": "PH",  # Philippine Peso
        "MYR": "MY",  # Malaysian Ringgit
        "UZS": "UZ",  # Uzbekistan Sum
        "THB": "TH",  # Thai Baht
        "ZAR": "ZA",  # South African Rand
        "TRY": "TR",  # Turkish Lira
        "KRW": "KR",  # South Korean Won
        "IDR": "ID",  # Indonesian Rupiah
        "VND": "VN",  # Vietnamese Dong
        "RUB": "RU",  # Russian Ruble
        "NPR": "NP",  # Nepalese Rupee
        "INR": "IN",  # Indian Rupee
        "CHF": "CH",  # Swiss Franc
        "BDT": "BD",  # Bangladeshi Taka
        "TWD": "TW",  # Taiwan New Dollar
        "BHD": "BH",  # Bahraini Dinar
        "AED": "AE",  # United Arab Emirates Dirham
        "OMR": "OM",  # Omani Rial
        "SAR": "SA",  # Saudi Arabian Riyal
        "QAR": "QA",  # Qatari Riyal
        "PKR": "PK",  # Pakistani Rupee
    }
    def __init__(self, config=None):
        super().__init__(name="wirebarley", base_url=self.BASE_URL)
        self.config = config or {}
        self.logger = logging.getLogger(__name__)
        self.session = None
        self.browser_data = None
        self.session_timestamp = None
        self.session_valid_duration = 3600  # 1 hour in seconds
        self._corridors_cache = {}
        self._cache_timestamp = {}
        self._cache_duration = 3600
        self._current_source_currency = "USD"
        self._initialize_session()
    def _get_browser_cookies(self):
        cookies_str = os.getenv('WIREBARLEY_COOKIES')
        if cookies_str:
            try:
                cookies_dict = json.loads(cookies_str)
                self.logger.info("Using cookies from environment variable")
                return cookies_dict
            except json.JSONDecodeError as e:
                self.logger.error(f"Failed to parse WIREBARLEY_COOKIES: {e}")
        self.logger.info("No cookies found in environment, falling back to Selenium")
        return self._get_selenium_cookies()
    def _get_selenium_cookies(self):
        options = webdriver.ChromeOptions()
        options.add_argument('--headless')
        options.add_argument('--window-size=1920,1080')
        options.add_argument(f'--user-agent={os.getenv("WIREBARLEY_USER_AGENT", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36")}')
        driver = None
        try:
            driver = webdriver.Chrome(options=options)
            wait = WebDriverWait(driver, 20)
            driver.get('https://my.wirebarley.com/login')
            time.sleep(5)  # Wait for page to load
            try:
                email_field = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, 'input[type="email"]')))
                password_field = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, 'input[type="password"]')))
                email = os.getenv('WIREBARLEY_EMAIL')
                password = os.getenv('WIREBARLEY_PASSWORD')
                if not email or not password:
                    raise ValueError("WIREBARLEY_EMAIL and WIREBARLEY_PASSWORD environment variables are required for Selenium automation")
                email_field.send_keys(email)
                password_field.send_keys(password)
                login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'button[type="submit"]')))
                login_button.click()
                time.sleep(5)
                driver.get('https://my.wirebarley.com/remittance')
                time.sleep(5)
                cookies = driver.get_cookies()
                cookie_dict = {}
                for cookie in cookies:
                    cookie_dict[cookie['name']] = cookie['value']
                return cookie_dict
            except (TimeoutException, NoSuchElementException) as e:
                self.logger.warning(f"Login attempt failed: {str(e)}\nStacktrace:\n{traceback.format_exc()}")
                return {}
        except Exception as e:
            self.logger.error(f"Browser automation failed: {str(e)}\nStacktrace:\n{traceback.format_exc()}")
            return {}
        finally:
            if driver:
                try:
                    driver.quit()
                except:
                    pass
    def _initialize_session(self):
        try:
            browser_data = self._get_browser_cookies()
            if not browser_data:
                raise Exception("Failed to get browser session data")
            self.session = requests.Session()
            user_agent = os.getenv('WIREBARLEY_USER_AGENT', 
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36')
            self.session.headers.update({
                'User-Agent': user_agent,
                'Accept': 'application/json, text/plain, */*',
                'Accept-Language': 'en-US,en;q=0.9',
                'Origin': 'https://my.wirebarley.com',
                'Referer': 'https://my.wirebarley.com/'
            })
            for name, value in browser_data.items():
                self.session.cookies.set(name, value, domain='.wirebarley.com')
            self.session_timestamp = time.time()
            self._validate_session()
            return True
        except Exception as e:
            self.logger.error(f"Failed to initialize session: {str(e)}")
            return False
    def _init_api_session(self):
        try:
            response = self.session.get(
                f"{self.BASE_URL}/en",
                timeout=15
            )
            response.raise_for_status()
            csrf_token = None
            for cookie in response.cookies:
                if cookie.name == "XSRF-TOKEN":
                    csrf_token = cookie.value
                    break
            if csrf_token:
                self.session.headers["X-XSRF-TOKEN"] = csrf_token
            init_data = {
                "deviceType": "WEB",
                "lang": "en",
                "region": "US",
                "deviceId": self.device_id,
                "sessionId": self.session_id,
                "timestamp": str(int(time.time() * 1000))
            }
            init_response = self.session.post(
                f"{self.BASE_URL}/my/remittance/api/v1/init",
                json=init_data,
                timeout=15
            )
            init_response.raise_for_status()
            if os.getenv("WIREBARLEY_TOKEN"):
                user_response = self.session.get(
                    f"{self.BASE_URL}/my/remittance/api/v1/user/info",
                    timeout=15
                )
                if user_response.status_code == 200:
                    user_data = user_response.json()
                    if user_data.get("status") == 0:
                        logger.debug("Successfully retrieved user info")
            self._validate_session()
        except requests.exceptions.RequestException as e:
            logger.error(f"API session initialization failed: {e}")
            raise
    def _validate_session(self):
        try:
            headers = {
                "Request-Id": str(uuid.uuid4()),
                "Request-Time": str(int(time.time() * 1000))
            }
            response = self.session.get(
                f"{self.BASE_URL}/my/remittance/api/v1/exrate/US/USD",
                headers=headers,
                timeout=15
            )
            response.raise_for_status()
            data = response.json()
            if data.get("status") == 400:
                raise Exception(f"Session validation failed: {data.get('messageKey')}")
        except Exception as e:
            logger.error(f"Session validation failed: {e}")
            raise
    def _ensure_valid_session(self):
        current_time = time.time()
        if (self.session is None or 
            self.session_timestamp is None or
            (current_time - self.session_timestamp) > self.session_valid_duration):
            logger.debug("Session expired or invalid, reinitializing...")
            self._initialize_session()
    def fetch_raw_data(self, source_currency: str, target_currency: str, amount: Decimal) -> Dict[str, Any]:
        max_retries = 3
        base_delay = 1
        country_code = self.CURRENCY_TO_COUNTRY.get(source_currency)
        if not country_code:
            logger.warning(f"Unsupported source currency: {source_currency}")
            return None
        api_endpoint = f"{self.BASE_URL}/my/remittance/api/v1/exrate/{country_code}/{source_currency}"
        for attempt in range(max_retries):
            try:
                self._ensure_valid_session()
                headers = {
                    "Request-Id": str(uuid.uuid4()),
                    "Request-Time": str(int(time.time() * 1000))
                }
                response = self.session.get(
                    api_endpoint,
                    headers=headers,
                    timeout=15
                )
                if response.status_code == 200:
                    data = response.json()
                    if data.get("status") == 0 and data.get("data"):
                        return data
                    elif data.get("status") == 400:
                        if "SESSION_EXPIRED" in str(data.get("messageKey", "")):
                            logger.warning("Session expired, reinitializing...")
                            self._initialize_session()
                            continue
                        else:
                            logger.error(f"API error: {data.get('messageKey')}")
                elif response.status_code in (401, 403):
                    logger.warning("Authentication error, reinitializing session...")
                    self._initialize_session()
                    continue
                elif response.status_code == 429:
                    retry_after = int(response.headers.get("Retry-After", base_delay * (2 ** attempt)))
                    logger.warning(f"Rate limited, waiting {retry_after} seconds")
                    time.sleep(retry_after)
                    continue
                else:
                    logger.error(f"Unexpected status code: {response.status_code}")
            except requests.exceptions.RequestException as e:
                logger.error(f"Request failed: {e}")
            if attempt < max_retries - 1:
                delay = base_delay * (2 ** attempt)
                logger.debug(f"Retrying in {delay} seconds...")
                time.sleep(delay)
        logger.error(f"Failed to fetch data after {max_retries} attempts")
        return None
    def parse_exrates(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        results = []
        if data.get("status") != 0 or data.get("data") is None:
            logger.warning(f"WireBarley API returned non-success status: {data.get('status')}")
            return results
        exrates = data.get("data", {}).get("exRates", [])
        for ex in exrates:
            country = ex.get("country")
            currency = ex.get("currency")
            wb_rate = ex.get("wbRate")       # The "WireBarley" rate
            base_rate = ex.get("baseRate")   # Possibly the standard/base rate
            status = ex.get("status")
            payment_fees = ex.get("paymentFees", [])
            transfer_fees = ex.get("transferFees", [])
            unified_payment_fees = self._parse_fee_array(payment_fees)
            unified_transfer_fees = self._parse_fee_array(transfer_fees)
            wb_rate_data = ex.get("wbRateData", {})
            threshold_rates = self._parse_threshold_rates(wb_rate_data)
            corridor_info = {
                "country_code": country,   # e.g. "PH", "AU", ...
                "currency": currency,      # e.g. "PHP", "AUD", ...
                "wirebarley_rate": float(wb_rate) if wb_rate else None,
                "base_rate": float(base_rate) if base_rate else None,
                "status": status,          # "ACTIVE", etc.
                "payment_fees": unified_payment_fees,   # array/list of fee tiers
                "transfer_fees": unified_transfer_fees, # array/list of fee tiers
                "rate_thresholds": threshold_rates,      # list of threshold-based rates
            }
            results.append(corridor_info)
        return results
    def _parse_fee_array(self, fee_array: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        results = []
        for fee_item in fee_array:
            option = fee_item.get("option")  # e.g. "CREDIT_DEBIT_CARD" or "ACH_EXPRESS"
            country = fee_item.get("country")
            dest_currency = fee_item.get("dest")
            min_send = fee_item.get("min")
            max_send = fee_item.get("max")
            use_discount = fee_item.get("useDiscountFee")  # bool
            fee_tiers = []
            for i in range(1, 11):
                fee_key = f"fee{i}"
                thr_key = f"threshold{i}"
                fee_val = fee_item.get(fee_key)
                thr_val = fee_item.get(thr_key)
                if fee_val is not None:
                    fee_tiers.append({
                        "threshold": float(thr_val) if thr_val is not None else None,
                        "fee": float(fee_val),
                    })
            results.append({
                "option": option,
                "country": country,
                "dest_currency": dest_currency,
                "min_send": min_send,
                "max_send": max_send,
                "use_discount_fee": use_discount,
                "fee_tiers": fee_tiers,
            })
        return results
    def _parse_threshold_rates(self, wb_rate_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        thresholds = []
        base_threshold = wb_rate_data.get("threshold")
        base_rate = wb_rate_data.get("wbRate")
        if base_threshold is not None or base_rate is not None:
            thresholds.append({
                "threshold": float(base_threshold) if base_threshold is not None else None,
                "rate": float(base_rate) if base_rate is not None else None
            })
        for i in range(1, 10):
            thr_key = f"threshold{i}"
            rate_key = f"wbRate{i}"
            threshold = wb_rate_data.get(thr_key)
            rate = wb_rate_data.get(rate_key)
            if threshold is not None or rate is not None:
                thresholds.append({
                    "threshold": float(threshold) if threshold is not None else None,
                    "rate": float(rate) if rate is not None else None
                })
        thresholds = [t for t in thresholds if not (t["threshold"] is None and t["rate"] is None)]
        thresholds.sort(key=lambda x: float('inf') if x["threshold"] is None else x["threshold"])
        return thresholds
    def get_min_amount(self, ex_rate: Dict[str, Any]) -> float:
        payment_fees = ex_rate.get("payment_fees", [])
        if payment_fees:
            min_amounts = [fee.get("min_send", 10.0) for fee in payment_fees if fee.get("min_send") is not None]
            if min_amounts:
                return min(min_amounts)
        return 10.0
    def get_max_amount(self, ex_rate: Dict[str, Any]) -> float:
        payment_fees = ex_rate.get("payment_fees", [])
        if payment_fees:
            max_amounts = [fee.get("max_send", 3000.0) for fee in payment_fees if fee.get("max_send") is not None]
            if max_amounts:
                return max(max_amounts)
        return 3000.0
    def get_corridors(self, source_currency: str = "USD") -> Dict[str, Any]:
        logger.debug(f"Fetching corridors for {source_currency}")
        default_amount = Decimal("100")
        data = self.fetch_raw_data(source_currency, "USD", default_amount)
        if not data or "data" not in data or "exRates" not in data["data"]:
            logger.error(f"Failed to fetch corridors for {source_currency}")
            return {
                "success": False,
                "error": "Failed to fetch corridor data"
            }
        corridors = []
        for rate in data["data"]["exRates"]:
            corridor = {
                "source_currency": source_currency,
                "target_currency": rate.get("currency"),
                "country_code": rate.get("countryCode"),
                "min_amount": Decimal(str(rate.get("minAmount", "10"))),
                "max_amount": Decimal(str(rate.get("maxAmount", "10000"))),
                "exchange_rate": Decimal(str(rate.get("exchangeRate", "0"))),
                "fee": Decimal(str(rate.get("fee", "0")))
            }
            corridors.append(corridor)
        return {
            "success": True,
            "corridors": corridors
        }
    def get_exchange_rate(self, send_amount: Decimal, send_currency: str, receive_country: str) -> Dict[str, Any]:
        try:
            self._ensure_valid_session()
            if send_currency not in self.CURRENCY_TO_COUNTRY:
                logger.warning(f"Unsupported source currency: {send_currency}")
                return {
                    "success": False, 
                    "error": f"Source currency {send_currency} not supported"
                }
            if send_amount < Decimal("10") or send_amount > Decimal("10000"):
                logger.warning(f"Amount {send_amount} outside of supported range (10-10000)")
                return {
                    "success": False,
                    "error": f"Amount {send_amount} outside of supported range (10-10000)"
                }
            raw_data = self.fetch_raw_data(send_currency, receive_country, send_amount)
            if not raw_data or "data" not in raw_data:
                logger.error("Failed to fetch exchange rate data")
                return {
                    "success": False,
                    "error": "Failed to fetch exchange rate data"
                }
            ex_rates = raw_data.get("data", {}).get("exRates", [])
            matching_rate = None
            for rate in ex_rates:
                if rate.get("country") == receive_country:
                    matching_rate = rate
                    break
            if not matching_rate:
                logger.error(f"No exchange rate found for {receive_country}")
                return {
                    "success": False,
                    "error": f"No exchange rate found for {receive_country}"
                }
            rate_value = self._get_threshold_rate(matching_rate, send_amount)
            if rate_value is None:
                logger.error("Failed to determine exchange rate")
                return {
                    "success": False,
                    "error": "Failed to determine exchange rate"
                }
            fee = self._calculate_fee(send_amount, send_currency, matching_rate)
            target_amount = float(send_amount) * float(rate_value)
            return {
                "success": True,
                "source_amount": float(send_amount),
                "source_currency": send_currency,
                "target_amount": target_amount,
                "target_currency": matching_rate.get("currency"),
                "fee": fee,
                "rate": float(rate_value),
                "fee_currency": send_currency,
                "rate_source": "wirebarley",
                "rate_timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Error getting exchange rate: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    def _get_threshold_rate(self, rate_data: Dict[str, Any], amount: Decimal) -> Optional[float]:
        try:
            wb_rate_data = rate_data.get("wbRateData", {})
            if wb_rate_data:
                thresholds = []
                for i in range(1, 6):  # Usually up to 5 thresholds
                    thr_key = f"threshold{i}" if i > 1 else "threshold"
                    rate_key = f"wbRate{i}" if i > 1 else "wbRate"
                    if thr_key in wb_rate_data and rate_key in wb_rate_data:
                        thresholds.append({
                            "threshold": float(wb_rate_data[thr_key]),
                            "rate": float(wb_rate_data[rate_key])
                        })
                thresholds.sort(key=lambda x: x["threshold"])
                for t in thresholds:
                    if float(amount) <= t["threshold"]:
                        return t["rate"]
                if thresholds:
                    return thresholds[-1]["rate"]
            return float(rate_data.get("wbRate", rate_data.get("baseRate")))
        except Exception as e:
            logger.error(f"Error determining threshold rate: {e}")
            return None
    def _calculate_fee(self, amount: Decimal, currency: str, rate_data: Dict[str, Any]) -> float:
        try:
            default_fee = 4.99
            payment_fees = rate_data.get("paymentFees", [])
            transfer_fees = rate_data.get("transferFees", [])
            if not payment_fees and not transfer_fees:
                logger.debug(f"No fee structures found for {currency}, using default")
                return default_fee
            for fee_info in payment_fees:
                min_amount = float(fee_info.get("min", 0))
                max_amount = float(fee_info.get("max", float("inf")))
                if min_amount <= float(amount) <= max_amount:
                    use_discount = fee_info.get("useDiscountFee", False)
                    tiers = []
                    for i in range(1, 11):
                        threshold_key = f"threshold{i}"
                        fee_key = f"fee{i}"
                        discount_key = f"discountFee{i}"
                        threshold = fee_info.get(threshold_key)
                        fee = fee_info.get(fee_key)
                        discount_fee = fee_info.get(discount_key) if use_discount else None
                        if fee is not None:
                            tiers.append({
                                "threshold": float(threshold) if threshold is not None else float("inf"),
                                "fee": float(discount_fee if use_discount and discount_fee is not None else fee)
                            })
                    tiers.sort(key=lambda x: x["threshold"])
                    for tier in tiers:
                        if float(amount) <= tier["threshold"]:
                            return tier["fee"]
                    if tiers:
                        return tiers[-1]["fee"]
                    base_fee = fee_info.get("fee")
                    if base_fee is not None:
                        return float(base_fee)
            for fee_info in transfer_fees:
                min_amount = float(fee_info.get("min", 0))
                max_amount = float(fee_info.get("max", float("inf")))
                if min_amount <= float(amount) <= max_amount:
                    fee = fee_info.get("fee")
                    if fee is not None:
                        return float(fee)
            logger.debug(f"No matching fee tier found for {amount} {currency}, using default")
            return default_fee
        except Exception as e:
            logger.error(f"Error calculating fee: {e}")
            return default_fee
    def get_quote(self, send_amount, send_currency, receive_currency):
        country_code = self._get_country_from_currency(receive_currency)
        if not country_code:
            return {
                "success": False,
                "error": f"Unsupported target currency: {receive_currency}",
                "send_amount": send_amount,
                "send_currency": send_currency,
                "target_currency": receive_currency,
                "provider": "wirebarley"
            }
        exchange_rate_response = self.get_exchange_rate(send_amount, send_currency, country_code)
        if exchange_rate_response.get("success", False):
            return {
                "success": True,
                "send_amount": exchange_rate_response["source_amount"],
                "send_currency": exchange_rate_response["source_currency"],
                "receive_amount": exchange_rate_response["target_amount"],
                "receive_currency": exchange_rate_response["target_currency"],
                "fee": exchange_rate_response["fee"],
                "rate": exchange_rate_response["rate"],
                "provider": "wirebarley",
                "rate_source": exchange_rate_response.get("rate_source", "wirebarley"),
                "rate_timestamp": exchange_rate_response.get("rate_timestamp", datetime.now().isoformat())
            }
        else:
            error_message = exchange_rate_response.get("error", "Unknown error")
            if "API authentication required" in error_message:
                error_message = "API authentication required. Please provide valid API credentials."
            return {
                "success": False,
                "error": error_message,
                "send_amount": send_amount,
                "send_currency": send_currency,
                "target_currency": receive_currency,
                "provider": "wirebarley"
            }
    def _get_country_from_currency(self, currency: str) -> Optional[str]:
        return self.CURRENCY_TO_COUNTRY.get(currency)
    def get_corridor_details(self, source_currency: str, country_code: str) -> Optional[Dict[str, Any]]:
        corridors_response = self.get_corridors(source_currency)
        if not corridors_response:
            logger.error(f"Failed to fetch corridors for {source_currency}")
            return None
        raw_data = self.fetch_raw_data(source_currency, "USD", Decimal("100"))
        if raw_data.get("status") != 0 or "data" not in raw_data or "exRates" not in raw_data["data"]:
            logger.error(f"Invalid API response for {source_currency}")
            return None
        for ex_rate in raw_data["data"]["exRates"]:
            if ex_rate.get("countryCode") == country_code:
                return ex_rate
        logger.warning(f"No corridor found for {source_currency} to {country_code}")
        return None
    def _update_exchange_rate_cache(self):
        pass 
###END

###END

import json
import logging
import re
import time
import uuid
from decimal import Decimal
from typing import Dict, Optional, Any, List, Union, Tuple
import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
from apps.providers.base.provider import RemittanceProvider
from apps.providers.remitly.exceptions import (
    RemitlyError,
    RemitlyAuthenticationError,
    RemitlyConnectionError,
    RemitlyValidationError,
    RemitlyRateLimitError
)
logger = logging.getLogger(__name__)
class ExchangeRateResult:
    def __init__(
        self,
        provider_id: str,
        source_currency: str,
        source_amount: float,
        destination_currency: str,
        destination_amount: float,
        exchange_rate: float,
        fee: float,
        delivery_method: str,
        delivery_time_minutes: Optional[int] = None,
        corridor: Optional[str] = None,
        payment_method: Optional[str] = None,
        details: Optional[Dict] = None
    ):
        self.provider_id = provider_id
        self.source_currency = source_currency
        self.source_amount = source_amount
        self.destination_currency = destination_currency
        self.destination_amount = destination_amount
        self.exchange_rate = exchange_rate
        self.fee = fee
        self.delivery_method = delivery_method
        self.delivery_time_minutes = delivery_time_minutes
        self.corridor = corridor
        self.payment_method = payment_method
        self.details = details or {}
    def to_dict(self) -> Dict:
        return {
            "provider_id": self.provider_id,
            "source_currency": self.source_currency,
            "source_amount": self.source_amount,
            "destination_currency": self.destination_currency,
            "destination_amount": self.destination_amount,
            "exchange_rate": self.exchange_rate,
            "fee": self.fee,
            "delivery_method": self.delivery_method,
            "delivery_time_minutes": self.delivery_time_minutes,
            "corridor": self.corridor,
            "payment_method": self.payment_method,
            "details": self.details
        }
class RemitlyProvider(RemittanceProvider):
    BASE_URL = "https://api.remitly.io"
    CALCULATOR_ENDPOINT = "/v3/calculator/estimate"
    CORRIDORS_ENDPOINT = "/v1/corridors" # Endpoint for getting available corridors
    COUNTRIES_ENDPOINT = "/v1/countries" # Endpoint for getting country information
    DEFAULT_USER_AGENT = (
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
        "AppleWebKit/605.1.15 (KHTML, like Gecko) "
        "Version/18.3 Safari/605.1.15"
    )
    DEFAULT_DEVICE_ENV_ID = (
        "3RoCMEE0ZDG79rpNP7sK7MoEVrYFpVS4TgavrNTpz405kCFlIwl0s49e1xh4okoKhH2bA"
        "HxYPg0GZINPtd1BG4xDZGA0b0wOoffs2ZSr9Lm1"
    )
    DEFAULT_BROWSER_FINGERPRINT = {
        "browser_fingerprint_id": "1424498403190294011",
        "session_id": "1424498403198931748",
        "identity_id": "1424498403198837863",
        "link": "https://link.remitly.com/a/key_live_fedYw0b1AK8QmSuljIyvAmdbrAbwqqAc"
                "?%24identity_id=1424498403198837863",
        "data": "{\"+clicked_branch_link\":false,\"+is_first_session\":true}",
        "has_app": False
    }
    PAYMENT_METHODS = {
        "BANK_ACCOUNT": "Bank Account",
        "DEBIT_CARD": "Debit Card",
        "CREDIT_CARD": "Credit Card"
    }
    DELIVERY_METHODS = {
        "BANK_DEPOSIT": "Bank Deposit",
        "CASH_PICKUP": "Cash Pickup",
        "HOME_DELIVERY": "Home Delivery",
        "MOBILE_WALLET": "Mobile Wallet"
    }
    def __init__(
        self,
        device_env_id: Optional[str] = None,
        user_agent: Optional[str] = None,
        timeout: int = 30
    ):
        super().__init__(name="Remitly", base_url=self.BASE_URL)
        self.timeout = timeout
        self.device_env_id = device_env_id or self.DEFAULT_DEVICE_ENV_ID
        self.user_agent = user_agent or self.DEFAULT_USER_AGENT
        self.session = requests.Session()
        self._setup_session()
        self.logger = logging.getLogger('remitly_provider')
    def _setup_session(self) -> None:
        self.session.headers.update({
            "User-Agent": self.user_agent,
            "Accept": "application/json, text/javascript, */*; q=0.01",
            "Accept-Language": "en-US,en;q=0.9",
            "Origin": "https://www.remitly.com",  # The site that might embed the JS
            "Referer": "https://www.remitly.com/",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
        })
        fingerprint_json = json.dumps(self.DEFAULT_BROWSER_FINGERPRINT)
        self.session.headers["X-Remitly-Browser-Fingerprint"] = fingerprint_json
        self.session.headers["Remitly-DeviceEnvironmentID"] = self.device_env_id
        retry_strategy = Retry(
            total=3,
            backoff_factor=1.0,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
    def _make_api_request(
        self,
        method: str,
        url: str,
        params: Optional[Dict] = None,
        data: Optional[Dict] = None,
        retry_auth: bool = True,
        max_retries: int = 2
    ) -> Dict:
        retry_count = 0
        while retry_count <= max_retries:
            try:
                if method.upper() == "GET":
                    response = self.session.get(
                        url=url,
                        params=params,
                        timeout=self.timeout
                    )
                else:  # POST
                    response = self.session.post(
                        url=url,
                        json=data,
                        params=params,
                        timeout=self.timeout
                    )
                if response.status_code in (401, 403):
                    if retry_auth and retry_count < max_retries:
                        logger.warning(f"Authentication failed, refreshing session and retrying (attempt {retry_count + 1}/{max_retries})")
                        self._setup_session()
                        time.sleep(1)  # Add delay between retries
                        retry_count += 1
                        continue
                    raise RemitlyAuthenticationError("Authentication failed")
                if response.status_code == 429:
                    if retry_count < max_retries:
                        wait_time = 2 * (retry_count + 1)  # Progressive backoff
                        logger.warning(f"Rate limit exceeded, waiting {wait_time} seconds before retry")
                        time.sleep(wait_time)
                        retry_count += 1
                        continue
                    raise RemitlyRateLimitError("Rate limit exceeded")
                if response.status_code >= 400:
                    error_message = f"API error: HTTP {response.status_code}"
                    try:
                        error_data = response.json()
                        if isinstance(error_data, dict) and "error" in error_data:
                            error_message = f"API error: {error_data['error']}"
                    except ValueError:
                        pass
                    raise RemitlyError(error_message)
                try:
                    return response.json()
                except ValueError:
                    raise RemitlyError("Invalid JSON response from API")
            except requests.RequestException as e:
                logger.error(f"Request failed: {e}")
                if retry_count < max_retries:
                    logger.warning(f"Connection error, retrying (attempt {retry_count + 1}/{max_retries})")
                    time.sleep(2)
                    retry_count += 1
                    continue
                raise RemitlyConnectionError(f"Connection error: {e}")
        raise RemitlyError("Maximum retries exceeded")
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        send_currency: str = "USD",
        receive_country: str = None,
        receive_currency: str = None,
        delivery_method: str = None,  # Optional 
        payment_method: str = None,   # Optional
        purpose: str = "OTHER",
        customer_segment: str = "UNRECOGNIZED",
        strict_promo: bool = False
    ) -> Dict:
        if receive_country is None:
            raise RemitlyValidationError("Receive country is required")
        if receive_currency is None:
            raise RemitlyValidationError("Receive currency is required")
        if len(receive_country) == 2:
            try:
                country_info = self.get_country_info(receive_country)
                receive_country = country_info.get("iso3_code")
                if not receive_country:
                    raise RemitlyValidationError(f"Could not determine ISO3 code for country: {receive_country}")
            except (RemitlyError, RemitlyConnectionError) as e:
                logger.error(f"Failed to get country info: {e}")
                raise RemitlyValidationError(f"Invalid country code format: {receive_country}")
        try:
            source_country = self.get_source_country_for_currency(send_currency)
            if not source_country:
                raise RemitlyValidationError(f"Could not determine source country for currency: {send_currency}")
        except (RemitlyError, RemitlyConnectionError) as e:
            logger.error(f"Failed to get source country: {e}")
            raise RemitlyValidationError(f"Unsupported source currency: {send_currency}")
        send_amount_float = float(send_amount)
        conduit_str = f"{source_country}:{send_currency}-{receive_country}:{receive_currency}"
        url = f"{self.base_url}{self.CALCULATOR_ENDPOINT}"
        params = {
            "conduit": conduit_str,
            "anchor": "SEND",  # Fixed to "SEND" since we're providing the send amount
            "amount": str(send_amount_float),
            "purpose": purpose,
            "customer_segment": customer_segment,
            "strict_promo": str(strict_promo).lower()
        }
        logger.debug(f"Requesting Remitly rate with URL: {url}")
        logger.debug(f"Params: {params}")
        response = self._make_api_request(
            method="GET",
            url=url,
            params=params
        )
        if not response:
            raise RemitlyError("Failed to get exchange rate data")
        estimate = response.get("estimate", {})
        if not estimate:
            raise RemitlyError("No estimate data available")
        exchange_rate_data = estimate.get("exchange_rate", {})
        exchange_rate = float(exchange_rate_data.get("base_rate", 0.0))
        fee_data = estimate.get("fee", {})
        fee = float(fee_data.get("total_fee_amount", 0.0))
        receive_amount_str = estimate.get("receive_amount", "0.0")
        receive_amount = float(receive_amount_str) if receive_amount_str else 0.0
        delivery_time_minutes = None
        delivery_time_text = estimate.get("delivery_speed_description", "")
        if "minutes" in delivery_time_text.lower():
            try:
                minutes_match = re.search(r'(\d+)\s*minutes', delivery_time_text.lower())
                if minutes_match:
                    delivery_time_minutes = int(minutes_match.group(1))
            except (ValueError, AttributeError):
                pass
        elif "hours" in delivery_time_text.lower():
            try:
                hours_match = re.search(r'(\d+)\s*hours', delivery_time_text.lower())
                if hours_match:
                    delivery_time_minutes = int(hours_match.group(1)) * 60
            except (ValueError, AttributeError):
                pass
        result = ExchangeRateResult(
            provider_id="Remitly",
            source_currency=send_currency,
            source_amount=send_amount_float,
            destination_currency=receive_currency,
            destination_amount=receive_amount,
            exchange_rate=exchange_rate,
            fee=fee,
            delivery_method=self._normalize_delivery_method(estimate.get("delivery_method", "")),
            delivery_time_minutes=delivery_time_minutes,
            corridor=f"{source_country}-{receive_country}",
            payment_method=estimate.get("payment_method", ""),
            details={"raw_response": response}  # Store raw response for reference
        )
        return result.to_dict()
    def get_source_country_for_currency(self, currency_code: str) -> str:
        logger.warning(f"get_source_country_for_currency should make a real API call for {currency_code}")
        url = f"{self.base_url}{self.CORRIDORS_ENDPOINT}"
        params = {"currency": currency_code}
        try:
            raise RemitlyValidationError(
                f"Cannot determine source country for {currency_code} without API call",
                error_code="API_REQUIRED"
            )
        except RemitlyError:
            raise
    def get_country_info(self, country_code: str) -> Dict:
        logger.warning(f"get_country_info should make a real API call for {country_code}")
        url = f"{self.base_url}{self.COUNTRIES_ENDPOINT}/{country_code}"
        try:
            raise RemitlyValidationError(
                f"Cannot retrieve information for country code {country_code} without API call",
                error_code="API_REQUIRED"
            )
        except RemitlyError:
            raise
    def _normalize_delivery_method(self, method_type: str) -> str:
        method_map = {
            "BANK_DEPOSIT": "bank deposit",
            "CASH_PICKUP": "cash pickup",
            "HOME_DELIVERY": "home delivery",
            "MOBILE_WALLET": "mobile wallet"
        }
        return method_map.get(method_type, method_type.lower())
    def get_supported_countries(self) -> List[Dict]:
        logger.warning("get_supported_countries should make a real API call")
        url = f"{self.base_url}{self.COUNTRIES_ENDPOINT}"
        raise NotImplementedError("This method requires API data")
    def get_source_countries(self) -> List[Dict]:
        logger.warning("get_source_countries should make a real API call")
        url = f"{self.base_url}{self.CORRIDORS_ENDPOINT}/sources"
        raise NotImplementedError("This method requires API data")
    def close(self):
        self.session.close()
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close() 
###END

from .integration import WiseProvider
from .exceptions import (
    WiseError,
    WiseAuthenticationError,
    WiseConnectionError,
    WiseValidationError,
    WiseRateLimitError
)
__all__ = [
    'WiseProvider',
    'WiseError',
    'WiseAuthenticationError',
    'WiseConnectionError',
    'WiseValidationError',
    'WiseRateLimitError'
] 
###END

import json
import logging
import os
import random
import time
import uuid
import pprint
from datetime import datetime, UTC
from decimal import Decimal
from typing import Dict, Optional, Any, List, Union
from urllib.parse import urljoin
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from apps.providers.base.provider import RemittanceProvider
from .exceptions import (
    WiseError,
    WiseAuthenticationError,
    WiseConnectionError,
    WiseValidationError,
    WiseRateLimitError
)
logger = logging.getLogger(__name__)
def log_request_details(logger, method: str, url: str, headers: Dict,
                      params: Dict = None, data: Dict = None):
    logger.debug("\n" + "="*80 + f"\nOUTGOING REQUEST DETAILS:\n{'='*80}")
    logger.debug(f"Method: {method}")
    logger.debug(f"URL: {url}")
    masked_headers = headers.copy()
    sensitive = ['Authorization', 'Cookie']
    for key in sensitive:
        if key in masked_headers:
            masked_headers[key] = '***MASKED***'
    logger.debug("\nHeaders:")
    logger.debug(pprint.pformat(masked_headers))
    if params:
        logger.debug("\nQuery Params:")
        logger.debug(pprint.pformat(params))
    if data:
        logger.debug("\nRequest Body:")
        logger.debug(pprint.pformat(data))
def log_response_details(logger, response):
    logger.debug("\n" + "="*80 + f"\nRESPONSE DETAILS:\n{'='*80}")
    logger.debug(f"Status Code: {response.status_code}")
    logger.debug(f"Reason: {response.reason}")
    logger.debug("\nResponse Headers:")
    logger.debug(pprint.pformat(dict(response.headers)))
    try:
        body = response.json()
        logger.debug("\nJSON Response Body:")
        logger.debug(pprint.pformat(body))
    except ValueError:
        body = response.text
        content_type = response.headers.get('content-type', '').lower()
        if 'html' in content_type:
            logger.debug("\nHTML Response (truncated):")
            logger.debug(body[:500] + '...' if len(body) > 500 else body)
        else:
            logger.debug("\nPlain Text Response:")
            logger.debug(body[:1000] + '...' if len(body) > 1000 else body)
    logger.debug("="*80)
class WiseProvider(RemittanceProvider):
    BASE_URL = "https://api.transferwise.com"
    QUOTES_ENDPOINT = "/v3/quotes/"
    def __init__(self, api_key: Optional[str] = None, timeout: int = 30, user_agent: Optional[str] = None):
        super().__init__(name="Wise", base_url=self.BASE_URL)
        self.logger = logger
        self.timeout = timeout
        self.user_agent = user_agent or os.environ.get(
            "WISE_DEFAULT_UA",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15"
        )
        self.api_key = api_key or os.environ.get("WISE_API_KEY")
        self._session = requests.Session()
        self.request_id = str(uuid.uuid4())
        self._initialize_session()
        self.logger.debug(f"Initialized WiseProvider with UA: {self.user_agent}")
    def _initialize_session(self) -> None:
        self.logger.debug("Initializing Wise session...")
        self._session.headers.update({
            "Content-Type": "application/json",
            "Accept": "application/json",
            "User-Agent": self.user_agent,
            "X-Request-ID": self.request_id
        })
        if self.api_key:
            self._session.headers.update({
                "Authorization": f"Bearer {self.api_key}"
            })
        retry_strategy = Retry(
            total=3,
            backoff_factor=0.5,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self._session.mount("https://", adapter)
    def get_exchange_rate(self,
                         send_amount: Decimal,
                         send_currency: str,
                         receive_country: str,
                         receive_currency: Optional[str] = None,
                         send_country: str = "US") -> Optional[Dict]:
        country_to_currency = {
            "US": "USD",
            "GB": "GBP",
            "IN": "INR",
            "EG": "EGP",
            "MX": "MXN",
            "CA": "CAD",
            "AU": "AUD",
            "NZ": "NZD",
            "JP": "JPY",
            "CN": "CNY",
            "PH": "PHP",
            "SG": "SGD",
            "AE": "AED",
            "ZA": "ZAR",
            "BR": "BRL",
            "NG": "NGN",
            "KE": "KES"
        }
        if not receive_currency:
            receive_currency = country_to_currency.get(receive_country)
            if not receive_currency:
                self.logger.warning(f"No default currency for country {receive_country}")
                return None
        try:
            quote_data = self.get_quote(
                source_currency=send_currency,
                target_currency=receive_currency,
                source_amount=float(send_amount)
            )
            if not quote_data:
                self.logger.warning("Failed to get quote data from Wise API")
                return None
            best_option = self._find_best_payment_option(quote_data)
            if not best_option:
                self.logger.warning("No valid payment options found in quote")
                return None
            return {
                "provider": self.name,
                "timestamp": datetime.now(UTC).isoformat(),
                "send_amount": float(send_amount),
                "send_currency": send_currency,
                "receive_country": receive_country,
                "receive_currency": receive_currency,
                "exchange_rate": float(quote_data.get("rate", 0)),
                "transfer_fee": float(best_option.get("fee", {}).get("total", 0)),
                "service_name": f"{best_option.get('payIn', 'Unknown')} to {best_option.get('payOut', 'Unknown')}",
                "delivery_time": best_option.get("formattedEstimatedDelivery", "Unknown"),
                "receive_amount": float(best_option.get("targetAmount", 0))
            }
        except (WiseError, WiseConnectionError, WiseValidationError) as e:
            self.logger.error(f"Error getting Wise exchange rate: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Unexpected error in Wise exchange rate: {e}")
            return None
    def get_quote(self,
                 source_currency: str,
                 target_currency: str,
                 source_amount: Optional[float] = None,
                 target_amount: Optional[float] = None) -> Dict:
        if not source_amount and not target_amount:
            raise WiseValidationError(
                "Either source_amount or target_amount must be provided",
                error_code="MISSING_AMOUNT"
            )
        payload = {
            "sourceCurrency": source_currency,
            "targetCurrency": target_currency,
            "sourceAmount": source_amount,
            "targetAmount": target_amount
        }
        payload = {k: v for k, v in payload.items() if v is not None}
        try:
            url = urljoin(self.BASE_URL, self.QUOTES_ENDPOINT)
            headers = dict(self._session.headers)
            log_request_details(self.logger, "POST", url, headers, data=payload)
            response = self._session.post(
                url,
                json=payload,
                timeout=self.timeout
            )
            log_response_details(self.logger, response)
            response.raise_for_status()
            data = response.json()
            if not data.get("paymentOptions") and not data.get("rate"):
                raise WiseValidationError(
                    "Invalid quote response format",
                    error_code="INVALID_RESPONSE",
                    details={"response": data}
                )
            return data
        except requests.HTTPError as e:
            status_code = e.response.status_code if e.response else 0
            response_text = e.response.text if e.response else ""
            if status_code == 401:
                raise WiseAuthenticationError(
                    "Authentication failed with Wise API",
                    error_code="AUTH_FAILED",
                    details={"original_error": str(e), "response": response_text}
                )
            elif status_code == 400:
                raise WiseValidationError(
                    "Invalid request parameters",
                    error_code="INVALID_PARAMETERS",
                    details={"original_error": str(e), "response": response_text}
                )
            elif status_code == 429:
                raise WiseRateLimitError(
                    "Rate limit exceeded for Wise API",
                    error_code="RATE_LIMIT",
                    details={"original_error": str(e), "response": response_text, 
                            "retry_after": e.response.headers.get("Retry-After", "60")}
                )
            else:
                raise WiseConnectionError(
                    f"HTTP error from Wise API: {status_code}",
                    error_code="HTTP_ERROR",
                    details={"original_error": str(e), "response": response_text}
                )
        except requests.RequestException as e:
            raise WiseConnectionError(
                "Failed to connect to Wise API",
                error_code="CONNECTION_FAILED",
                details={"original_error": str(e)}
            )
    def get_supported_corridors(self) -> List[Dict]:
        return [
            {"source_country": "US", "target_country": "MX"},
            {"source_country": "US", "target_country": "IN"},
            {"source_country": "US", "target_country": "PH"},
            {"source_country": "GB", "target_country": "IN"},
            {"source_country": "GB", "target_country": "US"},
            {"source_country": "CA", "target_country": "IN"}
        ]
    def get_payment_methods(self, source_country: str, target_country: str) -> List[str]:
        common_methods = ["BANK_TRANSFER", "DEBIT", "CREDIT"]
        if source_country == "GB":
            common_methods.append("PISP")  # Open Banking available in UK
        if source_country in ["US", "CA", "GB", "AU"]:
            common_methods.extend(["INTERNATIONAL_DEBIT", "INTERNATIONAL_CREDIT"])
        return common_methods
    def get_delivery_methods(self, source_country: str, target_country: str) -> List[str]:
        methods = ["BANK_TRANSFER"]
        if target_country in ["MX", "PH", "IN", "CO", "VN"]:
            methods.append("CASH_PICKUP")
        if target_country not in ["US", "GB", "EU"]:
            methods.append("SWIFT")
        return methods
    def _find_best_payment_option(self, quote_data: Dict) -> Optional[Dict]:
        payment_options = quote_data.get("paymentOptions", [])
        if not payment_options:
            payment_options = quote_data.get("options", [])
        if not payment_options:
            return None
        valid_options = [opt for opt in payment_options if not opt.get("disabled", False)]
        if not valid_options:
            return None
        sorted_options = sorted(
            valid_options,
            key=lambda x: float(x.get("fee", {}).get("total", float("inf")))
        )
        return sorted_options[0] if sorted_options else None
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self._session:
            self._session.close() 
###END

###END

import json
import logging
import os
import pprint
from datetime import datetime, UTC
from decimal import Decimal
from typing import Dict, Optional, Any, List, Union, Tuple
from urllib.parse import urljoin
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from apps.providers.base.provider import RemittanceProvider
from .exceptions import (
    PangeaError,
    PangeaAuthenticationError,
    PangeaConnectionError,
    PangeaValidationError,
    PangeaRateLimitError,
    PangeaConfigError,
    PangeaAPIError
)
logger = logging.getLogger(__name__)
def log_request_details(logger, method: str, url: str, headers: Dict,
                      params: Dict = None, data: Dict = None):
    logger.debug("\n" + "="*80 + f"\nOUTGOING REQUEST DETAILS:\n{'='*80}")
    logger.debug(f"Method: {method}")
    logger.debug(f"URL: {url}")
    masked_headers = headers.copy()
    sensitive = ['Authorization', 'Cookie']
    for key in sensitive:
        if key in masked_headers:
            masked_headers[key] = '***MASKED***'
    logger.debug("\nHeaders:")
    logger.debug(pprint.pformat(masked_headers))
    if params:
        logger.debug("\nQuery Params:")
        logger.debug(pprint.pformat(params))
    if data:
        logger.debug("\nRequest Body:")
        logger.debug(pprint.pformat(data))
def log_response_details(logger, response):
    logger.debug("\n" + "="*80 + f"\nRESPONSE DETAILS:\n{'='*80}")
    logger.debug(f"Status Code: {response.status_code}")
    logger.debug(f"Reason: {response.reason}")
    logger.debug("\nResponse Headers:")
    logger.debug(pprint.pformat(dict(response.headers)))
    try:
        body = response.json()
        logger.debug("\nJSON Response Body:")
        logger.debug(pprint.pformat(body))
    except ValueError:
        body = response.text
        content_type = response.headers.get('content-type', '').lower()
        if 'html' in content_type:
            logger.debug("\nHTML Response (truncated):")
            logger.debug(body[:500] + '...' if len(body) > 500 else body)
        else:
            logger.debug("\nPlain Text Response:")
            logger.debug(body[:1000] + '...' if len(body) > 1000 else body)
    logger.debug("="*80)
class PangeaProvider(RemittanceProvider):
    BASE_URL = "https://api.gopangea.com"
    MAX_RETRIES = 3
    DEFAULT_PAYMENT_METHOD = "Bank Transfer"
    DEFAULT_DELIVERY_METHOD = "Bank Deposit"
    def __init__(self, api_key: str = None):
        super().__init__()
        self.logger = logging.getLogger(__name__)
        self.api_key = api_key or os.environ.get("PANGEA_API_KEY")
        if not self.api_key:
            raise PangeaConfigError("Pangea API key not provided")
        self.session = requests.Session()
        self.session.headers.update({
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "Accept": "application/json"
        })
        retry_strategy = Retry(
            total=self.MAX_RETRIES,
            backoff_factor=0.5,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("https://", adapter)
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        send_currency: str = "USD",
        receive_country: str = None,
        receive_currency: str = None,
        delivery_method: str = None,
        payment_method: str = None
    ) -> Dict:
        if not receive_country:
            raise PangeaValidationError("receive_country is required for Pangea")
        if not receive_currency:
            raise PangeaValidationError("receive_currency is required when using live API")
        payment_method = payment_method or self.DEFAULT_PAYMENT_METHOD
        delivery_method = delivery_method or self.DEFAULT_DELIVERY_METHOD
        try:
            url = f"{self.BASE_URL}/v1/fees"
            params = {
                "source_country": "US",  # Pangea only supports US as source
                "source_currency": send_currency,
                "source_amount": float(send_amount),
                "destination_country": receive_country,
                "destination_currency": receive_currency,
                "payment_method": self._normalize_payment_method(payment_method),
                "delivery_method": self._normalize_delivery_method(delivery_method)
            }
            response = self.session.get(url, params=params)
            if response.status_code != 200:
                raise PangeaAPIError(f"Failed to get exchange rate: {response.status_code} - {response.text}")
            data = response.json()
            fee = data.get("fee", 0)
            exchange_rate = data.get("exchange_rate", 1.0)
            receive_amount = data.get("destination_amount", 0)
            delivery_time = self._get_delivery_time(receive_country, delivery_method)
            result = {
                "provider_id": "Pangea",
                "source_currency": send_currency,
                "source_amount": float(send_amount),
                "destination_currency": receive_currency,
                "destination_amount": float(receive_amount),
                "exchange_rate": float(exchange_rate),
                "fee": float(fee),
                "delivery_method": delivery_method,
                "delivery_time_minutes": delivery_time,
                "corridor": f"US-{receive_country}",
                "payment_method": payment_method,
                "details": {
                    "raw_response": data
                }
            }
            return result
        except Exception as e:
            self.logger.error(f"Error getting exchange rate from Pangea: {str(e)}")
            raise PangeaAPIError(f"Failed to get exchange rate: {str(e)}")
    def _normalize_payment_method(self, method: str) -> str:
        method_lower = method.lower()
        if "bank" in method_lower and "account" in method_lower:
            return "bank_account"
        elif "debit" in method_lower or "card" in method_lower:
            return "debit_card"
        else:
            return "bank_account"  # Default
    def _normalize_delivery_method(self, method: str) -> str:
        method_lower = method.lower()
        if "bank" in method_lower:
            return "bank_deposit"
        elif "cash" in method_lower:
            return "cash_pickup"
        else:
            return "bank_deposit"  # Default
    def _get_delivery_time(self, country: str, delivery_method: str) -> int:
        return None
    @staticmethod
    def get_supported_corridors() -> List[Tuple[str, str]]:
        raise NotImplementedError("This method requires API data")
    @staticmethod
    def get_payment_methods() -> List[str]:
        raise NotImplementedError("This method requires API data")
    @staticmethod
    def get_delivery_methods(destination: str = None) -> List[str]:
        raise NotImplementedError("This method requires API data")
    def close(self):
        if self.session:
            self.session.close() 
###END

###END

import json
import logging
import time
import uuid
from decimal import Decimal
from typing import Dict, Optional, Any, List, Union, Tuple
import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
from apps.providers.base.provider import RemittanceProvider
from apps.providers.transferGo.exceptions import (
    TransferGoError,
    TransferGoAuthenticationError,
    TransferGoConnectionError,
    TransferGoValidationError,
    TransferGoRateLimitError
)
logger = logging.getLogger(__name__)
class ExchangeRateResult:
    def __init__(
        self,
        provider_id: str,
        source_currency: str,
        source_amount: float,
        destination_currency: str,
        destination_amount: float,
        exchange_rate: float,
        fee: float,
        delivery_method: str,
        delivery_time_minutes: Optional[int] = None,
        corridor: Optional[str] = None,
        payment_method: Optional[str] = None,
        details: Optional[Dict] = None
    ):
        self.provider_id = provider_id
        self.source_currency = source_currency
        self.source_amount = source_amount
        self.destination_currency = destination_currency
        self.destination_amount = destination_amount
        self.exchange_rate = exchange_rate
        self.fee = fee
        self.delivery_method = delivery_method
        self.delivery_time_minutes = delivery_time_minutes
        self.corridor = corridor
        self.payment_method = payment_method
        self.details = details or {}
    def to_dict(self) -> Dict:
        return {
            "provider_id": self.provider_id,
            "source_currency": self.source_currency,
            "source_amount": self.source_amount,
            "destination_currency": self.destination_currency,
            "destination_amount": self.destination_amount,
            "exchange_rate": self.exchange_rate,
            "fee": self.fee,
            "delivery_method": self.delivery_method,
            "delivery_time_minutes": self.delivery_time_minutes,
            "corridor": self.corridor,
            "payment_method": self.payment_method,
            "details": self.details
        }
class TransferGoProvider(RemittanceProvider):
    BASE_URL = "https://my.transfergo.com"
    DELIVERY_METHODS = {
        "BANK_TRANSFER": "Bank Deposit",
        "CASH_PICKUP": "Cash Pickup",
        "MOBILE_WALLET": "Mobile Wallet",
    }
    PAYMENT_METHODS = {
        "BANK_TRANSFER": "Bank Transfer",
        "CARD": "Card Payment",
        "WALLET": "Digital Wallet"
    }
    COUNTRY_CURRENCIES = {
        "GB": "GBP", "DE": "EUR", "FR": "EUR", "ES": "EUR", "IT": "EUR", 
        "NL": "EUR", "BE": "EUR", "AT": "EUR", "IE": "EUR", "FI": "EUR",
        "LV": "EUR", "LT": "EUR", "EE": "EUR", "PT": "EUR", "GR": "EUR", 
        "SK": "EUR", "SI": "EUR", "LU": "EUR", "MT": "EUR", "CY": "EUR",
        "PL": "PLN", "RO": "RON", "CZ": "CZK", "HU": "HUF", "SE": "SEK", 
        "DK": "DKK", "NO": "NOK", "CH": "CHF", "BG": "BGN", "HR": "HRK",
        "US": "USD", "CA": "CAD", "MX": "MXN", "BR": "BRL", "CO": "COP", 
        "AR": "ARS", "CL": "CLP", "PE": "PEN", "UY": "UYU", "DO": "DOP",
        "JM": "JMD", "BS": "BSD", "BB": "BBD", "TT": "TTD",
        "AU": "AUD", "NZ": "NZD", "JP": "JPY", "SG": "SGD", "CN": "CNY", 
        "HK": "HKD", "KR": "KRW", "TW": "TWD", "MY": "MYR", "TH": "THB", 
        "VN": "VND", "ID": "IDR", "PH": "PHP", "IN": "INR", "PK": "PKR", 
        "BD": "BDT", "LK": "LKR", "NP": "NPR",
        "AE": "AED", "SA": "SAR", "QA": "QAR", "BH": "BHD", "KW": "KWD", 
        "OM": "OMR", "IL": "ILS", "JO": "JOD", "LB": "LBP", "TR": "TRY",
        "ZA": "ZAR", "NG": "NGN", "KE": "KES", "EG": "EGP", "MA": "MAD", 
        "TN": "TND", "GH": "GHS", "TZ": "TZS", "UG": "UGX", "ET": "ETB",
        "UA": "UAH", "RU": "RUB", "KZ": "KZT", "GE": "GEL", "BY": "BYN", 
        "AZ": "AZN", "MD": "MDL", "AL": "ALL", "BA": "BAM", "RS": "RSD",
        "ME": "EUR", "MK": "MKD", "AM": "AMD", "UZ": "UZS", "TJ": "TJS"
    }
    MULTI_CURRENCY_COUNTRIES = {
        "UA": ["UAH", "USD", "EUR"],
        "IN": ["INR", "USD", "EUR"], 
        "PH": ["PHP", "USD"],
        "NG": ["NGN", "USD", "EUR"],
        "KE": ["KES", "USD", "EUR"],
        "GH": ["GHS", "USD", "EUR"],
        "TZ": ["TZS", "USD", "EUR"],
        "UG": ["UGX", "USD", "EUR"],
        "LK": ["LKR", "USD"],
        "NP": ["NPR", "USD", "EUR"]
    }
    DEFAULT_USER_AGENT = (
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
        "AppleWebKit/605.1.15 (KHTML, like Gecko) "
        "Version/18.3 Safari/605.1.15"
    )
    def __init__(self, user_agent: Optional[str] = None, timeout: int = 30):
        super().__init__(name="TransferGo", base_url=self.BASE_URL)
        self.timeout = timeout
        self.user_agent = user_agent or self.DEFAULT_USER_AGENT
        self.session = requests.Session()
        self._setup_session()
    def _setup_session(self):
        self.session.headers.update({
            "User-Agent": self.user_agent,
            "Accept": "*/*",  # TransferGo's endpoint returns JSON by default
            "Accept-Language": "en-US,en;q=0.9",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
            "Origin": "https://www.transfergo.com",
            "Referer": "https://www.transfergo.com/"
        })
        retry_strategy = Retry(
            total=3,
            backoff_factor=1.0,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
    def _make_api_request(
        self,
        method: str,
        url: str,
        params: Optional[Dict] = None,
        data: Optional[Dict] = None,
        retry_auth: bool = True,
        max_retries: int = 2
    ) -> Dict:
        retry_count = 0
        while retry_count <= max_retries:
            try:
                if method.upper() == "GET":
                    response = self.session.get(
                        url=url,
                        params=params,
                        timeout=self.timeout
                    )
                else:  # POST
                    response = self.session.post(
                        url=url,
                        json=data,
                        params=params,
                        timeout=self.timeout
                    )
                logger.debug(f"TransferGo API response status: {response.status_code}")
                if response.status_code in (401, 403):
                    if retry_auth and retry_count < max_retries:
                        logger.warning(f"Authentication failed, refreshing session and retrying (attempt {retry_count + 1}/{max_retries})")
                        self._setup_session()
                        time.sleep(1)  # Add delay between retries
                        retry_count += 1
                        continue
                    raise TransferGoAuthenticationError("Authentication failed")
                if response.status_code == 429:
                    if retry_count < max_retries:
                        wait_time = 5 * (retry_count + 1)  # Progressive backoff
                        logger.warning(f"Rate limit exceeded, waiting {wait_time} seconds before retry")
                        time.sleep(wait_time)
                        retry_count += 1
                        continue
                    raise TransferGoRateLimitError("Rate limit exceeded")
                if response.status_code >= 400:
                    try:
                        error_data = response.json()
                        error_message = error_data.get("error", {}).get("message", "Unknown API error")
                        raise TransferGoError(f"API error: {error_message}")
                    except (ValueError, KeyError):
                        raise TransferGoError(f"API error: {response.status_code}")
                try:
                    return response.json()
                except ValueError:
                    if response.status_code == 200 and not response.text.strip():
                        return {}
                    raise TransferGoError("Invalid JSON response from API")
            except requests.RequestException as e:
                logger.error(f"Request failed: {e}")
                if retry_count < max_retries:
                    logger.warning(f"Connection error, retrying (attempt {retry_count + 1}/{max_retries})")
                    time.sleep(2)
                    retry_count += 1
                    continue
                raise TransferGoConnectionError(f"Connection error: {e}")
        raise TransferGoError("Maximum retries exceeded")
    def get_quote(
        self,
        from_country: str,
        to_country: str,
        from_currency: str,
        to_currency: str,
        amount: Decimal,
        calc_base: str = "sendAmount",  # or "receiveAmount"
        business: int = 0
    ) -> Dict[str, Any]:
        url = f"{self.base_url}/api/booking/quotes"
        params = {
            "fromCurrencyCode": from_currency,
            "toCurrencyCode": to_currency,
            "fromCountryCode": from_country,
            "toCountryCode": to_country,
            "amount": str(amount),
            "calculationBase": calc_base,
            "business": str(business),
        }
        logger.debug(f"[TransferGo] Requesting quotes: {url} with {params}")
        try:
            data = self._make_api_request(
                method="GET",
                url=url,
                params=params
            )
            logger.debug(f"[TransferGo] Raw JSON response:\n{json.dumps(data, indent=2)}")
            options_list = data.get("options", [])
            default_option = None
            for opt in options_list:
                if opt.get("isDefault", False):
                    default_option = opt
                    break
            result = {
                "provider": "TransferGo",
                "options": options_list,
                "raw_json": data
            }
            if default_option:
                result["default_fee"] = float(default_option["fee"]["value"])
                result["default_exchange_rate"] = float(default_option["rate"]["value"])
                result["default_send_amount"] = float(default_option["sendingAmount"]["value"])
                result["default_receive_amount"] = float(default_option["receivingAmount"]["value"])
                result["booking_token"] = default_option["bookingToken"]
                payment_method = default_option.get("payInMethod", {}).get("type", "")
                delivery_method = default_option.get("payOutMethod", {}).get("type", "")
                result["payment_method"] = self.PAYMENT_METHODS.get(payment_method, payment_method)
                result["delivery_method"] = self.DELIVERY_METHODS.get(delivery_method, delivery_method)
                delivery_time = default_option.get("delivery", {}).get("time", "")
                result["delivery_time"] = delivery_time
                delivery_time_minutes = self._parse_delivery_time(delivery_time)
                if delivery_time_minutes:
                    result["delivery_time_minutes"] = delivery_time_minutes
            return result
        except Exception as e:
            logger.error(f"Error getting quote from TransferGo: {str(e)}")
            raise
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        send_currency: str = "USD",
        receive_country: str = None,
        receive_currency: str = None,
        delivery_method: str = None,
        payment_method: str = None,
        preferred_receive_currency: str = None  # New parameter to specify preferred currency if multiple are available
    ) -> Dict:
        if not receive_country and not receive_currency:
            raise TransferGoValidationError("Either receive_country or receive_currency is required")
        from_country = self._get_country_for_currency(send_currency)
        if not receive_currency and receive_country:
            if preferred_receive_currency and receive_country in self.MULTI_CURRENCY_COUNTRIES:
                if preferred_receive_currency in self.MULTI_CURRENCY_COUNTRIES[receive_country]:
                    receive_currency = preferred_receive_currency
                else:
                    receive_currency = self._get_currency_for_country(receive_country)
            else:
                receive_currency = self._get_currency_for_country(receive_country)
        if not receive_country and receive_currency:
            receive_country = self._get_country_for_currency(receive_currency)
        try:
            quote_result = self.get_quote(
                from_country=from_country,
                to_country=receive_country,
                from_currency=send_currency,
                to_currency=receive_currency,
                amount=send_amount,
                calc_base="sendAmount"
            )
            if "default_exchange_rate" in quote_result:
                result = ExchangeRateResult(
                    provider_id="TransferGo",
                    source_currency=send_currency,
                    source_amount=float(send_amount),
                    destination_currency=receive_currency,
                    destination_amount=quote_result["default_receive_amount"],
                    exchange_rate=quote_result["default_exchange_rate"],
                    fee=quote_result["default_fee"],
                    delivery_method=quote_result.get("delivery_method", "bank deposit"),
                    delivery_time_minutes=quote_result.get("delivery_time_minutes"),
                    corridor=f"{from_country}-{receive_country}",
                    payment_method=quote_result.get("payment_method", "Bank Transfer"),
                    details={
                        "booking_token": quote_result.get("booking_token"),
                        "all_options": quote_result.get("options", []),
                        "raw_response": quote_result.get("raw_json", {})
                    }
                )
                return result.to_dict()
            else:
                raise TransferGoError("No default rate option found in response")
        except Exception as e:
            logger.error(f"Error getting exchange rate from TransferGo: {str(e)}")
            return self._get_fallback_exchange_rate(
                float(send_amount),
                send_currency,
                receive_country,
                receive_currency
            )
    def _get_fallback_exchange_rate(
        self,
        send_amount: float,
        send_currency: str,
        receive_country: str,
        receive_currency: str
    ) -> Dict:
        source_country = self._get_country_for_currency(send_currency)
        eur_rates = {
            "EUR": 1.0,
            "USD": 1.08, "GBP": 0.85, "CHF": 0.96, "JPY": 161.5, "CAD": 1.46,
            "AUD": 1.64, "NZD": 1.75, "SGD": 1.45, "HKD": 8.43, "CNY": 7.79,
            "PLN": 4.32, "CZK": 25.23, "SEK": 11.31, "NOK": 11.29, "DKK": 7.46,
            "HUF": 386.55, "RON": 4.97, "BGN": 1.96, "HRK": 7.51, "RSD": 117.16,
            "ALL": 102.50, "BAM": 1.96, "MKD": 61.70,
            "UAH": 42.50, "RUB": 98.50, "TRY": 34.37, "GEL": 3.05, "KZT": 480.20,
            "BYN": 3.50, "AZN": 1.83, "MDL": 19.15, "AMD": 419.50, "UZS": 13550.0,
            "TJS": 11.85,
            "MXN": 20.40, "BRL": 5.90, "ARS": 956.50, "COP": 4233.0, "CLP": 997.0,
            "PEN": 4.05, "UYU": 42.30, "DOP": 63.20, "JMD": 168.50, "BSD": 1.08,
            "BBD": 2.16, "TTD": 7.32,
            "INR": 90.11, "PKR": 300.5, "BDT": 126.5, "LKR": 338.0, "NPR": 144.0,
            "THB": 39.65, "IDR": 17550.0, "MYR": 5.07, "PHP": 62.50, "KRW": 1480.0,
            "VND": 27150.0, "TWD": 34.75,
            "AED": 3.97, "SAR": 4.05, "QAR": 3.94, "BHD": 0.41, "KWD": 0.33,
            "OMR": 0.42, "ILS": 3.98, "JOD": 0.77, "LBP": 96750.0,
            "ZAR": 19.90, "EGP": 51.0, "MAD": 10.89, "TND": 3.38, "NGN": 1670.0,
            "KES": 140.0, "GHS": 16.35, "TZS": 2850.0, "UGX": 4125.0, "ETB": 61.25
        }
        if send_currency == "EUR":
            eur_amount = send_amount
        else:
            source_eur_rate = eur_rates.get(send_currency, 1.0)
            eur_amount = send_amount / source_eur_rate if source_eur_rate != 0 else send_amount
        dest_eur_rate = eur_rates.get(receive_currency, 10.0)
        exchange_rate = dest_eur_rate
        if send_currency != "EUR":
            source_eur_rate = eur_rates.get(send_currency, 1.0)
            if source_eur_rate > 0:
                exchange_rate = dest_eur_rate / source_eur_rate
        receive_amount = send_amount * exchange_rate
        fee = 0.0
        if send_currency == "EUR":
            if send_amount >= 1000:
                fee = 2.99
            elif send_amount >= 500:
                fee = 1.99
            elif send_amount >= 100:
                fee = 0.99
        elif send_currency == "USD":
            if send_amount >= 1000:
                fee = 3.49
            elif send_amount >= 500:
                fee = 2.49
            elif send_amount >= 100:
                fee = 1.49
        elif send_currency == "GBP":
            if send_amount >= 800:
                fee = 2.49
            elif send_amount >= 400:
                fee = 1.99
            elif send_amount >= 100:
                fee = 0.99
        else:
            if send_amount >= 1000:
                fee = 2.99
            elif send_amount >= 500:
                fee = 1.99
            elif send_amount >= 100:
                fee = 0.99
        return {
            "provider_id": "TransferGo",
            "source_currency": send_currency,
            "source_amount": send_amount,
            "destination_currency": receive_currency,
            "destination_amount": receive_amount,
            "exchange_rate": exchange_rate,
            "fee": fee,
            "delivery_method": "bank deposit",
            "delivery_time_minutes": 1440,  # Default: 24 hours (in minutes)
            "corridor": f"{source_country}-{receive_country}",
            "payment_method": "Bank Transfer",
            "details": {"is_fallback": True}
        }
    def _get_currency_for_country(self, country_code: str) -> str:
        return self.COUNTRY_CURRENCIES.get(country_code, "EUR")
    def _get_supported_currencies_for_country(self, country_code: str) -> List[str]:
        if country_code in self.MULTI_CURRENCY_COUNTRIES:
            return self.MULTI_CURRENCY_COUNTRIES[country_code]
        else:
            return [self.COUNTRY_CURRENCIES.get(country_code, "EUR")]
    def _get_country_for_currency(self, currency_code: str) -> str:
        currency_to_country = {
            "EUR": "DE",  # Using Germany as default for Euro
            "GBP": "GB",
            "PLN": "PL",
            "RON": "RO",
            "CZK": "CZ",
            "HUF": "HU",
            "SEK": "SE",
            "NOK": "NO",
            "DKK": "DK",
            "CHF": "CH",
            "BGN": "BG",
            "HRK": "HR",
            "USD": "US",
            "CAD": "CA",
            "MXN": "MX",
            "BRL": "BR",
            "COP": "CO",
            "ARS": "AR",
            "CLP": "CL",
            "PEN": "PE",
            "UYU": "UY",
            "DOP": "DO",
            "JMD": "JM",
            "BSD": "BS",
            "BBD": "BB",
            "TTD": "TT",
            "AUD": "AU",
            "NZD": "NZ",
            "JPY": "JP",
            "SGD": "SG",
            "CNY": "CN",
            "HKD": "HK",
            "KRW": "KR",
            "TWD": "TW",
            "MYR": "MY",
            "THB": "TH",
            "VND": "VN",
            "IDR": "ID",
            "PHP": "PH",
            "INR": "IN",
            "PKR": "PK",
            "BDT": "BD",
            "LKR": "LK",
            "NPR": "NP",
            "AED": "AE",
            "SAR": "SA",
            "QAR": "QA",
            "BHD": "BH",
            "KWD": "KW",
            "OMR": "OM",
            "ILS": "IL",
            "JOD": "JO",
            "LBP": "LB",
            "TRY": "TR",
            "ZAR": "ZA",
            "NGN": "NG",
            "KES": "KE",
            "EGP": "EG",
            "MAD": "MA",
            "TND": "TN",
            "GHS": "GH",
            "TZS": "TZ",
            "UGX": "UG",
            "ETB": "ET",
            "UAH": "UA",
            "RUB": "RU",
            "KZT": "KZ",
            "GEL": "GE",
            "BYN": "BY",
            "AZN": "AZ",
            "MDL": "MD",
            "ALL": "AL",
            "BAM": "BA",
            "RSD": "RS",
            "MKD": "MK",
            "AMD": "AM",
            "UZS": "UZ",
            "TJS": "TJ"
        }
        return currency_to_country.get(currency_code, "GB" if currency_code == "GBP" else "DE")
    def _parse_delivery_time(self, time_string: str) -> Optional[int]:
        if not time_string:
            return None
        time_string = time_string.lower()
        if "minutes" in time_string:
            try:
                mins = int(time_string.split()[0])
                return mins
            except (ValueError, IndexError):
                pass
        if "hours" in time_string:
            try:
                hours = int(time_string.split()[0])
                return hours * 60
            except (ValueError, IndexError):
                pass
        if "same day" in time_string:
            return 12 * 60  # 12 hours
        if "next day" in time_string or "1 business day" in time_string:
            return 24 * 60  # 24 hours
        if "1-2" in time_string and "days" in time_string:
            return 36 * 60  # 1.5 days
        if "2-3" in time_string and "days" in time_string:
            return 60 * 60  # 2.5 days
        if "instant" in time_string or "immediately" in time_string:
            return 5  # 5 minutes
        mappings = {
            "standard": 48 * 60,  # 2 days
            "fast": 24 * 60,      # 1 day
            "today": 8 * 60,      # 8 hours
            "express": 4 * 60,    # 4 hours
            "urgent": 2 * 60      # 2 hours
        }
        for key, value in mappings.items():
            if key in time_string:
                return value
        return None
    def get_supported_countries_and_currencies(self) -> Dict[str, List[str]]:
        result = {}
        for country, currency in self.COUNTRY_CURRENCIES.items():
            result[country] = [currency]
        for country, currencies in self.MULTI_CURRENCY_COUNTRIES.items():
            result[country] = currencies
        return result
    def get_supported_send_countries(self) -> List[str]:
        return [
            "GB", "DE", "FR", "ES", "IT", "NL", "BE", "AT", "IE", 
            "PL", "RO", "LT", "LV", "CZ", "HU", "SE", "DK", "NO", 
            "US", "CA",
            "AU", "SG",
            "AE", "TR",
            "ZA"
        ]
    def close(self):
        self.session.close()
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close() 
###END

###FILE:./apps/providers/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views
router = DefaultRouter()
router.register(r'compare', views.RateComparisonViewSet, basename='rates')
urlpatterns = [
    path('', include(router.urls)),
    path('send/', views.send_money_view, name='send_money'),
] 
###END

###FILE:./apps/providers/base/provider.py
from abc import ABC, abstractmethod
from typing import Dict, Optional
from decimal import Decimal
class RemittanceProvider(ABC):
    def __init__(self, name: str, base_url: str):
        self.name = name
        self.base_url = base_url
    @abstractmethod
    def get_exchange_rate(self, send_amount: Decimal, send_currency: str, 
                         receive_country: str) -> Optional[Dict]:
        pass
###END

from apps.providers.base.provider import RemittanceProvider
__all__ = ['RemittanceProvider']
###END

###FILE:./apps/providers/views.py
from datetime import timedelta
from django.utils import timezone
from django.core.cache import cache
from django.conf import settings
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django_filters import rest_framework as filters
from django.shortcuts import render
from django.contrib import messages
from decimal import Decimal
from .models import Provider, ExchangeRate
from .serializers import ProviderSerializer, ExchangeRateSerializer
from .tasks import update_all_rates
from .forms import SendMoneyForm
from .westernunion.integration import WesternUnionProvider
from .westernunion.exceptions import (
    WUError,
    WUAuthenticationError,
    WUValidationError,
    WUConnectionError
)
from .worldremit.integration import WorldRemitProvider
from .worldremit.exceptions import (
    WorldRemitError,
    WorldRemitAuthenticationError,
    WorldRemitValidationError,
    WorldRemitConnectionError
)
class ExchangeRateFilter(filters.FilterSet):
    min_amount = filters.NumberFilter(field_name='send_amount', lookup_expr='gte')
    max_amount = filters.NumberFilter(field_name='send_amount', lookup_expr='lte')
    from_currency = filters.CharFilter(field_name='send_currency')
    to_country = filters.CharFilter(field_name='receive_country')
    provider = filters.CharFilter(field_name='provider__name')
    class Meta:
        model = ExchangeRate
        fields = ['send_currency', 'receive_country', 'provider']
class RateComparisonViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = ExchangeRateSerializer
    filter_backends = [filters.DjangoFilterBackend]
    filterset_class = ExchangeRateFilter
    def get_queryset(self):
        one_hour_ago = timezone.now() - timedelta(hours=1)
        return ExchangeRate.objects.select_related('provider').filter(
            timestamp__gte=one_hour_ago,
            is_available=True
        )
    @action(detail=False, methods=['get'])
    def compare(self, request):
        amount = request.query_params.get('amount')
        from_currency = request.query_params.get('from_currency')
        to_country = request.query_params.get('to_country')
        if not all([amount, from_currency, to_country]):
            return Response({
                'error': 'Please provide amount, from_currency, and to_country parameters'
            }, status=status.HTTP_400_BAD_REQUEST)
        try:
            amount = float(amount)
        except ValueError:
            return Response({
                'error': 'Invalid amount'
            }, status=status.HTTP_400_BAD_REQUEST)
        cache_key = f"rates_{amount}_{from_currency.upper()}_{to_country.upper()}"
        cached_response = cache.get(cache_key)
        if cached_response:
            return Response(cached_response)
        one_hour_ago = timezone.now() - timedelta(hours=1)
        rates = ExchangeRate.objects.filter(
            send_amount=amount,
            send_currency=from_currency.upper(),
            receive_country=to_country.upper(),
            timestamp__gte=one_hour_ago,
            is_available=True
        ).select_related('provider')
        if not rates.exists():
            update_all_rates.delay(
                send_amount=amount,
                send_currency=from_currency.upper(),
                receive_country=to_country.upper()
            )
            return Response({
                'message': 'Rates are being updated. Please try again in a few moments.'
            }, status=status.HTTP_202_ACCEPTED)
        serializer = self.get_serializer(rates, many=True)
        response_data = {
            'rates': serializer.data,
            'timestamp': timezone.now().isoformat()
        }
        cache.set(cache_key, response_data, timeout=getattr(settings, 'CACHE_TTL', 600))
        return Response(response_data)
def send_money_view(request):
    if request.method == 'POST':
        form = SendMoneyForm(request.POST)
        if form.is_valid():
            cd = form.cleaned_data
            send_amount = cd['send_amount']
            send_currency = cd['send_currency']
            receive_country = cd['receive_country']
            send_country = cd['send_country']
            postal_code = cd.get('sender_postal_code')
            city = cd.get('sender_city')
            state = cd.get('sender_state')
            wu = WesternUnionProvider(timeout=30)
            try:
                rate_data = wu.get_exchange_rate(
                    send_amount,
                    send_currency,
                    receive_country,
                    send_country
                )
                if rate_data is None:
                    messages.error(
                        request,
                        "Unable to get a valid quote. Please try again or choose different options."
                    )
                    return render(request, 'providers/send_money_form.html', {'form': form})
                request.session['wu_quote'] = rate_data
                return render(request, 'providers/send_money_quote.html', {
                    'rate_data': rate_data,
                    'form_data': cd
                })
            except WUValidationError as e:
                messages.error(request, f"Invalid input: {str(e)}")
            except WUAuthenticationError as e:
                messages.error(request, "Authentication error with Western Union. Please try again.")
            except WUConnectionError as e:
                messages.error(request, "Connection error with Western Union. Please try again later.")
            except WUError as e:
                messages.error(request, f"Western Union error: {str(e)}")
            except Exception as e:
                messages.error(request, "An unexpected error occurred. Please try again later.")
            return render(request, 'providers/send_money_form.html', {'form': form})
    else:
        form = SendMoneyForm()
    return render(request, 'providers/send_money_form.html', {'form': form})
###END

from apps.providers.xe.integration import XEProvider
from apps.providers.xe.exceptions import (
    XEError,
    XEConnectionError,
    XEApiError,
    XEValidationError,
    XEResponseError,
    XECorridorUnsupportedError,
    XEQuoteError,
    XEParsingError,
    XERateLimitError
)
__all__ = [
    'XEProvider',
    'XEError',
    'XEConnectionError',
    'XEApiError',
    'XEValidationError',
    'XEResponseError',
    'XECorridorUnsupportedError',
    'XEQuoteError',
    'XEParsingError',
    'XERateLimitError'
] 
###END

import logging
import json
import uuid
import requests
from decimal import Decimal, InvalidOperation
from typing import Dict, Any, Optional, List
from bs4 import BeautifulSoup
from ..base.provider import RemittanceProvider
from .exceptions import (
    XEError,
    XEConnectionError,
    XEApiError,
    XEValidationError,
    XEResponseError,
    XECorridorUnsupportedError,
    XEQuoteError,
    XEParsingError,
    XERateLimitError
)
logger = logging.getLogger(__name__)
class XEProvider(RemittanceProvider):
    API_BASE_URL = "https://www.xe.com"
    MIDMARKET_RATES_URL = "https://www.xe.com/api/protected/midmarket-converter/"
    QUOTES_API_URL = "https://launchpad-api.xe.com/v2/quotes"
    COUNTRY_TO_CURRENCY = {
        'IN': 'INR',  # India - Indian Rupee
        'PH': 'PHP',  # Philippines - Philippine Peso
        'PK': 'PKR',  # Pakistan - Pakistani Rupee
        'US': 'USD',  # United States - US Dollar
        'GB': 'GBP',  # United Kingdom - British Pound
        'CA': 'CAD',  # Canada - Canadian Dollar
        'AU': 'AUD',  # Australia - Australian Dollar
        'MX': 'MXN',  # Mexico - Mexican Peso
    }
    SUPPORTED_CORRIDORS = [
        ('AUD', 'PH'),  # AUD to PH
        ('CAD', 'IN'),  # CAD to IN
        ('EUR', 'PH'),  # EUR to PH
        ('GBP', 'IN'),  # GBP to IN
        ('USD', 'IN'),  # USD to IN
        ('USD', 'PH'),  # USD to PH
]
    def __init__(self, api_key: str = None, **kwargs):
        super().__init__(name="xe", base_url="https://www.xe.com")
        self.api_key = api_key
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15',
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Origin': 'https://www.xe.com',
            'Referer': 'https://www.xe.com/send-money/'
        })
        self.midmarket_rates: Dict[str, Decimal] = {}
        self.device_id = str(uuid.uuid4())
        self._fetch_midmarket_rates()
        if not self.midmarket_rates:
            logger.info("Using fallback mid-market rates")
            self._set_fallback_rates()
    def _set_fallback_rates(self) -> None:
        fallback_rates = {
            'USD': Decimal('1.0'),
            'EUR': Decimal('0.92'),
            'GBP': Decimal('0.79'),
            'INR': Decimal('83.25'),
            'PHP': Decimal('57.0'),
            'JPY': Decimal('151.0'),
            'CAD': Decimal('1.36'),
            'AUD': Decimal('1.53'),
            'MXN': Decimal('16.80'),
        }
        self.midmarket_rates = fallback_rates
    def _fetch_midmarket_rates(self) -> None:
        logger.info("Fetching mid-market rates from XE...")
        try:
            resp = self.session.get(self.MIDMARKET_RATES_URL, timeout=15)
            resp.raise_for_status()
            data = resp.json()
            rates_dict = data.get("rates", {})
            count = 0
            for ccy, val in rates_dict.items():
                try:
                    self.midmarket_rates[ccy] = Decimal(str(val))
                    count += 1
                except Exception:
                    logger.warning(f"Failed to parse rate for {ccy}: {val}")
            logger.info(f"XE mid-market rates fetched: {count} rates stored.")
        except requests.HTTPError as exc:
            logger.error(f"HTTP error fetching mid-market rates from XE: {exc}")
        except Exception as ex:
            logger.error(f"Error in mid-market rates fetch: {ex}")
    def _get_receive_currency(self, receive_country: str) -> str:
        return self.COUNTRY_TO_CURRENCY.get(receive_country, 'USD')
    def is_corridor_supported(self, send_currency: str, receive_country: str) -> bool:
        return (send_currency, receive_country) in self.SUPPORTED_CORRIDORS
    def _fetch_quote(self, from_ccy: str, to_ccy: str, send_amount: Decimal,
                    from_country: str, to_country: str) -> Dict[str, Any]:
        payload = {
            "sellCcy": from_ccy,
            "buyCcy": to_ccy,
            "userCountry": from_country,  # or maybe "GB", "US", etc.
            "amount": float(send_amount),
            "fixedCcy": from_ccy,
            "countryTo": to_country
        }
        headers = {
            "X-Correlation-ID": f"XECOM-{uuid.uuid4()}",
            "deviceid": str(self.device_id),
        }
        result = {
            "success": False,
            "error_message": None
        }
        try:
            logger.info(f"Requesting quote from XE API: {from_ccy} -> {to_ccy}, amount={send_amount}")
            resp = self.session.post(
                self.QUOTES_API_URL,
                json=payload,
                headers=headers,
                timeout=15
            )
            resp.raise_for_status()
            data = resp.json()
            if "quote" in data:
                quote = data["quote"]
                quote_id = quote.get("quoteId", "unknown")
                quote_status = quote.get("quoteStatus", "unknown")
                logger.info(f"Received XE quote (ID: {quote_id}, Status: {quote_status})")
                if "individualQuotes" in quote and len(quote["individualQuotes"]) > 0:
                    first_quote = quote["individualQuotes"][0]
                    provider = first_quote.get("commissionProvider", "XE")
                    sell_amount = first_quote.get("sellAmount", "0").replace(",", "")
                    buy_amount = first_quote.get("buyAmount", "0").replace(",", "")
                    rate = first_quote.get("rate", 0)
                    fee = first_quote.get("transferFee", "0").replace(",", "")
                    payment_fee = first_quote.get("paymentMethodFee", "0").replace(",", "")
                    delivery_eta = first_quote.get("valueDate", "Unknown")
                    try:
                        sell_amount_decimal = Decimal(sell_amount)
                        buy_amount_decimal = Decimal(buy_amount)
                        fee_decimal = Decimal(fee)
                        payment_fee_decimal = Decimal(payment_fee)
                    except (ValueError, InvalidOperation) as e:
                        logger.warning(f"Failed to convert amount string to Decimal: {e}")
                        sell_amount_decimal = send_amount
                        if rate and isinstance(rate, (int, float, Decimal)):
                            buy_amount_decimal = send_amount * Decimal(str(rate))
                        else:
                            buy_amount_decimal = Decimal("0")
                        fee_decimal = Decimal("0")
                        payment_fee_decimal = Decimal("0")
                    total_fee = fee_decimal + payment_fee_decimal
                    result = {
                        "provider": "xe",
                        "provider_name": provider,
                        "quote_id": quote_id,
                        "send_amount": sell_amount_decimal,
                        "send_currency": from_ccy,
                        "receive_amount": buy_amount_decimal,
                        "receive_currency": to_ccy,
                        "rate": Decimal(str(rate)) if rate else (buy_amount_decimal / sell_amount_decimal if sell_amount_decimal else Decimal("0")),
                        "fee": total_fee,
                        "fee_currency": from_ccy,
                        "delivery_estimate": delivery_eta,
                        "success": True
                    }
                else:
                    result["error_message"] = "No quote details found in response"
            else:
                result["error_message"] = "Unexpected response format from XE API - missing 'quote' field"
            return result
        except requests.HTTPError as e:
            error_msg = f"HTTP error from XE API ({e.response.status_code}): {str(e)}"
            logger.error(error_msg)
            result["error_message"] = error_msg
            raise XEApiError(error_msg) from e
        except (json.JSONDecodeError, KeyError) as e:
            error_msg = f"Error parsing XE API response: {str(e)}"
            logger.error(error_msg)
            result["error_message"] = error_msg
            raise XEResponseError(error_msg) from e
        except Exception as e:
            error_msg = f"Unexpected error when fetching XE quote: {str(e)}"
            logger.error(error_msg)
            result["error_message"] = error_msg
            raise XEError(error_msg) from e
    def get_exchange_rate(self, send_amount: Decimal, send_currency: str, receive_country: str, **kwargs) -> Dict[str, Any]:
        logger.info(f"Getting XE exchange rate for {send_currency} to {receive_country} (Amount: {send_amount})")
        result = {
            "provider": self.name,
            "send_amount": float(send_amount),
            "send_currency": send_currency,
            "receive_country": receive_country,
            "success": False,
            "error_message": None
        }
        receive_currency = self._get_receive_currency(receive_country)
        if not receive_currency:
            msg = f"Unable to determine currency for country {receive_country}"
            logger.warning(msg)
            result["error_message"] = msg
            raise XECorridorUnsupportedError(msg)
        result["receive_currency"] = receive_currency
        try:
            endpoint_url = self.QUOTES_API_URL
            headers = {
                "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36",
                "Content-Type": "application/json",
                "Accept": "application/json",
            }
            quote_id = str(uuid.uuid4())
            data = {
                "quoteId": quote_id,
                "partnerUserId": quote_id,
                "sellCurrency": send_currency,
                "buyCurrency": receive_currency,
                "sellAmount": str(send_amount),
                "scope": "full"
            }
            try:
                response = requests.post(endpoint_url, json=data, headers=headers, timeout=30)
                response.raise_for_status()
            except requests.exceptions.ConnectionError as e:
                msg = f"Connection error with XE API: {e}"
                logger.error(msg)
                result["error_message"] = msg
                raise XEConnectionError(msg) from e
            except requests.exceptions.Timeout as e:
                msg = f"Timeout connecting to XE API: {e}"
                logger.error(msg)
                result["error_message"] = msg
                raise XEConnectionError(msg) from e
            except requests.exceptions.HTTPError as e:
                status_code = e.response.status_code if hasattr(e, 'response') else 'unknown'
                msg = f"HTTP error from XE API ({status_code}): {e}"
                logger.error(msg)
                result["error_message"] = msg
                if status_code == 429:
                    raise XERateLimitError(msg) from e
                raise XEApiError(msg) from e
            except Exception as e:
                msg = f"Error connecting to XE API: {e}"
                logger.error(msg)
                result["error_message"] = msg
                raise XEError(msg) from e
            try:
                data = response.json()
            except ValueError as e:
                msg = f"Failed to parse JSON from XE API: {e}"
                logger.error(msg)
                result["error_message"] = msg
                raise XEParsingError(msg) from e
            quote_obj = data.get("quote", {})
            if not quote_obj:
                msg = "No quote in response"
                logger.error(msg)
                result["error_message"] = msg
                raise XEResponseError(msg)
            individual_quotes = quote_obj.get("individualQuotes", [])
            if not individual_quotes:
                msg = "No individual quotes found"
                logger.error(msg)
                result["error_message"] = msg
                raise XEResponseError(msg)
            chosen = None
            for q in individual_quotes:
                if q.get("isDefault", False) and q.get("isEnabled", True):
                    chosen = q
                    break
            if not chosen:
                for q in individual_quotes:
                    if q.get("isEnabled", False):
                        chosen = q
                        break
            if not chosen:
                msg = "No valid quote found in 'individualQuotes'"
                logger.error(msg)
                result["error_message"] = msg
                raise XEQuoteError(msg)
            try:
                rate = float(chosen.get("rate", 0.0))
                fee_str = chosen.get("transferFee", "0.00")
                fee = float(fee_str)
                buy_amt_str = chosen.get("buyAmount", "0").replace(",", "")
                buy_amt = float(buy_amt_str)
                delivery_time = chosen.get("leadTime", "N/A")
                result.update({
                    "success": True,
                    "exchange_rate": rate,
                    "fee": fee,
                    "receive_amount": buy_amt,
                    "delivery_time": delivery_time
                })
                if kwargs.get("include_raw_data", False):
                    result["raw_data"] = data
                logger.info(f"Successfully retrieved XE quote: {rate} {send_currency}/{receive_currency}")
                return result
            except Exception as e:
                msg = f"Error extracting quote details: {e}"
                logger.error(msg)
                result["error_message"] = msg
                raise XEParsingError(msg) from e
        except (XEConnectionError, XEApiError, XEResponseError, XEQuoteError, XEParsingError) as e:
            logger.warning(f"Direct API failed, trying fallback HTML method: {str(e)}")
            return self._fallback_get_rate_from_website(send_amount, send_currency, receive_currency, result)
        except Exception as e:
            logger.error(f"Unexpected error in XE API request: {str(e)}")
            result["error_message"] = f"Unexpected error: {str(e)}"
            return self._fallback_get_rate_from_website(send_amount, send_currency, receive_currency, result)
    def _get_exchange_rate_from_html(self, send_amount: Decimal, send_currency: str, receive_country: str) -> Dict[str, Any]:
        receive_currency = self._get_receive_currency(receive_country)
        result = {
            'success': False,
            'error_message': None
        }
        try:
            url = f"{self.API_BASE_URL}/send-money/details"
            params = {
                'Amount': str(send_amount),
                'FromCurrency': send_currency,
                'ToCurrency': receive_currency
            }
            original_headers = self.session.headers.copy()
            self.session.headers.update({
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
            })
            logger.info(f"Requesting HTML quote for {send_amount} {send_currency} to {receive_country}")
            response = self.session.get(url, params=params)
            self.session.headers = original_headers
            if response.status_code == 200:
                soup = BeautifulSoup(response.text, 'html.parser')
                next_data = soup.find('script', {'id': '__NEXT_DATA__'})
                if next_data:
                    try:
                        data = json.loads(next_data.string)
                        props = data.get('props', {}).get('pageProps', {})
                        quote_data = None
                        if 'quote' in props:
                            quote_data = props['quote']
                        elif 'initialData' in props and 'quote' in props['initialData']:
                            quote_data = props['initialData']['quote']
                        if quote_data:
                            individual_quotes = quote_data.get('individualQuotes', [])
                            default_quote = next((q for q in individual_quotes if q.get('isDefault', False)), None)
                            if default_quote:
                                exchange_rate = default_quote.get('rate')
                                receive_amount = float(default_quote.get('buyAmount', '0').replace(',', ''))
                                fee = float(default_quote.get('transferFee', '0'))
                                delivery_time = default_quote.get('leadTime', 'Unknown')
                                result.update({
                                    'exchange_rate': exchange_rate,
                                    'receive_amount': receive_amount,
                                    'fee': fee,
                                    'delivery_time': delivery_time,
                                    'success': True,
                                    'raw_data': {'quote': quote_data}
                                })
                                logger.info(f"Successfully retrieved XE quote from HTML: {exchange_rate} {send_currency}/{receive_currency}")
                                return result
                    except Exception as e:
                        logger.error(f"Error parsing __NEXT_DATA__: {str(e)}")
                state_pattern = r'window\.__INITIAL_STATE__\s*=\s*JSON\.parse\("(.+?)"\);'
                import re
                matches = re.search(state_pattern, response.text)
                if matches:
                    try:
                        json_str = matches.group(1)
                        json_str = json_str.replace('\\"', '"').replace('\\\\', '\\')
                        data = json.loads(json_str)
                        quote_data = data.get('quote', {}).get('quote', {})
                        if quote_data:
                            individual_quotes = quote_data.get('individualQuotes', [])
                            default_quote = next((q for q in individual_quotes if q.get('isDefault', False)), None)
                            if default_quote:
                                exchange_rate = default_quote.get('rate')
                                receive_amount = float(default_quote.get('buyAmount', '0').replace(',', ''))
                                fee = float(default_quote.get('transferFee', '0'))
                                delivery_time = default_quote.get('leadTime', 'Unknown')
                                result.update({
                                    'exchange_rate': exchange_rate,
                                    'receive_amount': receive_amount,
                                    'fee': fee,
                                    'delivery_time': delivery_time,
                                    'success': True,
                                    'raw_data': {'quote': quote_data}
                                })
                                logger.info(f"Successfully retrieved XE quote from HTML: {exchange_rate} {send_currency}/{receive_currency}")
                                return result
                    except Exception as e:
                        logger.error(f"Error parsing INITIAL_STATE: {str(e)}")
                result['error_message'] = "Could not extract quote data from the HTML"
                result['debug_html'] = response.text[:1000] + "..."
            else:
                logger.error(f"Failed to fetch XE HTML quote. Status code: {response.status_code}")
                result['error_message'] = f"HTTP error: {response.status_code}"
        except Exception as e:
            logger.error(f"Error in HTML fallback: {str(e)}")
            result['error_message'] = f"HTML fallback error: {str(e)}"
        return result
    def _fallback_get_rate_from_website(self, send_amount: Decimal, send_currency: str, receive_currency: str, result: Dict[str, Any]) -> Dict[str, Any]:
        logger.info(f"Trying fallback website method for {send_currency} to {receive_currency}")
        try:
            url = f"{self.API_BASE_URL}/xemoneytransfer/send"
            params = {
                "Amount": str(send_amount),
                "FromCurrency": send_currency,
                "ToCurrency": receive_currency
            }
            headers = {
                "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
            }
            try:
                response = requests.get(url, params=params, headers=headers, timeout=30)
                response.raise_for_status()
            except requests.exceptions.ConnectionError as e:
                msg = f"Connection error with XE website: {e}"
                logger.error(msg)
                result["error_message"] = msg
                raise XEConnectionError(msg) from e
            except requests.exceptions.Timeout as e:
                msg = f"Timeout connecting to XE website: {e}"
                logger.error(msg)
                result["error_message"] = msg
                raise XEConnectionError(msg) from e
            except requests.exceptions.HTTPError as e:
                status_code = e.response.status_code if hasattr(e, 'response') else 'unknown'
                msg = f"HTTP error from XE website ({status_code}): {e}"
                logger.error(msg)
                result["error_message"] = msg
                raise XEApiError(msg) from e
            except Exception as e:
                msg = f"Error connecting to XE website: {e}"
                logger.error(msg)
                result["error_message"] = msg
                raise XEError(msg) from e
            try:
                soup = BeautifulSoup(response.text, 'html.parser')
                next_data = soup.find('script', {'id': '__NEXT_DATA__'})
                if next_data:
                    try:
                        data = json.loads(next_data.string)
                        props = data.get('props', {}).get('pageProps', {})
                        quote_data = None
                        if 'quote' in props:
                            quote_data = props['quote']
                        elif 'initialData' in props and 'quote' in props['initialData']:
                            quote_data = props['initialData']['quote']
                        if quote_data:
                            individual_quotes = quote_data.get('individualQuotes', [])
                            default_quote = next((q for q in individual_quotes if q.get('isDefault', False)), None)
                            if default_quote:
                                exchange_rate = default_quote.get('rate')
                                receive_amount = float(default_quote.get('buyAmount', '0').replace(',', ''))
                                fee = float(default_quote.get('transferFee', '0'))
                                delivery_time = default_quote.get('leadTime', 'Unknown')
                                result.update({
                                    'exchange_rate': exchange_rate,
                                    'receive_amount': receive_amount,
                                    'fee': fee,
                                    'delivery_time': delivery_time,
                                    'success': True,
                                    'raw_data': {'quote': quote_data}
                                })
                                logger.info(f"Successfully retrieved XE quote from HTML: {exchange_rate} {send_currency}/{receive_currency}")
                                return result
                    except Exception as e:
                        logger.error(f"Error parsing __NEXT_DATA__: {str(e)}")
                        raise XEParsingError(f"Error parsing __NEXT_DATA__: {str(e)}") from e
                state_pattern = r'window\.__INITIAL_STATE__\s*=\s*JSON\.parse\("(.+?)"\);'
                import re
                matches = re.search(state_pattern, response.text)
                if matches:
                    try:
                        json_str = matches.group(1)
                        json_str = json_str.replace('\\"', '"').replace('\\\\', '\\')
                        data = json.loads(json_str)
                        quote_data = data.get('quote', {})
                        if quote_data:
                            rate = float(quote_data.get('rate', 0))
                            fee = float(quote_data.get('fee', 0))
                            receive_amount = (float(send_amount) - fee) * rate
                            result.update({
                                'exchange_rate': rate,
                                'receive_amount': receive_amount,
                                'fee': fee,
                                'delivery_time': quote_data.get('deliveryTime', 'Unknown'),
                                'success': True,
                                'raw_data': {'quote': quote_data}
                            })
                            logger.info(f"Successfully retrieved XE quote from __INITIAL_STATE__: {rate} {send_currency}/{receive_currency}")
                            return result
                    except Exception as e:
                        logger.error(f"Error parsing __INITIAL_STATE__: {str(e)}")
                        raise XEParsingError(f"Error parsing __INITIAL_STATE__: {str(e)}") from e
                try:
                    rate_element = soup.select_one("[data-test='exchange-rate']")
                    if rate_element:
                        rate_text = rate_element.text.strip()
                        import re
                        rate_match = re.search(r'1\s+[A-Z]{3}\s*=\s*(\d+(?:\.\d+)?)', rate_text)
                        if rate_match:
                            rate = float(rate_match.group(1))
                            fee_element = soup.select_one("[data-test='fee']")
                            fee = 0.0
                            if fee_element:
                                fee_text = fee_element.text.strip()
                                fee_match = re.search(r'(\d+(?:\.\d+)?)', fee_text)
                                if fee_match:
                                    fee = float(fee_match.group(1))
                            receive_amount = float(send_amount) * rate - fee
                            result.update({
                                'exchange_rate': rate,
                                'receive_amount': receive_amount,
                                'fee': fee,
                                'delivery_time': 'Unknown',
                                'success': True
                            })
                            logger.info(f"Successfully retrieved XE quote from HTML elements: {rate} {send_currency}/{receive_currency}")
                            return result
                except Exception as e:
                    logger.error(f"Error parsing HTML elements: {str(e)}")
                    raise XEParsingError(f"Error parsing HTML elements: {str(e)}") from e
                msg = "Could not extract exchange rate from HTML response"
                logger.error(msg)
                result["error_message"] = msg
                return result
            except XEParsingError as e:
                raise
            except Exception as e:
                msg = f"Error parsing XE website response: {str(e)}"
                logger.error(msg)
                result["error_message"] = msg
                raise XEParsingError(msg) from e
        except Exception as e:
            logger.error(f"Fallback method failed: {str(e)}")
            if not result.get("error_message"):
                result["error_message"] = f"Fallback method failed: {str(e)}"
            return result
        return result
    def get_quote(self, amount: Decimal, source_currency: str, target_country: str, **kwargs) -> Dict[str, Any]:
        return self.get_exchange_rate(
            send_amount=amount,
            send_currency=source_currency,
            receive_country=target_country,
            **kwargs
        )
    def get_supported_countries(self, base_currency: str = None) -> List[str]:
        if not base_currency:
            return sorted(set(country for _, country in self.SUPPORTED_CORRIDORS))
        return sorted(set(country for currency, country in self.SUPPORTED_CORRIDORS if currency == base_currency)) 
###END

from .integration import MukuruProvider
from .exceptions import (
    MukuruError,
    MukuruConnectionError,
    MukuruApiError,
    MukuruResponseError,
    MukuruCorridorUnsupportedError,
    MukuruRateLimitError,
)
__all__ = [
    'MukuruProvider',
    'MukuruError',
    'MukuruConnectionError',
    'MukuruApiError',
    'MukuruResponseError',
    'MukuruCorridorUnsupportedError',
    'MukuruRateLimitError',
] 
###END

import logging
import json
import re
import requests
from decimal import Decimal
from typing import Dict, Any, List, Optional
from apps.providers.base import RemittanceProvider
from apps.providers.mukuru.exceptions import (
    MukuruError,
    MukuruConnectionError,
    MukuruApiError,
    MukuruResponseError,
    MukuruCorridorUnsupportedError,
    MukuruRateLimitError,
)
logger = logging.getLogger(__name__)
class MukuruProvider(RemittanceProvider):
    BASE_URL = "https://mobile.mukuru.com"
    PRICECHECKER_CALCULATE_PATH = "/pricechecker/calculate"
    PRICECHECKER_COUNTRIES_PATH = "/pricechecker/get_recipient_countries"
    COUNTRY_TO_CURRENCY = {
        'ZA': 'ZAR',  # South Africa - South African Rand
        'ZW': 'USD',  # Zimbabwe - US Dollar
        'GH': 'GHS',  # Ghana - Ghana Cedi
        'NG': 'NGN',  # Nigeria - Nigerian Naira
        'ML': 'XOF',  # Mali - West African CFA franc
        'MZ': 'MZN',  # Mozambique - Mozambican Metical
        'KE': 'KES',  # Kenya - Kenyan Shilling
        'MW': 'MWK',  # Malawi - Malawian Kwacha
    }
    SUPPORTED_CORRIDORS = [
        ('ZA', 'ZW'),  # South Africa to Zimbabwe
        ('ZA', 'GH'),  # South Africa to Ghana
        ('ZA', 'NG'),  # South Africa to Nigeria
        ('ZA', 'MZ'),  # South Africa to Mozambique
        ('ZA', 'MW'),  # South Africa to Malawi
    ]
    CURRENCY_ID_MAPPING = {
        ('ZA', 'ZW'): 18,  # For ZAR to USD (Zimbabwe)
        ('ZA', 'GH'): 20,  # Example ID for Ghana (placeholder)
        ('ZA', 'NG'): 21,  # Example ID for Nigeria (placeholder)
    }
    def __init__(self, name="mukuru", **kwargs):
        super().__init__(name=name, base_url=self.BASE_URL, **kwargs)
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": (
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                "AppleWebKit/605.1.15 (KHTML, like Gecko) "
                "Version/18.3 Safari/605.1.15"
            ),
            "Accept": "application/json, text/javascript, */*; q=0.01",
            "X-Requested-With": "XMLHttpRequest",
            "Pragma": "no-cache",
            "Cache-Control": "no-cache",
        })
        self._supported_countries = None
    def get_supported_countries(self) -> Dict[str, str]:
        if self._supported_countries is not None:
            return self._supported_countries
        url = self.BASE_URL + self.PRICECHECKER_COUNTRIES_PATH
        logger.info(f"Fetching Mukuru recipient countries from {url}")
        try:
            resp = self.session.get(url, params={
                "brand_id": 1,
                "sales_channel": "mobi",
            }, timeout=15)
            resp.raise_for_status()
            try:
                data = resp.json()
                if data.get("status") != "success":
                    logger.error("Mukuru get_recipient_countries returned non-success status")
                    return {}
                result = {}
                for country_code, info in data.get("data", {}).items():
                    currency_iso = info.get("currency_market_iso")
                    result[country_code] = currency_iso
                self._supported_countries = result
                return result
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse JSON response: {str(e)}")
                raise MukuruResponseError(f"Failed to parse JSON response: {str(e)}")
        except requests.exceptions.RequestException as e:
            logger.error(f"Connection error fetching Mukuru countries: {str(e)}")
            raise MukuruConnectionError(f"Failed to connect to Mukuru API: {str(e)}")
    def get_currency_id(self, from_country: str, to_country: str) -> int:
        currency_id = self.CURRENCY_ID_MAPPING.get((from_country, to_country))
        if currency_id is None:
            logger.warning(f"No currency ID found for {from_country} to {to_country}, using default")
            currency_id = 18  # Default to ZW (Zimbabwe) corridor
        return currency_id
    def get_exchange_rate(
        self,
        send_amount: Decimal,
        send_currency: str,
        receive_country: str,
        **kwargs
    ) -> Dict[str, Any]:
        from_country_code = kwargs.get("from_country_code", "ZA")
        currency_id = self.get_currency_id(from_country_code, receive_country)
        result = {
            "provider": self.name,
            "success": False,
            "send_amount": float(send_amount),
            "send_currency": send_currency,
            "receive_country": receive_country,
            "error_message": None
        }
        url = self.BASE_URL + self.PRICECHECKER_CALCULATE_PATH
        params = {
            "from_currency_iso": send_currency,   # e.g. 'ZAR'
            "payin_amount": str(send_amount),     # e.g. '900'
            "from_country": from_country_code,    # e.g. 'ZA'
            "to_currency_iso": "",                # often empty if we rely on currency_id
            "payout_amount": "",
            "to_country": receive_country,        # e.g. 'ZW'
            "currency_id": currency_id,
            "active_input": "payin_amount",
            "brand_id": 1,
            "sales_channel": "mobi",
        }
        logger.info(f"Requesting Mukuru quote for {send_currency} {send_amount} to {receive_country}")
        try:
            resp = self.session.get(url, params=params, timeout=15)
            resp.raise_for_status()
            try:
                data = resp.json()
                if data.get("status") != "success":
                    error_msg = f"Non-success status from Mukuru: {data}"
                    logger.error(error_msg)
                    result["error_message"] = error_msg
                    return result
                quote_data = data.get("data", {})
                breakdown = quote_data.get("breakdown", {})
                rate_str = breakdown.get("Rate", "")
                exchange_rate = None
                rate_match = re.search(r"R(\d+(\.\d+)?)", rate_str)
                if rate_match:
                    zar_per_unit = float(rate_match.group(1))  # e.g., 18.7248
                    if zar_per_unit:
                        exchange_rate = 1.0 / zar_per_unit  # Convert to USD per ZAR
                else:
                    logger.warning(f"Could not parse exchange rate from: {rate_str}")
                payin_info = breakdown.get("payin", {})
                fee_str = payin_info.get("Charge", "")  # e.g., "ZAR94.00"
                fee_value = 0.0
                fee_match = re.search(r"(\d+(\.\d+)?)", fee_str)
                if fee_match:
                    fee_value = float(fee_match.group(1))
                payout_info = breakdown.get("payout", {})
                receive_str = payout_info.get("They receive", "")  # e.g., "USD50.00"
                receive_amount = 0.0
                receive_match = re.search(r"(\d+(\.\d+)?)", receive_str)
                if receive_match:
                    receive_amount = float(receive_match.group(1))
                receive_currency_match = re.search(r"([A-Z]{3})", receive_str)
                receive_currency = None
                if receive_currency_match:
                    receive_currency = receive_currency_match.group(1)
                result.update({
                    "success": True,
                    "exchange_rate": exchange_rate,
                    "receive_amount": receive_amount,
                    "fee": fee_value,
                    "receive_currency": receive_currency,
                })
                return result
            except json.JSONDecodeError as e:
                error_msg = f"Failed to parse JSON response: {str(e)}"
                logger.error(error_msg)
                result["error_message"] = error_msg
                return result
        except requests.exceptions.RequestException as e:
            error_msg = f"Connection error fetching Mukuru quote: {str(e)}"
            logger.error(error_msg)
            result["error_message"] = error_msg
            return result
    def get_quote(
        self,
        amount: Decimal,
        source_currency: str,
        target_country: str,
        **kwargs
    ) -> Dict[str, Any]:
        from_country_code = kwargs.get("from_country_code")
        if not from_country_code:
            for country, currency in self.COUNTRY_TO_CURRENCY.items():
                if currency == source_currency:
                    from_country_code = country
                    break
            if not from_country_code:
                from_country_code = "ZA"
        return self.get_exchange_rate(
            send_amount=amount,
            send_currency=source_currency,
            receive_country=target_country,
            from_country_code=from_country_code,
            **kwargs
        ) 
###END

###FILE:./apps/users/models.py
###END

###FILE:./apps/users/serializers.py
###END

###FILE:./apps/users/__init__.py
###END

###FILE:./apps/users/apps.py
###END

###FILE:./apps/users/admin.py
###END

###FILE:./apps/users/urls.py
###END

###FILE:./apps/users/views.py
###END

