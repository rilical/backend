"""
WorldRemit Money Transfer Integration with ScrapeOps

This module implements the integration with WorldRemit using ScrapeOps Proxy API
to bypass PerimeterX protection. ScrapeOps provides a proxy service that handles
the anti-bot protection and returns the clean HTML/JSON response.

PAYMENT METHODS:
---------------------------------
- Debit Card: Primary payment method
- Credit Card: Alternative payment method

DELIVERY METHODS:
---------------------------------
- Bank Deposit: Direct to bank account
- Mobile Money: Transfer to mobile wallet
- Cash Pickup: Available in some corridors
"""

import json
import logging
import os
import time
import re
from datetime import datetime
from decimal import Decimal
from typing import Dict, Optional, Any, List, Union
from urllib.parse import urljoin, quote_plus, urlencode

import requests
from bs4 import BeautifulSoup

from apps.providers.base.provider import RemittanceProvider
from apps.providers.worldremit.exceptions import (
    WorldRemitError,
    WorldRemitAuthenticationError,
    WorldRemitConnectionError,
    WorldRemitValidationError,
    WorldRemitRateLimitError
)

# Setup logging
logger = logging.getLogger(__name__)

def log_request_details(method: str, url: str, headers: Dict, params: Dict = None, data: Dict = None):
    """Log the details of an HTTP request for debugging purposes."""
    logger.debug(f"Request: {method} {url}")
    logger.debug(f"Headers: {json.dumps(headers, indent=2)}")

    if params:
        logger.debug(f"Params: {json.dumps(params, indent=2)}")
    
    if data:
        logger.debug(f"Data: {json.dumps(data, indent=2)}")

def log_response_details(response):
    """Log the details of an HTTP response for debugging purposes."""
    logger.debug(f"Response Status: {response.status_code}")
    logger.debug(f"Response Headers: {json.dumps(dict(response.headers), indent=2)}")
    
    try:
        # Try to parse as JSON
        json_data = response.json()
        logger.debug(f"Response JSON: {json.dumps(json_data, indent=2)}")
    except:
        # Log the full text response without truncation
        logger.debug(f"Response Text (full): {response.text}")
        
    # Always log the raw content length for reference
    logger.debug(f"Response Content Length: {len(response.content)} bytes")

class WorldRemitScrapeOpsProvider(RemittanceProvider):
    """
    WorldRemit integration using ScrapeOps Proxy API to bypass PerimeterX protection.
    """
    BASE_URL = "https://www.worldremit.com"
    CALCULATOR_URL = "https://www.worldremit.com/en/calculator"
    TRANSFER_URL = "https://www.worldremit.com/en/transfer"
    HOME_URL = "https://www.worldremit.com/en"
    US_HOME_URL = "https://www.worldremit.com/en/us"
    
    # GraphQL API endpoint
    GRAPHQL_API_URL = "https://api.worldremit.com/graphql"
    
    # If we can't access one URL, try these alternatives in order
    ALTERNATIVE_URLS = [
        "https://www.worldremit.com/en",
        "https://www.worldremit.com/en/us",
        "https://www.worldremit.com"
    ]
    
    PAYMENT_METHODS = {
        "DebitCard": "debit-card",
        "CreditCard": "credit-card"
    }
    
    COUNTRY_CODE_MAPPING = {
        "USA": "US",
        "TUR": "TR",
        "MEX": "MX",
        "COL": "CO",
        "PHL": "PH",
        "GTM": "GT",
        "SLV": "SV",
        "HND": "HN",
        "ECU": "EC",
        "DOM": "DO",
        "NIC": "NI",
        "PER": "PE",
        "EGY": "EG"
    }
    
    def __init__(
        self, 
        api_key: str,
        timeout: int = 60,
        render_js: bool = True,
        use_residential_proxies: bool = True,
        country: Optional[str] = None
    ):
        """
        Initialize the WorldRemit ScrapeOps Provider.
        
        Args:
            api_key: ScrapeOps API key
            timeout: Request timeout in seconds
            render_js: Whether to render JavaScript on the page (required for WorldRemit)
            use_residential_proxies: Whether to use residential proxies (better success rate)
            country: Optional country geotargeting for proxies
        """
        super().__init__(name="WorldRemit", base_url=self.BASE_URL)
        self.api_key = api_key
        self.timeout = timeout
        self.render_js = render_js
        self.use_residential_proxies = use_residential_proxies
        self.country = country
        
        # ScrapeOps API endpoint
        self.SCRAPEOPS_API_URL = "https://proxy.scrapeops.io/v1/"
        
        # Initialize requests session
        self.session = requests.Session()
    
    def _make_scrapeops_request(self, url: str, method: str = "GET", data: Optional[Dict | str] = None, custom_headers: Optional[Dict] = None, post_content_type: Optional[str] = None) -> requests.Response:
        """
        Make a request through ScrapeOps proxy to bypass PerimeterX.
        
        Args:
            url: The URL to request
            method: HTTP method (GET, POST, etc.)
            data: Optional data for POST requests (can be dict or JSON string)
            custom_headers: Optional custom headers to include
            post_content_type: Optional post content type for POST requests
            
        Returns:
            Response object
        """
        # Prepare parameters for ScrapeOps
        params = {
            'api_key': self.api_key,
            'url': url,
            'bypass': 'perimeterx',
            'render_js': 'true',  # Ensure JavaScript rendering is enabled
            'residential': 'true',  # Use residential proxies for better success
            'method': method,
        }
        
        # Add custom headers if provided
        if custom_headers:
            params['custom_headers'] = json.dumps(custom_headers)
        
        # Handle GraphQL request specifically
        is_graphql = url.endswith('/graphql') and method == "POST" and data
        
        # Handle POST data
        if method == "POST" and data:
            # Special handling for GraphQL
            if is_graphql:
                # Log the GraphQL request
                logger.info("Making GraphQL request through ScrapeOps")
                
                # Check if data is already a string
                if isinstance(data, str):
                    try:
                        # Try to parse it as JSON to ensure it's valid
                        json_data = json.loads(data)
                        payload_json = data
                    except json.JSONDecodeError:
                        # If not valid JSON, stringify it
                        payload_json = json.dumps(data)
                else:
                    # Convert dict to JSON
                    payload_json = json.dumps(data)
                
                # Log the GraphQL payload for debugging
                logger.debug(f"GraphQL payload: {payload_json}")
                
                # Try alternative approach: directly add graphql_query parameters
                if isinstance(data, dict) and 'query' in data:
                    # Extract GraphQL components
                    params['graphql_query'] = data['query']
                    
                    if 'variables' in data:
                        params['graphql_variables'] = json.dumps(data['variables'])
                    
                    if 'operationName' in data:
                        params['graphql_operation_name'] = data['operationName']
                        
                    # Mark that we're not using post_data since we're using specific GraphQL params
                    logger.debug("Using ScrapeOps GraphQL parameters instead of post_data")
                else:
                    # Fallback to standard post_data approach
                    params['post_data'] = payload_json
                    
                    # Ensure content type is set for GraphQL
                    if not post_content_type:
                        post_content_type = 'application/json'
            else:
                # Standard post_data handling for non-GraphQL
                if isinstance(data, dict):
                    params['post_data'] = json.dumps(data)
                else:
                    params['post_data'] = data
            
            # Add specific content type for POST request
            if post_content_type:
                params['post_content_type'] = post_content_type
        
        # Make request through ScrapeOps
        try:
            scrapeops_url = self.SCRAPEOPS_API_URL
            logger.info(f"Making ScrapeOps request: {method} {url}")
            logger.debug(f"ScrapeOps params: {json.dumps({k: v for k, v in params.items() if k != 'api_key'}, indent=2)}")
            
            response = self.session.get(scrapeops_url, params=params, timeout=self.timeout)
            
            # Log response details for debugging
            log_response_details(response)
            
            return response
        except requests.RequestException as e:
            logger.error(f"ScrapeOps request failed: {e}")
            raise WorldRemitConnectionError(f"ScrapeOps request failed: {e}")
    
    def _normalize_country_code(self, country_code: str) -> str:
        """Convert 3-letter country codes to 2-letter codes if needed."""
        return self.COUNTRY_CODE_MAPPING.get(country_code, country_code)
        
    def _make_direct_graphql_request(self, query: str, variables: Optional[Dict] = None, operationName: Optional[str] = None) -> Dict:
        """
        Make a direct GraphQL request to WorldRemit API.
        
        Args:
            query: The GraphQL query string
            variables: Optional variables for the query
            operationName: Optional operation name
            
        Returns:
            The parsed JSON response
        """
        # GraphQL endpoint
        url = self.GRAPHQL_API_URL
        
        # Create custom headers
        custom_headers = {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "Origin": "https://www.worldremit.com",
            "Referer": "https://www.worldremit.com/en/send-money/us/tr?lc=us",
            "x-wr-platform": "Web",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15"
        }
        
        # Generate a UUID for the request ID
        import uuid
        request_id = str(uuid.uuid4())
        custom_headers["x-wr-requestid"] = request_id
        
        # Construct the GraphQL payload
        payload = {
            "query": query
        }
        
        if variables:
            payload["variables"] = variables
            
        if operationName:
            payload["operationName"] = operationName
        
        # Convert payload to JSON string
        payload_json = json.dumps(payload)
        
        logger.info(f"Making direct GraphQL request to {url}")
        logger.debug(f"GraphQL payload: {payload_json}")
        
        try:
            direct_response = requests.post(
                url=url,
                headers=custom_headers,
                data=payload_json,
                timeout=self.timeout
            )
            
            # Check for HTTP errors
            if direct_response.status_code != 200:
                logger.error(f"Direct GraphQL request failed with status {direct_response.status_code}")
                logger.error(f"Response: {direct_response.text[:500]}")
                raise WorldRemitConnectionError(f"Direct GraphQL request failed with status {direct_response.status_code}")
            
            # Parse the response
            try:
                result = direct_response.json()
                
                # Log for debugging
                logger.debug(f"Direct GraphQL response: {json.dumps(result, indent=2)}")
                
                # Check for GraphQL errors
                if "errors" in result:
                    errors = result.get("errors", [])
                    error_message = errors[0].get("message", "Unknown GraphQL error") if errors else "Unknown GraphQL error"
                    logger.error(f"GraphQL errors: {error_message}")
                    raise WorldRemitValidationError(f"GraphQL errors: {error_message}")
                
                return result
                
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse response as JSON: {e}")
                logger.error(f"Response text: {direct_response.text[:500]}")
                raise WorldRemitError(f"Invalid JSON response: {e}")
                
        except requests.RequestException as e:
            logger.error(f"Direct GraphQL request failed: {e}")
            raise WorldRemitConnectionError(f"Failed to connect: {e}")
        except Exception as e:
            logger.error(f"Error making direct GraphQL request: {e}")
            raise WorldRemitError(f"Error making direct GraphQL request: {e}")

    def _make_graphql_request(self, query: str, variables: Optional[Dict] = None, operationName: Optional[str] = None) -> Dict:
        """
        Make a GraphQL request to WorldRemit API using direct requests only.
        
        Args:
            query: The GraphQL query string
            variables: Optional variables for the query
            operationName: Optional operation name
            
        Returns:
            The parsed JSON response
        """
        # Always use direct GraphQL requests - ScrapeOps has issues with GraphQL
        try:
            logger.info("Making direct GraphQL request")
            result = self._make_direct_graphql_request(query, variables, operationName)
            logger.info("Direct GraphQL request successful")
            return result
        except WorldRemitError as e:
            logger.error(f"Direct GraphQL request failed: {e}")
            raise  # Re-raise the exception - no fallback for GraphQL

    def get_exchange_rate(self, from_currency: str, to_country: str, to_currency: str, amount: float = 1000.0) -> ExchangeRateResult:
        """
        Get the exchange rate from WorldRemit using GraphQL API.
        
        Args:
            from_currency: Source currency code (e.g., USD)
            to_country: Destination country code (e.g., MX)
            to_currency: Destination currency code (e.g., MXN)
            amount: Amount to convert
            
        Returns:
            ExchangeRateResult with rate info
        """
        # Normalize country code
        to_country_code = self._normalize_country_code(to_country)
        send_country_code = "US"  # Only supporting US sending for now
        
        # Try different payout methods in order of preference
        payout_methods = ["BANK_TRANSFER", "CASH_PICKUP", "MOBILE_MONEY"]
        
        # GraphQL query for exchange rate calculation
        query = """
        mutation createCalculation($amount: BigDecimal!, $type: CalculationType!, $sendCountryCode: CountryCode!, $sendCurrencyCode: CurrencyCode!, $receiveCountryCode: CountryCode!, $receiveCurrencyCode: CurrencyCode!, $payOutMethodCode: String, $correspondentId: String) {
          createCalculation(calculationInput: {amount: $amount, send: {country: $sendCountryCode, currency: $sendCurrencyCode}, type: $type, receive: {country: $receiveCountryCode, currency: $receiveCurrencyCode}, payOutMethodCode: $payOutMethodCode, correspondentId: $correspondentId}) {
                        calculation {
                          id
                          isFree
                          send {
                            currency
                            amount
                          }
                          receive {
                            amount
                            currency
                          }
                          exchangeRate {
                            value
                          }
                        }
                        errors {
              __typename
              ... on GenericCalculationError {
                message
                genericType: type
              }
              ... on ValidationCalculationError {
                          message
                type
                            code
                description
                          }
                        }
                      }
                    }
                """
        
        # Iterate through payout methods until we find one that works
        for payout_method in payout_methods:
            variables = {
                "amount": amount,
                "type": "SEND",
                "sendCountryCode": send_country_code,
                "sendCurrencyCode": from_currency,
                "receiveCountryCode": to_country_code,
                "receiveCurrencyCode": to_currency,
                "payOutMethodCode": payout_method,
                "correspondentId": None
            }
            
            try:
                # Make the direct GraphQL request
                logger.info(f"Trying exchange rate calculation with payout method: {payout_method}")
                response = self._make_graphql_request(
                    query=query,
                    variables=variables,
                    operationName="createCalculation"
                )
                
                # Check for calculation errors
                if "errors" in response.get("data", {}).get("createCalculation", {}):
                    errors = response["data"]["createCalculation"]["errors"]
                    error_message = errors[0].get("message", "Unknown error") if errors else "Unknown error"
                    logger.warning(f"Calculation error with payout method {payout_method}: {error_message}")
                    continue  # Try next payout method
                
                # Extract calculation result
                calculation = response["data"]["createCalculation"]["calculation"]
                
                # Extract exchange rate value
                exchange_rate = calculation["exchangeRate"]["value"]
                
                # Extract send and receive amounts
                send_amount = calculation["send"]["amount"]
                receive_amount = calculation["receive"]["amount"]
                
                # Calculate fee (difference between sent and received at exchange rate)
                implied_receive_without_fee = float(send_amount) * float(exchange_rate)
                fee_in_destination_currency = implied_receive_without_fee - float(receive_amount)
                
                # Create result object
                result = ExchangeRateResult(
                    provider_id=self.provider_id,
                    source_currency=from_currency,
                    source_amount=float(send_amount),
                    destination_currency=to_currency,
                    destination_amount=float(receive_amount),
                    exchange_rate=float(exchange_rate),
                    fee=fee_in_destination_currency,
                    delivery_method=payout_method.lower(),
                    delivery_time_minutes=None,  # Not available from this API
                    corridor=f"{send_country_code}-{to_country_code}"
                )
                
                logger.info(f"Successfully got exchange rate: {exchange_rate} {from_currency}/{to_currency}")
                return result
                
            except WorldRemitError as e:
                logger.warning(f"Failed with payout method {payout_method}: {e}")
                continue  # Try next payout method
        except Exception as e:
            logger.error(f"Unexpected error with payout method {payout_method}: {e}")
            continue  # Try next payout method
        
        # If we've tried all payout methods and none worked
        raise WorldRemitValidationError(f"No supported payout methods for corridor {send_country_code} -> {to_country_code}")
            
    def _get_default_currency_for_country(self, country_code: str) -> Optional[str]:
        """
        Get the default currency for a country.
        
        Args:
            country_code: Two-letter country code
            
        Returns:
            Currency code or None if not found
        """
        # Common currency mappings
        country_to_currency = {
            "US": "USD",
            "GB": "GBP",
            "TR": "TRY",
            "MX": "MXN",
            "CO": "COP",
            "PH": "PHP",
            "GT": "GTQ",
            "SV": "USD",
            "HN": "HNL",
            "EC": "USD",
            "DO": "DOP",
            "NI": "NIO",
            "PE": "PEN",
            "EG": "EGP",
            "NG": "NGN",
            "IN": "INR",
            "PK": "PKR",
            "BD": "BDT",
            "LK": "LKR",
            "NP": "NPR",
            "ZA": "ZAR",
            "KE": "KES"
        }
        
        return country_to_currency.get(country_code)
    
    def get_supported_countries(self) -> List[Dict]:
        """
        Get a list of supported destination countries from WorldRemit.
            
        Returns:
            A list of dictionaries containing country information
        """
        # Skip GraphQL attempt since it's not working with ScrapeOps
        # Go directly to web scraping method
        
        # Try each URL in sequence until one works
        urls_to_try = [self.TRANSFER_URL] + self.ALTERNATIVE_URLS
        last_error = None
        
        for url in urls_to_try:
            try:
                logger.info(f"Attempting to access WorldRemit at URL: {url}")
                # Use ScrapeOps to access the WorldRemit page
                response = self._make_scrapeops_request(url)
                
                # Parse HTML
                soup = BeautifulSoup(response.text, 'html.parser')
                
                # Extract country options from the country dropdown
                # The selector will need to be adjusted based on the actual page structure
                countries = []
                
                # Look for country dropdown
                country_select = soup.select_one("select[data-test='dropdown-they-live-in']")
                if country_select:
                    for option in country_select.select("option"):
                        value = option.get("value")
                        name = option.text.strip()
                        
                        if value and name and value != "":
                            # Try to extract currency from the option text or attributes
                            currency_code = self._get_default_currency_for_country(value)
                            
                            countries.append({
                                "country_code": value,
                                "country_name": name,
                                "currency_code": currency_code
                            })
                
                # If countries found, return them
                if countries:
                    logger.info(f"Successfully found {len(countries)} countries on {url}")
                    return countries
                
                # If no countries found through the dropdown on this URL, try looking for another element
                # that might contain country information
                country_tiles = soup.select(".country-tile") or soup.select(".destination-country")
                if country_tiles:
                    for tile in country_tiles:
                        # Try to find country name and code from the tile
                        name_elem = tile.select_one("h3") or tile.select_one(".country-name")
                        if name_elem:
                            name = name_elem.text.strip()
                            # Try to get the country code from data attributes or links
                            code = None
                            link = tile.select_one("a")
                            if link:
                                href = link.get("href", "")
                                # Extract country code from URL pattern
                                if "country=" in href:
                                    code = href.split("country=")[1].split("&")[0]
                                elif "/to/" in href:
                                    code = href.split("/to/")[1].split("/")[0]
                            
                            if name and code:
                                currency_code = self._get_default_currency_for_country(code)
                                countries.append({
                                    "country_code": code.upper(),  # Ensure uppercase
                                    "country_name": name,
                                    "currency_code": currency_code
                                })
                    
                    if countries:
                        logger.info(f"Successfully found {len(countries)} countries from tiles on {url}")
                        return countries
                
                # If no countries found through either method on this URL, try the next one
                logger.warning(f"No countries found on {url}, trying next URL if available")
                
        except Exception as e:
                logger.warning(f"Error accessing {url}: {str(e)}")
                last_error = e
                continue  # Try the next URL
        
        # If we've tried all URLs and none worked, use the static list
        logger.warning("Could not extract countries from any page, using static list")
        return self._get_static_country_list()
            
    def _get_static_country_list(self) -> List[Dict]:
        """Return a static list of commonly supported WorldRemit countries."""
        logger.info("Using static country list as fallback")
        return [
            {"country_code": "TR", "country_name": "Turkey", "currency_code": "TRY"},
            {"country_code": "MX", "country_name": "Mexico", "currency_code": "MXN"},
            {"country_code": "CO", "country_name": "Colombia", "currency_code": "COP"},
            {"country_code": "PH", "country_name": "Philippines", "currency_code": "PHP"},
            {"country_code": "IN", "country_name": "India", "currency_code": "INR"},
            {"country_code": "BD", "country_name": "Bangladesh", "currency_code": "BDT"},
            {"country_code": "PK", "country_name": "Pakistan", "currency_code": "PKR"},
            {"country_code": "NG", "country_name": "Nigeria", "currency_code": "NGN"},
            {"country_code": "KE", "country_name": "Kenya", "currency_code": "KES"},
            {"country_code": "GH", "country_name": "Ghana", "currency_code": "GHS"},
            {"country_code": "ZA", "country_name": "South Africa", "currency_code": "ZAR"},
            {"country_code": "UG", "country_name": "Uganda", "currency_code": "UGX"},
            {"country_code": "PE", "country_name": "Peru", "currency_code": "PEN"},
            {"country_code": "EC", "country_name": "Ecuador", "currency_code": "USD"},
            {"country_code": "DO", "country_name": "Dominican Republic", "currency_code": "DOP"}
        ]
    
    def get_payment_methods(self, source_country: str = "US", target_country: str = "TR") -> List[Dict]:
        """
        Get available payment methods for a specific country corridor.
        
        Args:
            source_country: Sending country code
            target_country: Receiving country code
        
        Returns:
            List of available payment methods
        """
        # Normalize country codes
        source_country = self._normalize_country_code(source_country)
        target_country = self._normalize_country_code(target_country)
        
        # WorldRemit typically supports these payment methods universally
        # We're returning a static list since the actual available methods
        # would require navigating through the payment flow
        payment_methods = [
            {
                "id": "DebitCard",
                "name": "Debit Card",
                "type": "card",
                "description": "Pay with your debit card",
                "is_default": True
            },
            {
                "id": "CreditCard",
                "name": "Credit Card",
                "type": "card",
                "description": "Pay with your credit card",
                "is_default": False
            }
        ]
        
        return payment_methods
            
    def __enter__(self):
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.session.close() 